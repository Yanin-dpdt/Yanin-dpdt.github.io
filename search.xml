<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[matplotlib]]></title>
    <url>%2F2019%2F09%2F05%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[GUI编程–matplotlib绘图 numpyarray 12345678910111213141516import numpy as npt1 = np.array([1, 2, 3]) # 存放数组t2 = np.array(range(1,4),dtype = float) # 指定数组类型t6 = t5.astype('int8') # 调整数据类型#random.random() 取小数np.round(t7,2) # 取t7里小数的前两位t1.shape # 返回一个元祖 返回元祖的含义注意！ 第一个是0轴，第二个是1轴...t1.reshape((3, 4)) # 转入一个元祖 把1*12 变成3*4t5.flatte() # 把数据转换成一维的 轴 二维数组里 axis=0 代表行 1代表列 numpy读取数据(.csv) np.loadtxt(fram.dtype = np.float,delimiter = None, skipprows = 0, usecoles = None, unpack=False) fram 文件、字符或者生成器，可以是.gz (文件名) delimiter 分隔字符串，默认空格，可改成， skiprows 跳过前x行，一般跳过第一行表头 usecols 读取指定的列，索引，元祖类型 unpack 如True读入属性分别写入不同数组变量，False 只写入一个数组变量，默认False。(类似于把矩阵旋转了) t1.transpose()数组转置 或者t1.T 索引 切片 t2[2]取第二行 , 取多行t2[2,6,9] 取行t2[1,:] 取列t2[:,[0,2,7]] numpy中数值修改 t2[t2&lt;10] = 3 np.where(t&lt;10,0,10) 小于10是0，大于10是10 t.clip(10,18) 小于10 是10 大于18是18 数组的拼接 np.vstack((t1,t2)) 竖直拼接 np.hstack((t1,t2)) 水平拼接 行列交换t[[1,2],:] = t[[2,1],:] 构造全为0的数组 np.zero((us_data.shape[0],1)) 构造全为1的数组 np.ones((us_data.shape[0],1)) 获取最大值最小值的位置np.argmax(t,axis=0) /np.argmin(t,axis=1) 创建一个对角线为1的正方形数组(方阵)：np.eye(3) numpy的注意点copy和view a=b 完全不复制，a和b相互影响 a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的， a = b.copy(),复制，a和b互不影响 常用的统计函数 求和：t.sum(axis=None) 指定一个轴 均值：t.mean(a,axis=None) 受离群点的影响较大 中值：np.median(t,axis=None) 最大值：t.max(axis=None) 最小值：t.min(axis=None) 极值：np.ptp(t,axis=None) 即最大值和最小值只差 标准差：t.std(axis=None) FuncAnimation动态绘图1、函数FuncAnimation(fig,func,frames,init_func,interval,blit)是绘制动图的主要函数，其参数如下： a.fig 绘制动图的画布名称 b.func自定义动画函数，即下边程序定义的函数update c.frames动画长度，一次循环包含的帧数，在函数运行时，其值会传递给函数update(n)的形参“n” d.init_func自定义开始帧，即传入刚定义的函数init,初始化函数 e.interval更新频率，以ms计 f.blit选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显 12345678910111213141516171819202122import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationfig, ax = plt.subplots() #生成子图，相当于fig = plt.figure(),ax = fig.add_subplot(),其中ax的函数参数表示把当前画布进行分割，例：fig.add_subplot(2,2,2).表示将画布分割为两行两列 #ax在第2个子图中绘制，其中行优先，xdata, ydata = [], [] #初始化两个数组ln, = ax.plot([], [], 'r-', animated=False) #第三个参数表示画曲线的颜色和线型，具体参见：https://blog.csdn.net/tengqingyong/article/details/78829596def init(): ax.set_xlim(0, 2*np.pi) #设置x轴的范围pi代表3.14...圆周率， ax.set_ylim(-1, 1) #设置y轴的范围 return ln, #返回曲线def update(n): xdata.append(n) #将每次传过来的n追加到xdata中 ydata.append(np.sin(n)) ln.set_data(xdata, ydata) #重新设置曲线的值 return ln,ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 10), #这里的frames在调用update函数是会将frames作为实参传递给“n” init_func=init, blit=True)plt.show() PS:一般来说一个动图有两类函数，一类是初始化函数，另一类是需要更新的函数！！ Figure构造器参数说明 class matplotlib.figure.Figure( figsize=None, #Figure的大小，单位是英寸 dpi=None, #分辨率（每英寸的点数） facecolor=None, #修饰的颜色 edgecolor=None, #边界颜色 linewidth=0.0, #线条宽度 frameon=None, #布尔值，是否绘制框架（Frame） subplotpars=None, #子图的参数 tight_layout=None, #取值布尔或者字典，缺省自动布局，False 使用 subplotpars参数，True就使用tight_layout，如果是字典，则包含如下字段：pad, w_pad, h_pad, 与 rect constrained_layout=None) #True就使用constrained_layout，会自动调整plot的位置。]]></content>
      <tags>
        <tag>matplotlib</tag>
        <tag>pyqt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柔性负载-杨明]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E6%9D%A8%E6%98%8E%2F</url>
    <content type="text"><![CDATA[关于杨明老师柔性负载的文献综述制作人：颜世伟 制作时间：2019.8 --- 一、机械谐振建模 [1] 电机和执行机构通过传动轴系联接，传动轴系具有一定的抗扭刚度 K 和阻尼系数 Cw。当传动轴系发生扭转形变时轴系将产生转矩 Tw，此转矩对于电机来说可看作是电机的负载转矩，而对于执行机构来说可看作是驱动转矩。伺服驱动器控制电机运行，为电机的转轴提供电磁转矩 Te。在电机端电磁转矩 Te和传动轴系转矩 Tw作用于转动惯量为 J1、阻尼系数为 C1的电机转轴。在执行机构端，执行机构具有大小为 J2的等效转动惯量以及阻尼系数 C2，传动轴系转矩 Tw与负载转矩Tl共同作用于执行机构最终决定了负载转速。 系统中的阻尼系数很小，可忽略阻尼系数从而对系统模型进行化简得到 传动装置的数学表达： 实际系统模型框图： 根据系统的传递函数画处Bode图(A: ω1/ ωref传递函数的幅频特性曲线. B：ω2/ ω1 . C为A+B) 可以看出闭环系统中存在一个谐振点，系统对于此频率点的响应比较强烈，存在机械谐振。并且谐振频率受系统中的机械谐振频率和振幅主要受到负载转动惯量 J2和传动轴扭转弹性系数 K 两个参数影响. 二、双惯量弹性伺服系统外部机械参数辨识方法综述[5] 参考文献[1] 杨明, 胡浩, 徐殿国. 永磁交流伺服系统机械谐振成因及其抑制[J]. 电机与控制学报, 2012, 16(1):79-84. [2] 杨明, 郝亮, 徐殿国. 基于自适应陷波滤波器的在线机械谐振抑制[J]. 哈尔滨工业大学学报, 2014, 46(4):63-69. [3] 王璨, 杨明, 徐殿国. 基于PI控制的双惯量弹性系统机械谐振的抑制[J]. 电气传动, 2015(1). [4] 杨明, 王璨, 徐殿国. 基于轴矩限幅控制的机械谐振抑制技术[J]. 电机与控制学报, 2015, 19(4):58-64. [5] 王璨, 杨明, 栾添瑞. 双惯量弹性伺服系统外部机械参数辨识综述[J]. 中国电机工程学报, 2016, 36(3):804-817. [6] 杨明, 郝亮, 徐殿国. 双惯量弹性负载系统机械谐振机理分析及谐振特征快速辨识[J]. 电机与控制学报, 2016, 20(04):112-120. [7] 郎志, 杨明, 徐殿国. 双惯量弹性系统负载扰动观测器设计研究[J]. 电工技术学报, 2016(S2):90-97. [8] Beinke S，Wertz H，Schutte F，et al．Identification of nonlinear two-mass systems for self-commissioning speed control of electrical drives[C]//Proceedings of the 24th Annual Conference of the IEEE Industrial Electronics Society．Aachen：IEEE，1998：2251-2256． [9] GuoY J，HuangL P，Muramatsu M．Research on inertia identification and auto-tuning of speed controller for AC servo system[C]//Proceedings of the Power Conversion Conference．Osaka：IEEE，2002：896-901 [10] Östring M ， Gunnarsson S ， Norrlöf M ． Closed-loop identification of an industrial robot containing flexibilities [J]．Control Engineering Practice，2003，11(3)：291-300 [11] Östring M．Closed loop identification of the physical parameters of an industrial robot[C]//Proceedings of the 32nd International Symposium on Robotics ． Seoul ，Korea，2000． [12]Dhaouadi R，KuboK．Transfer function and parameters identification of a motor drive system using adaptive filtering[C]//Proceedings of the 4th International Workshop on Advanced Motion Control．Mie：IEEE，1996：588-593． [13] Eker I，Vural M．Experimental online identification of a three-mass mechanical system[C]//Proceedings of 2003 IEEE Conference on Control Applications．Istanbul，Turkey：IEEE，2003：60-65． [14] Landau I D，Karimi A．An extended output error recursive algorithm for identification in closed loop[C]//Proceedings of the 35th IEEE Conference on Decision and Control．Kobe：IEEE，1996：1405-1410． [15] Eker I，Vural M．Experimental online identification of a three-mass mechanical system[C]//Proceedings of 2003 IEEE Conference on Control Applications．Istanbul，Turkey：IEEE，2003：60-65． [16] Landau I D，Karimi A．An extended output error recursive algorithm for identification in closed loop[C]//Proceedings of the 35th IEEE Conference on Decision and Control．Kobe：IEEE，1996：1405-1410． [17] Zoubek H，Pacas M．A method for speed-sensorless identification of two-mass-systems[C]//Proceedings of the 2010 IEEE Energy Conversion Congress and Exposition．Atlanta，GA：IEEE，2010：4461-4468． [18] YoshiokaY ， HanamotoT ． Estimation of a multimass system using the LWTLS and a coefficient diagram for vibration-controller design[J] ． IEEE Transactions on Industry Applications，2008，44(2)：566-574． [19] Villwock S，Pacas M．Application of the Welch-method for the identification of two-and three-mass-systems [J]．IEEE Transactions on Industrial Electronics，2008，55(1)：457-466．]]></content>
      <tags>
        <tag>PMSM</tag>
        <tag>柔性负载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyqt基础知识]]></title>
    <url>%2F2019%2F08%2F24%2Fpyqt5%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[pqqt基础知识汇总 第一个窗口1、if __name__ == “__main__“: 是代表如果这个文件是主程序这运行下面的代码，如果是被别的程序文件调用的话，则运行下面的代码。 2、__init __ 方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的 初始化 。注意，这个名称的开始和结尾都是双下划线。 3、生成实例（对象）必须以类名()，别忘记了() 4、类中的函数（方法）必须有self，是代表属于这个实例（对象）本身持有的，而外部定义的函数则不需要。 5、QApplication相当于main函数，也就是整个程序（有很多文件）的主入口函数。 ​ 对于一个Gui程序必须至少有一个这样的一个实例来让程序运行。 6、最后一句是调用sys库的exit退出方法，退出条件（参数）是app.exec_()也就是整个窗口关闭。 Qt Designer1、记得在Qt Designer中窗体的layout层次可以通过对象查看器来查看，layout的一些设置可以通过属性编辑器来修该。 2、通常我们使用栅格布局作为顶层布局，将控件放置好之后可以通过右键–布局–栅格布局，将布局充满整个窗体。 3、我们可以先放入控件，然后ctrl选中多个控件，然后点击工具栏上快速布局工具进行布局。 4、在mianwindows中默认会有个centralwidget布局也是继承自QtWidgets.QWidget，表示窗口的中央部分。 信号和槽信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。它为高层次的事件处理自动生成所需要的附加代码。在我们所熟知的很多 GUI 工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。 说实话对于像我这样的新手来说看着就蛋疼，想学会它没办法，我们还是简化一下概念吧：所有QObject类都可以使用信号槽，换句话来说继承自pyqt中的类基本上都可以使用信号槽机制。当然非QObject也是可以通过其他一些办法来使用信号槽的。 仅仅有了信号和槽是不行的，我们还需要了解：信号(Signal)、槽(slot)、连接(connect)、动作事件(action)、发射(emit)、发送者、接受者等等一些列的知识。 在PyQt中接受者和发送者必须是个对象（实例）！ PyQt中的控件中提供了很多信号和槽方法，大家可以多多使用Qt Designer 设计参考！ 槽其实就个函数（方法），Qt5中的槽函数不在限定必须是slot，可以是普通的函数、类的普通成员函数、lambda函数等。编译期间就会检查信号与槽是否存在！ 信号的connect连接最好放在__init__析构函数里面，这样只会声明一次连接，如果在类方法（函数中）使用的话，要记得disconnect，否则connect会连接多次，导致程序异常。 信号槽函数不用加 ()，否则可能会导致连接异常。 PyQt信号和槽传递额外参数使用Pyqt编程过程中，经常会遇到给槽函数传递额外参数的情况。但是信号-槽机制只是指定信号如何连接到槽，信号定义的参数被传递给槽，而额外的参数（用户定义）不能直接传递。 而传递额外参数又是很有用处。你可能使用一个槽处理多个组件的信号，有时要传递额外的信息。 一种方法是使用lambda表达式。 1234567891011121314151617181920212223242526272829from PyQt4.QtCore import *from PyQt4.QtGui import * class MyForm(QMainWindow): def __init__(self, parent=None): super(MyForm, self).__init__(parent) button1 = QPushButton('Button 1') button2 = QPushButton('Button 1') button1.clicked.connect(lambda: self.on_button(1)) button2.clicked.connect(lambda: self.on_button(2)) layout = QHBoxLayout() layout.addWidget(button1) layout.addWidget(button2) main_frame = QWidget() main_frame.setLayout(layout) self.setCentralWidget(main_frame) def on_button(self, n): print('Button &#123;0&#125; clicked'.format(n)) if __name__ == "__main__": import sys app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() 解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用） 第2个方法是使用functools里的partial函数。 1button1.clicked.connect(partial(self.on_button, 1))button2.clicked.connect(partial(self.on_button, 2)) 《Rapid GUI Program with Python and QT》 P143例子。 自定义信号emit及传参12345678910111213141516171819202122232425262728293031from f1 import Ui_MainWindowfrom PyQt5 import QtWidgets,QtCoreimport sys,timeclass MyWindow(QtWidgets.QMainWindow, Ui_MainWindow): # 继承QWidget和Ui_MainWindow _signal = QtCore.pyqtSignal() # 定义信号 def __init__(self): super(MyWindow, self).__init__() self.setupUi(self) #加载窗体 self.pushButton.clicked.connect(self.prn) # 按钮1链接到prn槽函数 # self.pushButton_2.clicked.connect(self.prn) self._signal.connect(self.mysignalslot) # 将信号连接到mysignalslot def prn(self): print('打印测试') time.sleep(1) print('延时1秒') self._signal.emit() #发射信号 def mysignalslot(self): # 自定义槽函数 print('我是slot')if __name__ == '__main__': import sys app = QtWidgets.QApplication(sys.argv) mywindow = MyWindow() # 创建实例 mywindow.show() # 使用QtWidgets的show()方法 sys.exit(app.exec_()) main.py的程序如上所示。实现功能： 注意：当信号与槽函数的参数数量相同时，它们参数类型要完全一致。信号与槽不能有缺省参数。 当信号的参数与槽函数的参数数量不同时，只能是信号的参数数量多于槽函数的参数数量，且前面相同数量的参数类型应一致，信号中多余的参数会被忽略。此外，在不进行参数传递时，信号槽绑定时也是要求信号的参数数量大于等于槽函数的参数数量。这种情况一般是一个带参数的信号去绑定一个无参数的槽函数。 当然可以出传递的参数类型有很多种：str、int、list、object、float、tuple、dict等等 单个文件打开 QFileDialog.getOpenFileName()多个文件打开 QFileDialog.getOpenFileNames() 文件夹选取 QFileDialog.getExistingDirectory() 文件保存 QFileDialog.getSaveFileName() 123456789101112131415161718192021222324252627282930313233343536373839404142from PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QFileDialog class MyWindow(QtWidgets.QWidget): def __init__(self): super(MyWindow,self).__init__() self.myButton = QtWidgets.QPushButton(self) self.myButton.setObjectName("myButton") self.myButton.setText("Test") self.myButton.clicked.connect(self.msg) def msg(self): directory1 = QFileDialog.getExistingDirectory(self, "选取文件夹", "C:/") #起始路径 print(directory1) fileName1, filetype = QFileDialog.getOpenFileName(self, "选取文件", "C:/", "All Files (*);;Text Files (*.txt)") #设置文件扩展名过滤,注意用双分号间隔 print(fileName1,filetype) files, ok1 = QFileDialog.getOpenFileNames(self, "多文件选择", "C:/", "All Files (*);;Text Files (*.txt)") print(files,ok1) fileName2, ok2 = QFileDialog.getSaveFileName(self, "文件保存", "C:/", "All Files (*);;Text Files (*.txt)") print(fileName2,ok2) if __name__=="__main__": import sys app=QtWidgets.QApplication(sys.argv) myshow=MyWindow() myshow.show() sys.exit(app.exec_()) 第一个参数parent，用于指定父组件。注意，很多Qt组件的构造函数都会有这么一个parent参数，并提供一个默认值0,这里一般填 self父类； 第三个参数dir，是对话框显示时默认打开的目录，”.”代表程序运行目录,”/“代表当前盘符下根目录，注意，这里跟平台有关，例如windows可填”C:\“等，Linux下填写”/“根目录 第四个参数Filter，是对话框后缀名过滤器，有Image File(.jpg *png)就让他只能显示后缀名是jpg或者是png的文件。Text Files(.txt)代表后缀名为.txt的文件。All Files()则代表是各种类型的文件。如果需要使用多个过滤器，使用&quot;;;&quot;分割，比如`”JPEG Files(.jpg);;PNG Files(*.png)”；` 各种对话框PyQt5提供了一系列标准的对话框，常见的有：消息对话框QMessageBox、颜色对话框QColorDialog、字体对话框QFontDialog、输入对话框QInputDialog以及文件对话框QFileDialog 1. 颜色对话框和字体对话框这两种对话框分别可以让用户进行颜色和字体选择。两者用法相似，所以就放在一起讲了： 123456789101112131415161718192021222324252627282930313233343536373839import sysfrom PyQt5.QtWidgets import QApplication, QWidget, QTextEdit, QColorDialog, QFontDialog, QPushButton, \ QHBoxLayout, QVBoxLayoutclass Demo(QWidget): def __init__(self): super(Demo, self).__init__() self.text_edit = QTextEdit(self) # 1 self.color_btn = QPushButton('Color', self) # 2 self.font_btn = QPushButton('Font', self) self.color_btn.clicked.connect(lambda: self.open_dialog_func(self.color_btn)) self.font_btn.clicked.connect(lambda: self.open_dialog_func(self.font_btn)) self.h_layout = QHBoxLayout() self.h_layout.addWidget(self.color_btn) self.h_layout.addWidget(self.font_btn) self.v_layout = QVBoxLayout() self.v_layout.addWidget(self.text_edit) self.v_layout.addLayout(self.h_layout) self.setLayout(self.v_layout) def open_dialog_func(self, btn): if btn == self.color_btn: # 3 color = QColorDialog.getColor() if color.isValid(): self.text_edit.setTextColor(color) else: # 4 font, ok = QFontDialog.getFont() if ok: self.text_edit.setFont(font)if __name__ == '__main__': app = QApplication(sys.argv) demo = Demo() demo.show() sys.exit(app.exec_()) QTextEdit控件用于显示文本颜色和字体变化； 实例化两个按钮分别用于打开颜色对话框和字体对话框，然后进行信号和槽的连接； 如果是color_btn被按下的话，则调用QColorDialog的getColor()方法显示颜色对话框，当选择一种颜色后其十六进制的值会保存在color变量中，但如果点击对话框中的取消(Cancel)按钮的话，则color为无效值。通过isValid()方法判断color是否有效，若有效的话则通过setTextColor()方法设置QTextEdit的文本颜色； 如果是font_btn被按下的话，则调用QFontDialog的getFont()方法显示字体对话框，该方法返回两个值，分别为QFont和bool值，如果用户选择了一种字体并按下确定(Ok)的话，则font保存所选择的QFont值，并且ok为True。若按下取消(Cancel)的话，则bool为False。当ok为True时，调用setFont()方法设置QTextEdit的文本字体。 2 输入对话框输入对话框一共有五种输入方法： 下面请看示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from zh22_2 import Ui_MainWindowfrom PyQt5 import QtWidgets,QtCorefrom PyQt5.QtWidgets import QApplication, QWidget, QInputDialog, QLineEdit, QTextEdit, QPushButton, \ QGridLayoutimport sys,timeclass MyWindow(QtWidgets.QMainWindow, Ui_MainWindow): # 继承QWidget和Ui_MainWindow def __init__(self): super().__init__() self.setupUi(self) #加载窗体 self.name_btn.clicked.connect(self.name_f) self.gender_btn.clicked.connect(self.gender_f) self.age_btn.clicked.connect(self.age_f) self.score_btn.clicked.connect(self.score_f) self.info_btn.clicked.connect(self.info_f) def name_f(self): name, ok = QInputDialog.getText(self, 'Name Input', 'Please enter the name:') if ok: self.name_line.setText(name) def gender_f(self): gender_list = ["Man", "Woman"] gender, ok = QInputDialog.getItem(self, 'Geender Input', 'Please select the gender', gender_list) if ok: self.gender_line.setText(gender) def age_f(self): age, ok = QInputDialog.getInt(self, 'Age Input', 'Please enter the age:') if ok: self.age_line.setText(str(age)) def score_f(self): score, ok = QInputDialog.getDouble(self, 'Score Input', 'Please select the score:') if ok: self.score_line.setText(str(score)) def info_f(self): info, ok = QInputDialog.getMultiLineText(self, 'Info Input', 'Please enter the info:') if ok: self.info_line.insertPlainText(info)if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) mywindow = MyWindow() # 创建实例 mywindow.show() # 使用QtWidgets的show()方法 sys.exit(app.exec_()) 前面就是实例化按钮、单行输入框和文本编辑框并通过布局管理器进行排列，我们重点来看下槽函数： 如果是name_btn被点击的话，则调用QInputDialog的getText(parent, str, str)方法，第一个参数为指定的父类，第二个为输入框的标题，第三个为输入框提示。方法会返回一个字符串和一个布尔值，若点击输入框的ok按钮，则变量ok就为True，接着我们调用QLineEdit的setText()方法将其文本设为所输入的内容； getItem(parent, str, str, iterable, int, bool)方法需要多设置几个参数，前三个与getText()相同，第四个参数为要加入的选项内容，这里我们传入了item_list列表，可以让用户选择男性或女性。第五个参数为最初显示的选项，0代表刚开始显示第一个选项，即Female。最后一个参数是选项内容是否可编辑，这里设为False，不可编辑。 其他方法的使用都是类似的，这里就进行省略了。]]></content>
      <tags>
        <tag>pyqt</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2019%2F08%2F14%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第一个python程序 在写代码之前，请千万不要用复制-粘贴把代码从页面粘贴到你自己的电脑上。写程序也讲究一个感觉，你需要一个字母一个字母地把代码自己敲进去，在敲代码的过程中，初学者经常会敲错代码：拼写不对，大小写不对，混用中英文标点，混用空格和Tab键，所以，你需要仔细地检查、对照，才能以最快的速度掌握如何写程序。 直接运行py 有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释： #!/usr/bin/env python3 print(‘hello, world’) 然后，通过命令给hello.py以执行权限： $ chmod a+x hello.py 就可以直接运行hello.py了 python基础 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 //，称为地板除，两个整数的除法仍然是整数 %,取余 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： ‘ABC’.encode(‘ascii’) b’ABC’ ‘中文’.encode(‘utf-8’) b’\xe4\xb8\xad\xe6\x96\x87’ 要计算str包含多少个字符，可以用len()函数 删除list的元素，用pop(i)方法,i为索引 classmates.pop(i) list = [] ; tuple = () ; dict = { ‘ xiaoming ‘: 15 ,} 要删除一个key，用pop(key)方法，对应的value也会从dict中删除 set set和dict类似，也是一组key的集合，但不存储value。 再议不可变对象 上面我们讲了，str是不变对象，而list是可变对象。 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： 1234&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 而对于不可变对象，比如str，对str进行操作呢： 12345&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;)&apos;Abc&apos;&gt;&gt;&gt; a&apos;abc&apos; 虽然字符串有个replace()方法，也确实变出了&#39;Abc&#39;，但变量a最后仍是&#39;abc&#39;，应该怎么理解呢？ 我们先把代码改成下面这样： 123456&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)&gt;&gt;&gt; b&apos;Abc&apos;&gt;&gt;&gt; a&apos;abc&apos; 要始终牢记的是，a是变量，而&#39;abc&#39;才是字符串对象！有些时候，我们经常说，对象a的内容是&#39;abc&#39;，但其实是指，a本身是一个变量，它指向的对象的内容才是&#39;abc&#39;： 123┌───┐ ┌───────┐│ a │─────────────────&gt;│ &apos;abc&apos; │└───┘ └───────┘ 当我们调用a.replace(&#39;a&#39;, &#39;A&#39;)时，实际上调用方法replace是作用在字符串对象&#39;abc&#39;上的，而这个方法虽然名字叫replace，但却没有改变字符串&#39;abc&#39;的内容。相反，replace方法创建了一个新字符串&#39;Abc&#39;并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串&#39;abc&#39;，但变量b却指向新字符串&#39;Abc&#39;了： 123456┌───┐ ┌───────┐│ a │─────────────────&gt;│ &apos;abc&apos; │└───┘ └───────┘┌───┐ ┌───────┐│ b │─────────────────&gt;│ &apos;Abc&apos; │└───┘ └───────┘ 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) 执行这段代码，会依次打印names的每一个元素： 123MichaelBobTracy 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 另外的， 如果要提前结束循环，可以用break语句： 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') 在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 字符串方法及注释 capitalize() 把字符串的第一个字符改为大写 casefold() 把整个字符串的所有字符改为小写 center(width) 将字符串居中，并使用空格填充至长度 width 的新字符串 count(sub[, start[, end]]) 返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。 encode(encoding=’utf-8’, errors=’strict’) 以 encoding 指定的编码格式对字符串进行编码。 endswith(sub[, start[, end]]) 检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。 expandtabs([tabsize=8]) 把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。 find(sub[, start[, end]]) 检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。 index(sub[, start[, end]]) 跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。 isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。 isdecimal() 如果字符串只包含十进制数字则返回 True，否则返回 False。 isdigit() 如果字符串只包含数字则返回 True，否则返回 False。 islower() 如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False。 isspace() 如果字符串中只包含空格，则返回 True，否则返回 False。 istitle() 如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。 isupper() 如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。 join(sub) 以字符串作为分隔符，插入到 sub 中所有的字符之间。 ljust(width) 返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。 lower() 转换字符串中所有大写字符为小写。 lstrip() 去掉字符串左边的所有空格 partition(sub) 找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’) replace(old, new[, count]) 把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。 rfind(sub[, start[, end]]) 类似于 find() 方法，不过是从右边开始查找。 rindex(sub[, start[, end]]) 类似于 index() 方法，不过是从右边开始。 rjust(width) 返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。 rpartition(sub) 类似于 partition() 方法，不过是从右边开始查找。 rstrip() 删除字符串末尾的空格。 split(sep=None, maxsplit=-1) 不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。 splitlines(([keepends])) 在输出结果里是否去掉换行符，默认为 False，不包含换行符；如果为 True，则保留换行符。。 startswith(prefix[, start[, end]]) 检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。 strip([chars]) 删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。 swapcase() 翻转字符串中的大小写。 title() 返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。 translate(table) 根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符。 upper() 转换字符串中的所有小写字符为大写。 zfill(width) 返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。 函数 定义默认参数要牢记一点：默认参数必须指向不变对象！ 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。 文件文件打开模式 打开模式 执行操作 ‘r’ 以只读方式打开文件（默认） ‘w’ 以写入的方式打开文件，会覆盖已存在的文件 ‘x’ 如果文件已经存在，使用此模式打开将引发异常 ‘a’ 以写入模式打开，如果文件存在，则在末尾追加写入 ‘b’ 以二进制模式打开文件 ‘t’ 以文本模式打开（默认） ‘+’ 可读写模式（可添加到其他模式中使用） ‘U’ 通用换行符支持 ​ 文件对象方法 文件对象方法 执行操作 f.close() 关闭文件 f.read([size=-1]) 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回 f.readline([size=-1]) 从文件中读取并返回一行（包括行结束符），如果有size有定义则返回size个字符 f.write(str) 将字符串str写入文件 f.writelines(seq) 向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象 f.seek(offset, from) 在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节 f.tell() 返回当前在文件中的位置 f.truncate([size=file.tell()]) 截取文件到size个字节，默认是截取到文件指针当前位置 OS模块 os模块中关于文件/目录常用的函数使用方法 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path=’.’) 列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：’E:\a\b’和’E:\a\c’并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（’.’） os.pardir 指代上一级目录（’..’） os.sep 输出操作系统特定的路径分隔符（Win下为’\‘，Linux下为’/‘） os.linesep 当前平台使用的行终止符（Win下为’\r\n’，Linux下为’\n’） os.name 指代当前使用的操作系统（包括：’posix’, ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’） os.path模块中关于路径常用的函数使用方法 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, …]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 标准异常Python标准异常总结 AssertionError 断言语句（assert）失败 AttributeError 尝试访问未知的对象属性 EOFError 用户输入文件末尾标志EOF（Ctrl+d） FloatingPointError 浮点计算错误 GeneratorExit generator.close()方法被调用的时候 ImportError 导入模块失败的时候 IndexError 索引超出序列的范围 KeyError 字典中查找一个不存在的关键字 KeyboardInterrupt 用户输入中断键（Ctrl+c） MemoryError 内存溢出（可通过删除对象释放内存） NameError 尝试访问一个不存在的变量 NotImplementedError 尚未实现的方法 OSError 操作系统产生的异常（例如打开一个不存在的文件） OverflowError 数值运算超出最大限制 ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象 RuntimeError 一般的运行时错误 StopIteration 迭代器没有更多的值 SyntaxError Python的语法错误 IndentationError 缩进错误 TabError Tab和空格混合使用 SystemError Python编译器系统错误 SystemExit Python编译器进程被关闭 TypeError 不同类型间的无效操作 UnboundLocalError 访问一个未初始化的本地变量（NameError的子类） UnicodeError Unicode相关的错误（ValueError的子类） UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类） UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类） UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类） ValueError 传入无效的参数 ZeroDivisionError 除数为零 以下是 Python 内置异常类的层次结构： BaseException+– SystemExit+– KeyboardInterrupt+– GeneratorExit+– Exception +– StopIteration +– ArithmeticError | +– FloatingPointError | +– OverflowError | +– ZeroDivisionError +– AssertionError +– AttributeError +– BufferError +– EOFError +– ImportError +– LookupError | +– IndexError | +– KeyError +– MemoryError +– NameError | +– UnboundLocalError +– OSError | +– BlockingIOError | +– ChildProcessError | +– ConnectionError | | +– BrokenPipeError | | +– ConnectionAbortedError | | +– ConnectionRefusedError | | +– ConnectionResetError | +– FileExistsError | +– FileNotFoundError | +– InterruptedError | +– IsADirectoryError | +– NotADirectoryError | +– PermissionError | +– ProcessLookupError | +– TimeoutError +– ReferenceError +– RuntimeError | +– NotImplementedError +– SyntaxError | +– IndentationError | +– TabError +– SystemError +– TypeError +– ValueError | +– UnicodeError | +– UnicodeDecodeError | +– UnicodeEncodeError | +– UnicodeTranslateError +– Warning +– DeprecationWarning +– PendingDeprecationWarning +– RuntimeWarning +– SyntaxWarning +– UserWarning +– FutureWarning +– ImportWarning +– UnicodeWarning +– BytesWarning +– ResourceWarning 对象对象 = 属性 + 方法 类是为了让对象实现量产. self指的是类实例对象本身(注意：不是类本身) 若子类会覆盖父类的__init__时，可采用(1)调用父类 父类.__init__(self) (2) supur().__init__() import在Python中，如果import的语句比较长，导致后续引用不方便，可以使用as语法，比如： import dir1.dir2.mod 那么，后续对mod的引用，都必须是dir1.dir2.mod dir1.dir2.mod.X那么，为了简化输入，可以使用as语法： import dir1.dir2.mod as m 那么，后续对mod的引用，可以直接使用m m. X 需要注意的是，使用as语法之后，只能通过as后面名字来访问导入的moudle import mod as m m.X # OK mod.X # Error 下面提供as的完整语法格式，import和from都支持： import modulename as name # 只能通过name来引用 from modulename import attrname as name # 只能通过name来引用 魔法方法(左右两边两个下划线) 魔法方法 含义 基本的魔法方法 new(cls[, …]) 1. new 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法 3. new 决定是否要使用该 init 方法，因为 new 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 new 没有返回实例对象，则 init 不会被调用 4. new 主要是用于继承一个不可变的类型比如一个 tuple 或者 string init(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 del(self) 析构器，当一个实例被销毁的时候调用的方法 call(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) len(self) 定义当被 len() 调用时的行为 repr(self) 定义当被 repr() 调用时的行为 str(self) 定义当被 str() 调用时的行为 bytes(self) 定义当被 bytes() 调用时的行为 hash(self) 定义当被 hash() 调用时的行为 bool(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False format(self, format_spec) 定义当被 format() 调用时的行为 有关属性 getattr(self, name) 定义当用户试图获取一个不存在的属性时的行为 getattribute(self, name) 定义当该类的属性被访问时的行为 setattr(self, name, value) 定义当一个属性被设置时的行为 delattr(self, name) 定义当一个属性被删除时的行为 dir(self) 定义当 dir() 被调用时的行为 get(self, instance, owner) 定义当描述符的值被取得时的行为 set(self, instance, value) 定义当描述符的值被改变时的行为 delete(self, instance) 定义当描述符的值被删除时的行为 比较操作符 lt(self, other) 定义小于号的行为：x &lt; y 调用 x.lt(y) le(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.le(y) eq(self, other) 定义等于号的行为：x == y 调用 x.eq(y) ne(self, other) 定义不等号的行为：x != y 调用 x.ne(y) gt(self, other) 定义大于号的行为：x &gt; y 调用 x.gt(y) ge(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.ge(y) 算数运算符 add(self, other) 定义加法的行为：+ sub(self, other) 定义减法的行为：- mul(self, other) 定义乘法的行为：* truediv(self, other) 定义真除法的行为：/ floordiv(self, other) 定义整数除法的行为：// mod(self, other) 定义取模算法的行为：% divmod(self, other) 定义当被 divmod() 调用时的行为 pow(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 lshift(self, other) 定义按位左移位的行为：&lt;&lt; rshift(self, other) 定义按位右移位的行为：&gt;&gt; and(self, other) 定义按位与操作的行为：&amp; xor(self, other) 定义按位异或操作的行为：^ or(self, other) 定义按位或操作的行为：| 反运算 radd(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rsub(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmul(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rtruediv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rfloordiv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rdivmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rpow(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rlshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rrshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rand(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rxor(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） ror(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 iadd(self, other) 定义赋值加法的行为：+= isub(self, other) 定义赋值减法的行为：-= imul(self, other) 定义赋值乘法的行为：*= itruediv(self, other) 定义赋值真除法的行为：/= ifloordiv(self, other) 定义赋值整数除法的行为：//= imod(self, other) 定义赋值取模算法的行为：%= ipow(self, other[, modulo]) 定义赋值幂运算的行为：**= ilshift(self, other) 定义赋值按位左移位的行为：&lt;&lt;= irshift(self, other) 定义赋值按位右移位的行为：&gt;&gt;= iand(self, other) 定义赋值按位与操作的行为：&amp;= ixor(self, other) 定义赋值按位异或操作的行为：^= ior(self, other) 定义赋值按位或操作的行为：|= 一元操作符 pos(self) 定义正号的行为：+x neg(self) 定义负号的行为：-x abs(self) 定义当被 abs() 调用时的行为 invert(self) 定义按位求反的行为：~x 类型转换 complex(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） int(self) 定义当被 int() 调用时的行为（需要返回恰当的值） float(self) 定义当被 float() 调用时的行为（需要返回恰当的值） round(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） index(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句） enter(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 exit(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 len(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） getitem(self, key) 定义获取容器中指定元素的行为，相当于 self[key] setitem(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value delitem(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] iter(self) 定义当迭代容器中的元素的行为 reversed(self) 定义当被 reversed() 调用时的行为 contains(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 super()不是父类，而是继承顺序的下一个类super()可以避免重复调用 如果childA基础Base, childB继承childA和Base，如果childB需要调用Base的init()方法时，就会导致init()被执行两次： 1234567891011121314151617class Base(object): def __init__(self): print 'Base create'class childA(Base): def __init__(self): print 'enter A ' Base.__init__(self) print 'leave A'class childB(childA, Base): def __init__(self): childA.__init__(self) Base.__init__(self)b = childB() Base的init()方法被执行了两次 1234enter A Base createleave ABase create 使用super()是可避免重复调用 123456789101112131415161718192021class Base(object): def __init__(self): print 'Base create'class childA(Base): def __init__(self): print 'enter A ' super(childA, self).__init__() print 'leave A'class childB(childA, Base): def __init__(self): super(childB, self).__init__()b = childB()print b.__class__.mro()enter A Base createleave A[&lt;class '__main__.childB'&gt;, &lt;class '__main__.childA'&gt;, &lt;class '__main__.Base'&gt;, &lt;type 'object'&gt;] Python变量前’‘和’*‘的作用在Python的在形参前加’‘和’*‘表示动态形参 在形参前加’*’表示可以接受多个实参值存进数组 12345678910def F(a, *b) print(a) print(b)F(1, 2, 3)&apos;&apos;&apos;1 (2, 3)&apos;&apos;&apos; 对于在形参前加’**’表示表示接受参数转化为字典类型 123456def F(**a) print(a)F(x=1, y=2)#&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125; 混合运用 123456789101112def F(a, *b, **c) print(a) print(b) print(c)F(1, 2, 3, x=4, y=5)&apos;&apos;&apos;1(2, 3)&#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;&apos;&apos;&apos; 1234567891011def F(*a) print(a)ls = [1, 2, 3]F(ls) #表示列表作为一个元素传入F(*ls) #表示列表元素作为多个元素传入'''([1, 2, 3],)(1, 2, 3)''' 12345678910111213141516def F(**a) print(a)dt = dict(x=1, y=2)F(x=1, y=2) F(**dt) #作为字典传入'''&#123;'x': 1, 'y':2&#125;&#123;'x': 1, 'y':2&#125;函数调用时dt = dict(color='red', fontproperties='SimHei')plt.plot(**dt) 等价于plt.plot(color='red', fontproperties='SimHei')''']]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP开发板灯光控制上位机]]></title>
    <url>%2F2019%2F08%2F12%2FDSP%E5%BC%80%E5%8F%91%E6%9D%BF%E7%81%AF%E5%85%89%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BD%8D%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[想法在前几天对PYQT5的学习以后，自己试着做了一个上位机 来对DSP开发板实现LED亮灭操作。 软硬件:pycharm + PYQT5 + CCS6.0 + DSP开发板 成果上位机界面 LED控制 描述：当按下 &lt;打开1灯&gt;时 1亮、2灭。当按下 &lt;打开2灯&gt;时 2亮、1灭。 遇到的问题 在CCS对GPIO进行写操作时(GPXDTA.bit = ) 无法成功写入，在顺华师兄建议下 改用SET CLEAR操作解决. 至于为何DAT不好用还未知？ 关于串口发送 16进制问题 代码 ui_demo.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'ui_demo_1.ui'## Created by: PyQt5 UI code generator 5.11.3## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_Form(object): def setupUi(self, Form): Form.setObjectName("Form") Form.resize(868, 452) self.formGroupBox = QtWidgets.QGroupBox(Form) self.formGroupBox.setGeometry(QtCore.QRect(20, 20, 167, 301)) self.formGroupBox.setObjectName("formGroupBox") self.formLayout = QtWidgets.QFormLayout(self.formGroupBox) self.formLayout.setContentsMargins(10, 10, 10, 10) self.formLayout.setSpacing(10) self.formLayout.setObjectName("formLayout") self.s1__lb_1 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_1.setObjectName("s1__lb_1") self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.s1__lb_1) self.s1__box_1 = QtWidgets.QPushButton(self.formGroupBox) self.s1__box_1.setAutoRepeatInterval(100) self.s1__box_1.setDefault(True) self.s1__box_1.setObjectName("s1__box_1") self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.s1__box_1) self.s1__lb_2 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_2.setObjectName("s1__lb_2") self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.s1__lb_2) self.s1__box_2 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_2.setObjectName("s1__box_2") self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.s1__box_2) self.s1__lb_3 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_3.setObjectName("s1__lb_3") self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.s1__lb_3) self.s1__box_3 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_3.setObjectName("s1__box_3") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.s1__box_3) self.s1__lb_4 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_4.setObjectName("s1__lb_4") self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.s1__lb_4) self.s1__box_4 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_4.setObjectName("s1__box_4") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.formLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.s1__box_4) self.s1__lb_5 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_5.setObjectName("s1__lb_5") self.formLayout.setWidget(5, QtWidgets.QFormLayout.LabelRole, self.s1__lb_5) self.s1__box_5 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_5.setObjectName("s1__box_5") self.s1__box_5.addItem("") self.formLayout.setWidget(5, QtWidgets.QFormLayout.FieldRole, self.s1__box_5) self.open_button = QtWidgets.QPushButton(self.formGroupBox) self.open_button.setObjectName("open_button") self.formLayout.setWidget(7, QtWidgets.QFormLayout.SpanningRole, self.open_button) self.close_button = QtWidgets.QPushButton(self.formGroupBox) self.close_button.setObjectName("close_button") self.formLayout.setWidget(8, QtWidgets.QFormLayout.SpanningRole, self.close_button) self.s1__lb_6 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_6.setObjectName("s1__lb_6") self.formLayout.setWidget(6, QtWidgets.QFormLayout.LabelRole, self.s1__lb_6) self.s1__box_6 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_6.setObjectName("s1__box_6") self.s1__box_6.addItem("") self.formLayout.setWidget(6, QtWidgets.QFormLayout.FieldRole, self.s1__box_6) self.state_label = QtWidgets.QLabel(self.formGroupBox) self.state_label.setText("") self.state_label.setTextFormat(QtCore.Qt.AutoText) self.state_label.setScaledContents(True) self.state_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter) self.state_label.setObjectName("state_label") self.formLayout.setWidget(2, QtWidgets.QFormLayout.SpanningRole, self.state_label) self.verticalGroupBox = QtWidgets.QGroupBox(Form) self.verticalGroupBox.setGeometry(QtCore.QRect(210, 20, 401, 241)) self.verticalGroupBox.setObjectName("verticalGroupBox") self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalGroupBox) self.verticalLayout.setContentsMargins(10, 10, 10, 10) self.verticalLayout.setObjectName("verticalLayout") self.s2__receive_text = QtWidgets.QTextBrowser(self.verticalGroupBox) self.s2__receive_text.setObjectName("s2__receive_text") self.verticalLayout.addWidget(self.s2__receive_text) self.verticalGroupBox_2 = QtWidgets.QGroupBox(Form) self.verticalGroupBox_2.setGeometry(QtCore.QRect(210, 280, 401, 101)) self.verticalGroupBox_2.setObjectName("verticalGroupBox_2") self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalGroupBox_2) self.verticalLayout_2.setContentsMargins(10, 10, 10, 10) self.verticalLayout_2.setObjectName("verticalLayout_2") self.s3__send_text = QtWidgets.QTextEdit(self.verticalGroupBox_2) self.s3__send_text.setObjectName("s3__send_text") self.verticalLayout_2.addWidget(self.s3__send_text) self.s3__send_button = QtWidgets.QPushButton(Form) self.s3__send_button.setGeometry(QtCore.QRect(620, 310, 61, 31)) self.s3__send_button.setObjectName("s3__send_button") self.s3__clear_button = QtWidgets.QPushButton(Form) self.s3__clear_button.setGeometry(QtCore.QRect(620, 350, 61, 31)) self.s3__clear_button.setObjectName("s3__clear_button") self.formGroupBox1 = QtWidgets.QGroupBox(Form) self.formGroupBox1.setGeometry(QtCore.QRect(20, 340, 171, 101)) self.formGroupBox1.setObjectName("formGroupBox1") self.formLayout_2 = QtWidgets.QFormLayout(self.formGroupBox1) self.formLayout_2.setContentsMargins(10, 10, 10, 10) self.formLayout_2.setSpacing(10) self.formLayout_2.setObjectName("formLayout_2") self.label = QtWidgets.QLabel(self.formGroupBox1) self.label.setObjectName("label") self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.label) self.label_2 = QtWidgets.QLabel(self.formGroupBox1) self.label_2.setObjectName("label_2") self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.label_2) self.lineEdit = QtWidgets.QLineEdit(self.formGroupBox1) self.lineEdit.setObjectName("lineEdit") self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.lineEdit) self.lineEdit_2 = QtWidgets.QLineEdit(self.formGroupBox1) self.lineEdit_2.setObjectName("lineEdit_2") self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.lineEdit_2) self.hex_send = QtWidgets.QCheckBox(Form) self.hex_send.setGeometry(QtCore.QRect(620, 280, 71, 16)) self.hex_send.setObjectName("hex_send") self.hex_receive = QtWidgets.QCheckBox(Form) self.hex_receive.setGeometry(QtCore.QRect(620, 40, 71, 16)) self.hex_receive.setObjectName("hex_receive") self.s2__clear_button = QtWidgets.QPushButton(Form) self.s2__clear_button.setGeometry(QtCore.QRect(620, 80, 61, 31)) self.s2__clear_button.setObjectName("s2__clear_button") self.timer_send_cb = QtWidgets.QCheckBox(Form) self.timer_send_cb.setGeometry(QtCore.QRect(260, 390, 71, 16)) self.timer_send_cb.setObjectName("timer_send_cb") self.lineEdit_3 = QtWidgets.QLineEdit(Form) self.lineEdit_3.setGeometry(QtCore.QRect(350, 390, 61, 20)) self.lineEdit_3.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter) self.lineEdit_3.setObjectName("lineEdit_3") self.dw = QtWidgets.QLabel(Form) self.dw.setGeometry(QtCore.QRect(420, 390, 54, 20)) self.dw.setObjectName("dw") self.line = QtWidgets.QFrame(Form) self.line.setGeometry(QtCore.QRect(700, 30, 20, 351)) self.line.setFrameShape(QtWidgets.QFrame.VLine) self.line.setFrameShadow(QtWidgets.QFrame.Sunken) self.line.setObjectName("line") self.s4__open1_button = QtWidgets.QPushButton(Form) self.s4__open1_button.setGeometry(QtCore.QRect(740, 160, 61, 31)) self.s4__open1_button.setObjectName("s4__open1_button") self.s4__open2_button = QtWidgets.QPushButton(Form) self.s4__open2_button.setGeometry(QtCore.QRect(740, 210, 61, 31)) self.s4__open2_button.setObjectName("s4__open2_button") self.verticalGroupBox.raise_() self.verticalGroupBox_2.raise_() self.formGroupBox.raise_() self.s3__send_button.raise_() self.s3__clear_button.raise_() self.formGroupBox.raise_() self.hex_send.raise_() self.hex_receive.raise_() self.s2__clear_button.raise_() self.timer_send_cb.raise_() self.lineEdit_3.raise_() self.dw.raise_() self.line.raise_() self.s4__open1_button.raise_() self.s4__open2_button.raise_() self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate = QtCore.QCoreApplication.translate Form.setWindowTitle(_translate("Form", "Form")) self.formGroupBox.setTitle(_translate("Form", "串口设置")) self.s1__lb_1.setText(_translate("Form", "串口检测：")) self.s1__box_1.setText(_translate("Form", "检测串口")) self.s1__lb_2.setText(_translate("Form", "串口选择：")) self.s1__lb_3.setText(_translate("Form", "波特率：")) self.s1__box_3.setItemText(0, _translate("Form", "115200")) self.s1__box_3.setItemText(1, _translate("Form", "2400")) self.s1__box_3.setItemText(2, _translate("Form", "4800")) self.s1__box_3.setItemText(3, _translate("Form", "9600")) self.s1__box_3.setItemText(4, _translate("Form", "14400")) self.s1__box_3.setItemText(5, _translate("Form", "19200")) self.s1__box_3.setItemText(6, _translate("Form", "38400")) self.s1__box_3.setItemText(7, _translate("Form", "57600")) self.s1__box_3.setItemText(8, _translate("Form", "76800")) self.s1__box_3.setItemText(9, _translate("Form", "12800")) self.s1__box_3.setItemText(10, _translate("Form", "230400")) self.s1__box_3.setItemText(11, _translate("Form", "460800")) self.s1__lb_4.setText(_translate("Form", "数据位：")) self.s1__box_4.setItemText(0, _translate("Form", "8")) self.s1__box_4.setItemText(1, _translate("Form", "7")) self.s1__box_4.setItemText(2, _translate("Form", "6")) self.s1__box_4.setItemText(3, _translate("Form", "5")) self.s1__lb_5.setText(_translate("Form", "校验位：")) self.s1__box_5.setItemText(0, _translate("Form", "N")) self.open_button.setText(_translate("Form", "打开串口")) self.close_button.setText(_translate("Form", "关闭串口")) self.s1__lb_6.setText(_translate("Form", "停止位：")) self.s1__box_6.setItemText(0, _translate("Form", "1")) self.verticalGroupBox.setTitle(_translate("Form", "接受区")) self.verticalGroupBox_2.setTitle(_translate("Form", "发送区")) self.s3__send_text.setHtml(_translate("Form", "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\n""&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\n""p, li &#123; white-space: pre-wrap; &#125;\n""&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\"&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;123456&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;")) self.s3__send_button.setText(_translate("Form", "发送")) self.s3__clear_button.setText(_translate("Form", "清除")) self.formGroupBox1.setTitle(_translate("Form", "串口状态")) self.label.setText(_translate("Form", "已接收：")) self.label_2.setText(_translate("Form", "已发送：")) self.hex_send.setText(_translate("Form", "Hex发送")) self.hex_receive.setText(_translate("Form", "Hex接收")) self.s2__clear_button.setText(_translate("Form", "清除")) self.timer_send_cb.setText(_translate("Form", "定时发送")) self.lineEdit_3.setText(_translate("Form", "1000")) self.dw.setText(_translate("Form", "ms/次")) self.s4__open1_button.setText(_translate("Form", "打开1灯")) self.s4__open2_button.setText(_translate("Form", "打开2灯")) ui_demo.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import sysimport serialimport serial.tools.list_portsfrom PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QMessageBoxfrom PyQt5.QtCore import QTimerfrom ui_demo_1 import Ui_Formclass Pyqt5_Serial(QtWidgets.QWidget, Ui_Form): def __init__(self): super(Pyqt5_Serial, self).__init__() self.setupUi(self) self.init() self.setWindowTitle("串口小助手") self.ser = serial.Serial() self.port_check() # 接收数据和发送数据数目置零 self.data_num_received = 0 self.lineEdit.setText(str(self.data_num_received)) self.data_num_sended = 0 self.lineEdit_2.setText(str(self.data_num_sended)) def init(self): # 串口检测按钮 self.s1__box_1.clicked.connect(self.port_check) # 串口信息显示 self.s1__box_2.currentTextChanged.connect(self.port_imf) # 打开串口按钮 self.open_button.clicked.connect(self.port_open) # 关闭串口按钮 self.close_button.clicked.connect(self.port_close) # 发送数据按钮 self.s3__send_button.clicked.connect(self.data_send) # 定时发送数据 self.timer_send = QTimer() self.timer_send.timeout.connect(self.data_send) self.timer_send_cb.stateChanged.connect(self.data_send_timer) # 定时器接收数据 self.timer = QTimer(self) self.timer.timeout.connect(self.data_receive) # 清除发送窗口 self.s3__clear_button.clicked.connect(self.send_data_clear) # 清除接收窗口 self.s2__clear_button.clicked.connect(self.receive_data_clear) # 打开1灯 self.s4__open1_button.clicked.connect(self.open_led1) # 打开2灯 self.s4__open2_button.clicked.connect(self.open_led2) # 串口检测 def port_check(self): # 检测所有存在的串口，将信息存储在字典中 self.Com_Dict = &#123;&#125; port_list = list(serial.tools.list_ports.comports()) self.s1__box_2.clear() for port in port_list: self.Com_Dict["%s" % port[0]] = "%s" % port[1] self.s1__box_2.addItem(port[0]) if len(self.Com_Dict) == 0: self.state_label.setText(" 无串口") # 串口信息 def port_imf(self): # 显示选定的串口的详细信息 imf_s = self.s1__box_2.currentText() if imf_s != "": self.state_label.setText(self.Com_Dict[self.s1__box_2.currentText()]) # 打开串口 def port_open(self): self.ser.port = self.s1__box_2.currentText() self.ser.baudrate = int(self.s1__box_3.currentText()) self.ser.bytesize = int(self.s1__box_4.currentText()) self.ser.stopbits = int(self.s1__box_6.currentText()) self.ser.parity = self.s1__box_5.currentText() try: self.ser.open() except: QMessageBox.critical(self, "Port Error", "此串口不能被打开！") return None # 打开串口接收定时器，周期为2ms self.timer.start(2) if self.ser.isOpen(): self.open_button.setEnabled(False) self.close_button.setEnabled(True) self.formGroupBox1.setTitle("串口状态（已开启）") # 关闭串口 def port_close(self): self.timer.stop() self.timer_send.stop() try: self.ser.close() except: pass self.open_button.setEnabled(True) self.close_button.setEnabled(False) self.lineEdit_3.setEnabled(True) # 接收数据和发送数据数目置零 self.data_num_received = 0 self.lineEdit.setText(str(self.data_num_received)) self.data_num_sended = 0 self.lineEdit_2.setText(str(self.data_num_sended)) self.formGroupBox1.setTitle("串口状态（已关闭）") # 发送数据 def data_send(self): if self.ser.isOpen(): input_s = self.s3__send_text.toPlainText() if input_s != "": # 非空字符串 if self.hex_send.isChecked(): # hex发送 input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) else: # ascii发送 input_s = (input_s + '\r\n').encode('utf-8') num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended)) else: pass # 接收数据 def data_receive(self): try: num = self.ser.inWaiting() except: self.port_close() return None if num &gt; 0: data = self.ser.read(num) num = len(data) # hex显示 if self.hex_receive.checkState(): out_s = '' for i in range(0, len(data)): out_s = out_s + '&#123;:02X&#125;'.format(data[i]) + ' ' self.s2__receive_text.insertPlainText(out_s) else: # 串口接收到的字符串为b'123',要转化成unicode字符串才能输出到窗口中去 self.s2__receive_text.insertPlainText(data.decode('iso-8859-1')) # 统计接收字符的数量 self.data_num_received += num self.lineEdit.setText(str(self.data_num_received)) # 获取到text光标 textCursor = self.s2__receive_text.textCursor() # 滚动到底部 textCursor.movePosition(textCursor.End) # 设置光标到text中去 self.s2__receive_text.setTextCursor(textCursor) else: pass # 定时发送数据 def data_send_timer(self): if self.timer_send_cb.isChecked(): self.timer_send.start(int(self.lineEdit_3.text())) self.lineEdit_3.setEnabled(False) else: self.timer_send.stop() self.lineEdit_3.setEnabled(True) # 清除显示 def send_data_clear(self): self.s3__send_text.setText("") def receive_data_clear(self): self.s2__receive_text.setText("") def open_led1(self): input_s = '1' input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended)) def open_led2(self): input_s = '2' input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended))if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) myshow = Pyqt5_Serial() myshow.show() sys.exit(app.exec_()) CCS源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include "DSP2833x_Device.h" // DSP2833x 头文件#include "DSP2833x_Examples.h" // DSP2833x 例子相关头文件/**************************************函数声明************************************************/void scib_echoback_init(void);void scib_xmit(int a);void scib_msg(char *msg);/**********************************************************************************************/// 使用前，声明本文件中的相关函数；void configtestled(void);/**************************************宏定义************************************************/#define InitDIR() \ EALLOW; \ GpioCtrlRegs.GPBPUD.bit.GPIO49 = 0; \ GpioCtrlRegs.GPBDIR.bit.GPIO49 = 1; \ GpioDataRegs.GPBCLEAR.bit.GPIO49 = 1; \ EDIS;#define RX_EN GpioDataRegs.GPBCLEAR.bit.GPIO49 = 1;#define TX_EN GpioDataRegs.GPBSET.bit.GPIO49 = 1;/**********************************************************************************************/void main(void)&#123; Uint16 ReceivedChar; //变量定义 char *msg; //指针// 步骤 1. 初始化系统控制:// 设置PLL, WatchDog, 使能外设时钟// 下面这个函数可以从DSP2833x_SysCtrl.c文件中找到.. InitSysCtrl(); InitScibGpio();// 步骤 2. 初始化通用输入输出多路复用器GPIO:// 这个函数在DSP2833x_Gpio.c源文件中被定义了// 这个函数使GPIO控制类寄存器初始化到默认状态// InitGpio(); // 本例不用此子函数 InitDIR();// 本例使用下面的GPIO配置 configtestled();// 总线初始化函数 InitXintf16Gpio(); //zq// 步骤 3. 清除所有中断初始化中断向量表:// 禁止CPU全局中断 DINT;// 初始化PIE控制寄存器到他们的默认状态.// 这个默认状态就是禁止PIE中断及清除所有PIE中断标志// 这个函数放在DSP2833x_PieCtrl.c源文件里 InitPieCtrl();// 禁止CPU中断和清除所有CPU中断标志 IER = 0x0000; IFR = 0x0000;//初始化PIE中断向量表，并使其指向中断服务子程序（ISR）// 这些中断服务子程序被放在了DSP280x_DefaultIsr.c源文件中// 这个函数放在了DSP2833x_PieVect.c源文件里面. InitPieVectTable(); // 步骤 4. 初始化片内外设:// 这个函数可以在DSP280x_CpuTimers.c源文件中找到// InitCpuTimers(); // 这个例子仅初始化了Cpu定时器// 步骤 5. 用户特定的代码 scib_echoback_init(); msg = "\r\n\nled control\0"; //发送语句 scib_msg(msg); //发送函数 msg = "\r\n \n\0"; //发送语句 scib_msg(msg); //发送函数 GpioDataRegs.GPASET.bit.GPIO1 = 1; GpioDataRegs.GPASET.bit.GPIO2 = 1; for(;;) &#123; msg = "\r\n \0"; //发送语句 scib_msg(msg); //发送函数 //等待接收到数据，否则在此循环 while(ScibRegs.SCIRXST.bit.RXRDY !=1) &#123; &#125; // wait for XRDY =1 for empty state //把接收BUF里的数据赋值给ReceivedChar ReceivedChar = ScibRegs.SCIRXBUF.all; msg = " led open \0"; //发送语句 scib_msg(msg); //发送函数 scib_xmit(ReceivedChar); //发送ReceivedChar if(ScibRegs.SCIRXBUF.all == 1) &#123; GpioDataRegs.GPACLEAR.bit.GPIO1 = 1; GpioDataRegs.GPASET.bit.GPIO2 = 1; msg = "1"; scib_msg(msg); &#125; else if (ScibRegs.SCIRXBUF.all == 2) &#123; GpioDataRegs.GPACLEAR.bit.GPIO2 = 1; GpioDataRegs.GPASET.bit.GPIO1 = 1; msg = "2"; scib_msg(msg); &#125;&#125;void configtestled(void) //GPIO初始化函数&#123; EALLOW; GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 0; // GPIO0复用为GPIO功能 GpioCtrlRegs.GPADIR.bit.GPIO1 = 1; // GPIO0设置为输出 GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 0; // GPIO1复用为GPIO功能 GpioCtrlRegs.GPADIR.bit.GPIO2 = 1; // GPIO1设置为输出 EDIS;&#125;void scib_echoback_init()&#123; // Note: Clocks were turned on to the SCIA peripheral // in the InitSysCtrl() function //SCI的工作模式和参数需要用户在后面的学习中，深入的了解一个寄存器底层相关的资料了，多看看芯片手册和寄存器的意思。 //因为28335的寄存器太多了，所以在以后的学习过程中，就不会对寄存器进行详细的注释了。 ScibRegs.SCICTL1.bit.SWRESET =0; ScibRegs.SCICCR.all =0x0007; // 1 stop bit, No loopback // No parity,8 char bits, // async mode, idle-line protocol ScibRegs.SCICTL1.all =0x0003; // enable TX, RX, internal SCICLK, // Disable RX ERR, SLEEP, TXWAKE #if (CPU_FRQ_150MHZ) ScibRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 37.5MHz. ScibRegs.SCILBAUD =0x00E7; #endif #if (CPU_FRQ_100MHZ) ScibRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 20MHz. ScibRegs.SCILBAUD =0x0044; #endif ScibRegs.SCICTL1.all =0x0023; // Relinquish SCI from Reset&#125;// Transmit a character from the SCIvoid scib_xmit(int a) //发送字节的函数&#123; while (ScibRegs.SCICTL2.bit.TXRDY == 0) &#123;&#125; ScibRegs.SCITXBUF=a;&#125;void scib_msg(char * msg) //发送数组的函数&#123; int i; i = 0; TX_EN; while(msg[i] != '\0') &#123; scib_xmit(msg[i]); i++; &#125; RX_EN;&#125;//===========================================================================// No more.//=========================================================================== 参考[1] 参考的串口程序 [2] 王硕,孙洋洋.PyQt5快速开发与实战[M].电子工业出版社:北京,2017]]></content>
      <tags>
        <tag>上位机</tag>
        <tag>DSP开发板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP基础知识一览]]></title>
    <url>%2F2019%2F08%2F10%2FDSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[CCS编程基础CCS开发环境已经为我们封装好了许多片内外设寄存器的结构体，我们只需要包含相应的官方的头文件就可以使用了，那么它的内部具体是如何实现的呢？ 下面来一个典型的例子： 1.使用结构体和联合体A.用struct定义位域的作用：在DSP2833x_Sci.h中有一段: 1234567891011121314struct SCICCR_BITS &#123; // bit description Uint16 SCICHAR:3; // 2:0 Character length control Uint16 ADDRIDLE_MODE:1; // 3 ADDR/IDLE Mode control Uint16 LOOPBKENA:1; // 4 Loop Back enable Uint16 PARITYENA:1; // 5 Parity enable Uint16 PARITY:1; // 6 Even or Odd Parity Uint16 STOPBITS:1; // 7 Number of Stop Bits Uint16 rsvd1:8; // 15:8 reserved 保留&#125;; union SCICCR_REG &#123; Uint16 all; struct SCICCR_BITS bit;&#125;; Uint16 SCICHAR:3 表示定义SCICHAR，它占一个字节中的3位；*注意：必须以4字节对齐！观察上面的SCICCR_BITS的定义也会发现前面定义了3+1+1+1+1+1=8位=1字节 B.再来看union的作用 1234union SCICCR_REG&#123; Uint16 all; struct SCICCR_BITS bit;&#125; 这样定义有什么效果？当我想操作SCICCR_BITS中的每一位时，只需定义union SCICCR_REG reg即可 我们可以整体操作，如：reg.all = 0x0011; 我们可以操作其中一位：reg.bit.PARITY = 0; 还记得c语言中union中的共享同一个内存空间地址么？ 2.使用cmd文件进行数据段与存储器空间映射既然官方已经帮我们做好了上面的一切，上面的东西肯定可以直接使用，那么为什么可以直接使用呢？ 定义一个上面的变量就可以访问到真正硬件上的寄存器了吗？肯定不行！ 我们需要将上面的变量和实际硬件的寄存器存储空间绑定，怎么绑定，通过cmd文件。 下面是官方DSP2833x_GlobalVariableDefs.c中的一段代码： 1234567//----------------------------------------#ifdef __cplusplus#pragma DATA_SECTION("ScicRegsFile")#else#pragma DATA_SECTION(ScicRegs,"ScicRegsFile");#endifvolatile struct SCI_REGS ScicRegs; 官方定义了ScicRegs来操作串口SCI-C的相关的寄存器，但是肯定没法直接使用，还没有做绑定； 使用#pragma DATA_SECTION可以将变量与数据段绑定，变量和数据段是自己定义的，只需要将他们绑定即可； 这样绑定显然还不行，还需要通过cmd文件数据段映射到硬件的寄存器地址空间中去！ 查看DSP2833x_Headers_nonBIOS.cmd文件我们发现其中有这样几行： 12345678910111213141516171819MEMORY&#123; PAGE 0: /* Program Memory */ PAGE 1: /* Data Memory */ ADC : origin = 0x007100, length = 0x000020 /* ADC registers */ SCIB : origin = 0x007750, length = 0x000010 /* SCI-B registers */ SCIC : origin = 0x007770, length = 0x000010 /* SCI-C registers */ I2CA : origin = 0x007900, length = 0x000040 /* I2C-A registers */ &#125; SECTIONS&#123; AdcRegsFile : &gt; ADC, PAGE = 1 ScibRegsFile : &gt; SCIB, PAGE = 1 ScicRegsFile : &gt; SCIC, PAGE = 1 I2caRegsFile : &gt; I2CA, PAGE = 1&#125; MEMORY代表内存空间，PAGE0是程序空间， PAGE1是数据空间； (还记得第一课的介绍么？28335采样的哈佛总线结构，程序与数据分开了~) SECTIONS代表需要映射的段； 通过上面的映射后，操作ScicRegs就可以实际操作串口了，目的也就达到了； 时钟TMS320F28335上有一个基于PLL电路的片上时钟模块，如图1所示，为CPU及外设提供时钟有两种方式： 一种是用外部的时钟源，将其连接到X1引脚上或者XCLKIN引脚上，X2接地；另一种是使用振荡器产生时钟，用30MHz的晶体和两个20PF的电容组成的电路分别连接到X1和X2引脚上，XCLKIN引脚接地。 我们常用第二种来产生时钟。此时钟将通过一个内部PLL锁相环电路，进行倍频。由于F28335的最大工作频率是150M，所以倍频值最大是5。其中倍频值由PLLCR的低四位和PLLSTS的第7、8位来决定。其详细的倍频值可以参照TMS320F28335的Datasheet。 三种时钟输入的接法: 如果我们希望DSP工作在某一个频率下，我们就可以对Uint16 val, Uint16 divsel两个参数进行设定。说白了就相当于乘10，除2 (30*10/2 = 150MHZ) GPIO引脚GPIO（General-Purpose Input/Output）——通用输入/输出口 DSP28335 GPIO模块分为三类IO口：PORTA(0-31),PORTB(32-63),PORTC(64-87) 对GPIO模块的设置主要通过三类寄存器来完成，分别是：控制寄存器、数据寄存器、中断寄存器。 1、控制寄存器 12345678910111213141516171819 GPxCTRL; // GPIO x Control Register (GPIO0 to 31) //设置采样窗周期T=2*GPXCTRL*Tsysclk； GPxQSEL1; // GPIO x Qualifier Select 1 Register (GPIO0 to 15)(32-47) GPxQSEL2; // GPIO x Qualifier Select 2 Register (GPIO16 to 31)(48-63) //每两位控制一个引脚，确定是3周期采样还是6周期采样或者不用采样 GPxMUX1; // GPIO x Mux 1 Register (GPIO0 to 15)(32-47)(64-79) GPxMUX2; // GPIO x Mux 2 Register (GPIO16 to 31)(48-63)(80-95) //配置各个引脚的功能，0：I/O功能，1：外设功能。 GPxDIR; // GPIO x Direction Register (GPIO0 to 31)(32-63)(64-95) //配置每个引脚是输入还是输出，0：数字量输入；1：数字量输出。 GPxPUD; // GPIO x Pull Up Disable Register (GPIO0 to 31)(32-63)(64-95) //使能或禁止内部上拉 0：开启上拉，1：禁止上拉 2、数据寄存器 123456 GPxDAT; // GPIO Data Register (GPIO0 to 31)(32-63)(64-95) GPxSET; // GPIO Data Set Register (GPIO0 to 31)(32-63)(64-95)——置位 GPxCLEAR; // GPIO Data Clear Register (GPIO0 to 31)(32-63)(64-95) GPxTOGGLE; // GPIO Data Toggle Register (GPIO0 to 31)(32-63)(64-95)—反转 3、中断寄存器 12345678910111213141516 GPIOXINT1SEL; // XINT1 GPIO Input Selection GPIOXINT2SEL; // XINT2 GPIO Input Selection GPIOXNMISEL; // XNMI_Xint13 GPIO Input Selection GPIOXINT3SEL; // XINT3 GPIO Input Selection GPIOXINT4SEL; // XINT4 GPIO Input Selection GPIOXINT5SEL; // XINT5 GPIO Input Selection GPIOXINT6SEL; // XINT6 GPIO Input Selection GPIOXINT7SEL; // XINT7 GPIO Input Selection GPIOLPMSEL; // Low power modes GP I/O input select 可以对GPIO0-63进行外部中断设置； 具体定义在DSP28335Gpio.h中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct GPIO_CTRL_REGS &#123; union GPACTRL_REG GPACTRL; // GPIO A Control Register (GPIO0 to 31) union GPA1_REG GPAQSEL1; // GPIO A Qualifier Select 1 Register (GPIO0 to 15) union GPA2_REG GPAQSEL2; // GPIO A Qualifier Select 2 Register (GPIO16 to 31) union GPA1_REG GPAMUX1; // GPIO A Mux 1 Register (GPIO0 to 15) union GPA2_REG GPAMUX2; // GPIO A Mux 2 Register (GPIO16 to 31) union GPADAT_REG GPADIR; // GPIO A Direction Register (GPIO0 to 31) union GPADAT_REG GPAPUD; // GPIO A Pull Up Disable Register (GPIO0 to 31) Uint32 rsvd1; union GPBCTRL_REG GPBCTRL; // GPIO B Control Register (GPIO32 to 63) union GPB1_REG GPBQSEL1; // GPIO B Qualifier Select 1 Register (GPIO32 to 47) union GPB2_REG GPBQSEL2; // GPIO B Qualifier Select 2 Register (GPIO48 to 63) union GPB1_REG GPBMUX1; // GPIO B Mux 1 Register (GPIO32 to 47) union GPB2_REG GPBMUX2; // GPIO B Mux 2 Register (GPIO48 to 63) union GPBDAT_REG GPBDIR; // GPIO B Direction Register (GPIO32 to 63) union GPBDAT_REG GPBPUD; // GPIO B Pull Up Disable Register (GPIO32 to 63) Uint16 rsvd2[8]; union GPC1_REG GPCMUX1; // GPIO C Mux 1 Register (GPIO64 to 79) union GPC2_REG GPCMUX2; // GPIO C Mux 2 Register (GPIO80 to 95) union GPCDAT_REG GPCDIR; // GPIO C Direction Register (GPIO64 to 95) union GPCDAT_REG GPCPUD; // GPIO C Pull Up Disable Register (GPIO64 to 95)&#125;; struct GPIO_DATA_REGS &#123; union GPADAT_REG GPADAT; // GPIO Data Register (GPIO0 to 31) union GPADAT_REG GPASET; // GPIO Data Set Register (GPIO0 to 31) union GPADAT_REG GPACLEAR; // GPIO Data Clear Register (GPIO0 to 31) union GPADAT_REG GPATOGGLE; // GPIO Data Toggle Register (GPIO0 to 31) union GPBDAT_REG GPBDAT; // GPIO Data Register (GPIO32 to 63) union GPBDAT_REG GPBSET; // GPIO Data Set Register (GPIO32 to 63) union GPBDAT_REG GPBCLEAR; // GPIO Data Clear Register (GPIO32 to 63) union GPBDAT_REG GPBTOGGLE; // GPIO Data Toggle Register (GPIO32 to 63) union GPCDAT_REG GPCDAT; // GPIO Data Register (GPIO64 to 95) union GPCDAT_REG GPCSET; // GPIO Data Set Register (GPIO64 to 95) union GPCDAT_REG GPCCLEAR; // GPIO Data Clear Register (GPIO64 to 95) union GPCDAT_REG GPCTOGGLE; // GPIO Data Toggle Register (GPIO64 to 95) Uint16 rsvd1[8];&#125;; struct GPIO_INT_REGS &#123; union GPIOXINT_REG GPIOXINT1SEL; // XINT1 GPIO Input Selection union GPIOXINT_REG GPIOXINT2SEL; // XINT2 GPIO Input Selection union GPIOXINT_REG GPIOXNMISEL; // XNMI_Xint13 GPIO Input Selection union GPIOXINT_REG GPIOXINT3SEL; // XINT3 GPIO Input Selection union GPIOXINT_REG GPIOXINT4SEL; // XINT4 GPIO Input Selection union GPIOXINT_REG GPIOXINT5SEL; // XINT5 GPIO Input Selection union GPIOXINT_REG GPIOXINT6SEL; // XINT6 GPIO Input Selection union GPIOXINT_REG GPIOXINT7SEL; // XINT7 GPIO Input Selection union GPADAT_REG GPIOLPMSEL; // Low power modes GP I/O input select&#125;; 注意：GPIO相关寄存器介绍 1、GPxMUX寄存器（功能选择寄存器） 每个I/O口都有一个功能选择寄存器，功能选择寄存器主要用于选择I/O工作在特殊功能还是通用数组I/O模式。在复位时，所有GPIO配置成通用数字模式。 1）如果GPxMUX.bit = 0，配置成通用数字I/O功能； 2）如果GPxMUX.bit = 1 2 3，配置成特殊外设功能口（如SCI、CAN）； I/O的输入功能和外设的输入通道总是被使能的，输出通道是通用数组I/O和特殊外设复用的。如果引脚配置成通用数组I/O功能，相应的外设功能将被禁止。 2、GPxDIR（方向控制寄存器） 每个I/O口都有数据方向控制寄存器，数据方向控制寄存器用于设置通用数字I/O为输入还是输出口，在复位时，引脚的默认状态为输入状态。 1）如果GPxDIR.bit = 0，引脚设置为通用数字量输入； 2）如果GPxDIR.bit = 1，引脚设置为通用数字量输出； 复位时，GPxMUX和GPxDIR默认值都为0，所以在复位时，引脚的默认状态为数字I/O输入。 3、GPxDAT寄存器（数据寄存器） 每个I/O口都有一个数据寄存器，数据寄存器是可读可写寄存器。 1）I/O设置为输出功能时，如果GPxDAT.bit = 0，那么操作将会使相应的引脚拉低； 2）I/O口设置为输入功能时，如果GPxDAT.bit = 0，反映相应的引脚状态为低电平； 3）I/O口设置为输出功能时，如果GPxDAT.bit = 1，那么操作将会使相应的引脚拉高； 4）I/O口设置为输入功能时，如果GPxDAT.bit = 1，反映相应的引脚状态为高电平。 需要说明的是，当用户试图改变一个数字I/O的状态时，不要改变另一个I/O的引脚状态。 4、GOxSET寄存器（置位寄存器） 每个I/O口都有一个置位寄存器，置位寄存器是只写寄存器，任何读操作都返回0，如果相应的引脚配置成数据量输出，写1后相应的引脚会置高，写0时没有反映。 1）如果GPxSET.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxSET.bit = 1，那么操作将会使引脚置高。 5、GPxCLEAR寄存器（清除寄存器） 每个I/O口都有一个清除寄存器，清除寄存器是只写寄存器，任何读操作都返回0。 1）如果GPxCLEAR.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxCLEAR.bit = 1，将相应的引脚置成低电平。 6、GPxTOGGLE寄存器（取反触发寄存器） 每个I/O口都有一个取反触发寄存器，该寄存器是只写寄存器，任何读操作都返回0。 1）如果GPxTOGGLE.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxTOGGLE.bit = 1，那么操作将使相应的引脚取反。 中断1.中断系统 在这里我们要十分清楚DSP的中断系统。C28XX一共有16个中断源，其中有2个不可屏蔽的中断RESET和NMI、定时器1和定时器2分别使用中断13和14。这样还有12个中断都直接连接到外设中断扩展模块PIE上。说的简单一点就是PIE通过12根线与28335核的12个中断线相连。而PIE的另外一侧有12*8根线分别连接到外设，如AD、SPI、EXINT等等。 PIE共管理12*8=96个外部中断。这12组大中断由28335核的中断寄存器IER来控制，即IER确定每个中断到底属于哪一组大中断（如IER |= M_INT12; 说明我们要用第12组的中断，但是第12组里面的什么中断CPU并不知道需要再由PIEIER确定）。 接下来再由PIE模块中的寄存器PIEIER中的低8确定该中断是这一组的第几个中断，这些配置都要告诉CPU（我们不难想象到PIEIER共有12总即从PIEIER1-PIEIER12）。另外，PIE模块还有中断标志寄存器PIEIFR，同样它的低8位是来自外部中断的8个标志位，同样CPU的IFR寄存器是中断组的标志寄存器。由此看来，CPU的所有中断寄存器控制12组的中断，PIE的所有中断寄存器控制每组内8个的中断。除此之外，我们用到哪一个外部中断，相应的还有外部中断的寄存器，需要注意的就是外部中断的标志要自己通过软件来清零。而PIE和CPU的中断标志寄存器由硬件来清零。 12345678EALLOW; // This is needed to write to EALLOW protected registers PieVectTable.XINT2 = &amp;ISRExint; //告诉中断入口地址EDIS; // This is needed to disable write to EALLOW protected registersPieCtrlRegs.PIECTRL.bit.ENPIE = 1; // Enable the PIE block使能PIEPieCtrlRegs.PIEIER1.bit.INTx5= 1; //使能第一组中的中断5IER |= M_INT1; // Enable CPU 第一组中断EINT; // Enable Global interrupt INTMERTM; // Enable Global realtime interrupt DBGM 也就是说，12组中的每个中断都要完成上面的相同配置，剩下的才是去配置自己的中断。如我们提到的EXINT，即外面来个低电平我们就进入中断，完成我们的程序。在这里要介绍一下，DSP的GPIO口都可以配置为外部中断口，其配置方法如下： 1234567891011121314151617181920212223242526272829GpioCtrlRegs.GPBMUX2.bit.GPIO54 = 0; //选择他们是GPIO口GpioCtrlRegs.GPBMUX2.bit.GPIO55 = 0;GpioCtrlRegs.GPBMUX2.bit.GPIO56 = 0;GpioCtrlRegs.GPBMUX2.bit.GPIO57 = 0; GpioCtrlRegs.GPBDIR.bit.GPIO54 = 0;//选择他们都是输入口GpioCtrlRegs.GPBDIR.bit.GPIO55 = 0;GpioCtrlRegs.GPBDIR.bit.GPIO56 = 0;GpioCtrlRegs.GPBDIR.bit.GPIO57 = 0; GpioCtrlRegs.GPBQSEL2.bit.GPIO54= 0;//使GPIO时钟和系统时钟一样 且支持GPIOGpioCtrlRegs.GPBQSEL2.bit.GPIO55= 0;GpioCtrlRegs.GPBQSEL2.bit.GPIO56= 0;//配置输入口权限，对于选择为输入口的需配置GPACTRL,GPBCTRL,GPAQSEL1GpioCtrlRegs.GPBQSEL2.bit.GPIO57= 0;//GPAQSEL2, GPBQSEL1, and GPBQSEL2寄存器所有输入信号与CPU输出系统时钟同步； GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = 54;//中断3选择GPIOGpioIntRegs.GPIOXINT4SEL.bit.GPIOSEL = 55;GpioIntRegs.GPIOXINT5SEL.bit.GPIOSEL = 56;GpioIntRegs.GPIOXINT6SEL.bit.GPIOSEL = 57; XIntruptRegs.XINT3CR.bit.POLARITY= 0;//触发模式为下降沿触发XIntruptRegs.XINT4CR.bit.POLARITY= 0;XIntruptRegs.XINT5CR.bit.POLARITY= 0;XIntruptRegs.XINT6CR.bit.POLARITY= 0; XIntruptRegs.XINT3CR.bit.ENABLE = 1;//使能中断XIntruptRegs.XINT4CR.bit.ENABLE = 1;XIntruptRegs.XINT5CR.bit.ENABLE = 1;XIntruptRegs.XINT6CR.bit.ENABLE = 1; 注意一点就是外部中断1和2只能对GPIO0—GPIO31配置；外部中断3和4、5、6、7只对GPIO32—GPIO63配置。 GPIO分为A(0-31)、B(32-63)、C(64-87);C组的不能配置为外部中断； 2.如何开启某个中断？ 设置中断向量。例如：PieVectTable.ADCINT = &amp;adc_isr;等打开PIE控制器。PieCtrlRegs.PIECTRL.bit.ENPIE = 1;使能PIE中对应外设的中断（相应group的相应pin）。例如：PieCtrlRegs.PIEIER1.bit.INTx8 = 1; PieCtrlRegs.PIEIER1.bit.INTx6 = 1;等使能CPU的相应中断（INT1~INT12）IER |= M_INT1;使能CPU响应中断EINT、ERTM;; 3.中断标志有几级？作用是什么？ 中断标志主要有三级CPU（有16个标志位）、PIE（有12组每组有12个标志位）和外设（有的外设没有）。 标志位在中断发生后锁存中断状态，即表示中断发生。在CPU响应中断后，会自动清除cpu级别的标志位IFR bit，同时将INTM bit 置位，以防止其它中断的发生； CPU在从PIE中取中断向量时PIE会自动清除PIE级别的标志位PIEIFRx.y。所以在进入中断处理程序后除了外设所有中断位都已经清除。 而中断处理程序中需要清除PIEACKx和外设的中断标志位（如果有的话）。 在CPU响应一个中断后，在进入ISR的时候，默认会关断全局中断，即在执行中断服务程序时，不会有其他中断来打断CPU，包括本次的中断事件。另外，如果外设的中断标志位不清除，不会循环进入这个中断服务函数，这个外设中断被阻断了。所以只有清除外设的中断服务程序，才能响应下一次的外设中断。PIEACK同理，如果没有PIEACK，这组所有中断都被阻断。 参考文献[1] TMS320F2833x Datasheet [2] 风雨也无晴 CSDN [3] GPIO blog]]></content>
      <tags>
        <tag>DSP28335</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP 串口接口及通信通信]]></title>
    <url>%2F2019%2F08%2F09%2F%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[对串口通信进行简单知识点梳理串行通信可以分为两大类： 同步通信：典型 I2C,SPI 异步通信：典型 SCI(serial communication interface,串行通信接口) 进行串口异步通信接口，一般可以看作UART口(Universal Asynchronous Receiver Transmitter：通用异步收发器/异步串行通信口) UART、COM指物理接口形式(硬件), TTL、RS232、RS485 指电平标准(电信号) SCI 串口先来补充一个概念:FIFO（First Input First Output），即先进先出队列。 SCI模块介绍TMS320F28335内部有三个SCI模块，SCIA、SCIB、SCIC。 每一个SCI模块都有一个接收器和发送器，SCI的接收器和发送器各有一个16级的FIFO(First In First Out先入先出)队列，它们都还有自己独立的使能位和中断位；可以工作在半双工或全双工模式。 1. SCI的CPU 接口SCI 模块具有两个引脚， SCITXDA 和 SCIRXDA，分别实现发送数据和接收数据的功能，这两个引脚对应于 GPIOF 模块的第4和第5位，在编程初始化的时候，需要将GPIOFMUX 寄存器的第4和第5位置为1，才能使得这两个引脚具有发送和接收的功能，否则就是普通的I/O引脚。外部晶振通 PLL 模块产生了CPU 的系统时钟SYSCLKOUT，然后SYSCLKOUT经过低速预定标器之后输出低速时钟LSPCLK 供给SCI。要保证SCI的正常运行，系统控制模块下必须使能SCI的时钟，也就是在系统初始化函数中需要将外设时钟控制寄存器PCLKCR的SCIAENCLK位置1。从下图，我们可以清楚的看到SCIA可以产生两个中断，SCIRXINTA 和SCITXINTA，即发送中断和接收中断。 2. SCI相关寄存器 SCICR：SCI通信参数设置寄存器，设置数据位，停止位，奇偶校验位。 SCICTL1：使能SCI的发送接收功能 注：SW RESET需置1 SCILBAUD、SCIHBAUD：通信速率（波特率）的设置。 SCICTL2：使能接收发送中断，以及发送中断标志位。 SCIRXST：接收相关标志位。 SCIRXBUF：8位发送缓存寄存器 SCITXBUF：8位接收缓存寄存器。 SCI中断配置： SCI的中断采用三级中断管理。分别是SCI外设中断，PIE中断，CPU中断。SCIA的PIE中断是第九组，分别是INT９.１和INT９.２.PIE中断的配置在前面已经说过了，此处不多说。注意：在中断不要忘记将PIEACK写１清除。 SCI的FIFO模式： FIFO：先入先出队列。SCI采用这种模式时，接收或者发送完指定字节数量的数据后，才进入中断处理。这样可以节省了CPU的使用效率，CPU不用每次接收完一个字节的数据后就进入中断处理。 相关寄存器： SCIFFTX：配置发送的数据量，使能SCI的FIFO模式，使能中断等 SCIFFRX：配置接收的数据量，使能接收中断等。 在学习FIFO模式时，遇到一个问题，就是接收完指定数量字节的数据后，总是重复进入两次发送中断，一次找不到原因。下面贴出代码，希望各位读者不吝赐教。 3. SCI 模块发送和接收数据的工作原理 SCI 模块的工作原理如下图所示，之所以SCI 能工作于全双工模式，是因为它有独立的数据发送器和数据接收器，这样能够保证SCI既能够同时进行，也能够独立进行发送和接收的操作。 SCI 发送数据的过程如下：如下图右半部分所示， 在FIFO功能使能的情况下， 首先，发送数据缓冲寄存器SCITXBUF从TX FIFO 中获取由 CPU 加载的需要发送的数据，然后 SCITXBUF将数据传输给发送移位寄存器TXSHF， 如果SCI的发送功能使能， TXSHF 则将接收到的数据逐位逐位的移到 SCITXD 引脚上。 SCI接收数据的过程如下：如X下图的左半部分所示，首先，接收移位寄存器 RXSHF 逐位逐位的接收来自于 SCIRXD 引脚的数据， 如果 SCI 的接收功能使能， RXSHF 将这些数据传输给接收缓冲寄存器 SCIRXBUF，CPU 就能从 SCIRXBUF 读取外部发送来的数据。当然，如果 FIFO 功能使能的话， SCIRXBUF 会将数据加载到RX FIFO 的队列中， CPU 再从FIFO 的队列读取数据。 4. SCI数据格式 在 SCI 中，通信协议体现在 SCI 的数据格式上。 通常将 SCI 的数据格式称之为可编程的数据格式，原因就是可以通过 SCI 的通信控制寄存器 SCICCR 来进行设置，规定通信过程中所使用的数据格式。 在空闲线模式下， SCI 发送或者接收一帧的数据格式如图 4 所示，其中 LSB 是数据的最低位， MSB 是数据的最高位。 使用 SCICCR 进行数据格式编程 12345678SciaRegs.SCICCR.bit.SCICHAR=8;//选择数据长度，为 8 个数据位SciaRegs.SCICCR.bit.PARITYENA=1;//开启极性功能，值为 0 的时候取消极性功能SciaRegs.SCICCR.bit.PARITY=0;//在开启极性功能的前提下，该位值为 0 时选择偶极性，值为 1 时选择奇极性SciaRegs.SCICCR.bit.STOPBITS=0;//选择停止位，该位为 0 时有 1 个停止位，该位为 1 时有 2 个停止位 当然，上述这几个语句，我们也可以合并成如下的语句： 1SciaRegs.SCICCR.all=0x13; 5. SCI通信波特率 所谓的波特率就是指每秒所能发送的位数。SCI波特率设置寄存器SCIHBAUD和SCILBAUD，0-15是高字节与低字节连在一起，构成16位波特率设置寄存器BRR。BRR = SCIHBAUD + SCILBAUD 如果1&lt;= BRR &lt;=65535，那么SCI波特率=LSPCLK / ( (BRR+1) * 8 )，由此，可以带入你需要的波特率，既可以得到BRR的值；如果BRR = 0，那么SCI波特率=LSPCLK/ 16 我们举例来进行说明。例如外部晶振位 30M，经过 PLL 之后 SYSCLKOUT 为 150MHz，然后，当低速预定标器 LOSPCP 的值为 2 的时候， SYSCLKOUT 经过低速预定标器之后产生&gt;低速外设时钟 LSPCLK 为 37.5MHz，也就是说 SCI 的时钟为 37.5MHz。如果我们需要 SCI 的波特率为 19200，则将 LSPCLK 和波特率的数值代入式 1，便可得到BRR=243.14，由于寄存器都是正整数，所以省略掉小数后可以得到 BRR=243。将 243 转换成 16 进制是 0xF3，因此 SCIHBAUD 的值为 0， SCIHBAUD 的值为 0XF3。由于省略了小数，将会产生 0.06%的误差。 当 LSPCLK 为 37.5M 时，对于 SCI 常见的波特率，其寄存器的值如下表所示： 6. 串口SCI编程 A. 先初始化IO管脚 (以SCI-A为例，SCI-B、SCI-C的初始化方法一样，就是照着改对应的管脚就行) 1234567891011121314void InitSciaGpio() //初始化SCIA的GPIO管脚为例子&#123;EALLOW;//根据硬件设计决定采用GPIO28/29和GPIO35/36中的哪一组。这里以35/36为例//定义管脚为上拉GpioCtrlRegs.GPBPUD.bit.GPIO36 = 0;GpioCtrlRegs.GPBPUD.bit.GPIO35 = 0;//定义管脚为异步输入GpioCtrlRegs.GPBQSEL1.bit.GPIO36 = 3;//配置管脚为SCI功能管脚GpioCtrlRegs.GPBMUX1.bit.GPIO36 = 1;GpioCtrlRegs.GPBMUX1.bit.GPIO35 = 1;EDIS;&#125; B. SCI初始化配置 12345678910111213void scia_init()&#123;SciaRegs.SCICCR.all =0x0007; // 1 stop bit, No loopback// No parity,8 char bits,// async mode, idle-line protocolSciaRegs.SCICTL1.all =0x0003; // enable TX, RX, internal SCICLK,// Disable RX ERR, SLEEP, TXWAKESciaRegs.SCICTL2.bit.TXINTENA =1; //发送中断使能SciaRegs.SCICTL2.bit.RXBKINTENA =1;//接收中断使能SciaRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 37.5MHz.SciaRegs.SCILBAUD =0x00E7;SciaRegs.SCICTL1.all =0x0023; // Relinquish SCI from Reset&#125; C. 接着进行中断的配置 123456EALLOW; // This is needed to write to EALLOW protected registersPieVectTable.SCIRXINTA = &amp;sciaRxIsr;PieVectTable.SCITXINTA = &amp;sciaTxIsr;PieVectTable.SCIRXINTB = &amp;scibRxIsr;PieVectTable.SCITXINTB = &amp;scibTxIsr;EDIS; // This is needed to disable write to EALLOW protected registers D. 上面是将SCIA和SCIB的中断服务程序连到PIE的中断表中，发生中断就会跑到你的ISR去了，下面是开中断： 1234567PieCtrlRegs.PIECTRL.bit.ENPIE = 1; // Enable the PIE blockPieCtrlRegs.PIEIER9.bit.INTx1=1; // PIE Group 9, int1PieCtrlRegs.PIEIER9.bit.INTx2=1; // PIE Group 9, INT2PieCtrlRegs.PIEIER9.bit.INTx3=1; // PIE Group 9, INT3PieCtrlRegs.PIEIER9.bit.INTx4=1; // PIE Group 9, INT4IER = 0x100; // Enable CPU INTEINT; 这样串口基本就OK了。 参考文献[1] 接口及协议总结[2] SCI通信]]></content>
      <tags>
        <tag>上位机</tag>
        <tag>串口通信</tag>
        <tag>DSP28335</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP电机平台上位机编写(Python+pyqt)]]></title>
    <url>%2F2019%2F08%2F06%2FDSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[准备给DSP电机平台增加一个电机转速调节的上位机。 目的： 1.学习python，并利用它做点东西 2.对串口通信有更加深刻的了解 计划步骤： 1.先把Python的基础知识有大体了解 2.学习pyqt并绘制上位机界面 3.做好串口通信的工作 环境的搭建环境搭建参考： 环境搭建 再由.ui转成.py时，再最后添加：参考 Ui_MainWindow 要和前面类名一致 1234567891011class MyWindow(QtWidgets.QMainWindow, Ui_MainWindow): def __init__(self): super(MyWindow, self).__init__() self.setupUi(self)if __name__ == '__main__': import sys app = QtWidgets.QApplication(sys.argv) mywindow = MyWindow() mywindow.show() sys.exit(app.exec_()) 槽函数 未完待续~~]]></content>
      <tags>
        <tag>pyqt</tag>
        <tag>DSP平台</tag>
        <tag>上位机</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业岗位要求]]></title>
    <url>%2F2019%2F08%2F06%2F%E4%BC%81%E4%B8%9A%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[几家企业的岗位要求，激励自己不断前进！]]></content>
      <tags>
        <tag>岗位要求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柔性负载-肖曦]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E8%82%96%E6%9B%A6%2F</url>
    <content type="text"><![CDATA[关于肖老师柔性负载的文献综述一、柔性负载建模–中心刚体-悬臂梁系统(欧拉-伯努利梁)[5]应用于 工业机器人中的柔性机械臂。单柔性连杆伺服驱动系统如下图所示。图中：u(x,t)为挠性负载在x处的挠度；θm(t)为伺服电机转轴的转角；Ta为伺服电机驱动转矩。 二、PMSM驱动柔性负载相关公式：[2]在对柔性负载建模后， 该系统的传递函数如下:(Ta表示电磁转矩，参数Ω 表示系统谐振频率， 而 Fa 则可以表示每一阶模态频率的谐振程度，通过系统模型和参数可以很容易地观察系统谐振状况。)(一般选取一阶模态，即Fa，Ω均为标量) 转速环和电流环传递函数 系统控制框图 (1)电流环特征–柔性负载影响小 刚性电流环开环传递函数 与上面的 柔性负载 电流环传递函数相比，其差别主要在分母的第三项。故可以对其分母第三项单独分析。 但是，由于柔性负载的振动频率与电流环带宽差别较大，因而，柔性对 PMSM 电流环的影响较小. (2)转速环环特征–柔性负载影响大 刚性负载 转速外环控制框图 柔性负载 转速外环控制框图（在不考虑电流环影响下，由系统框体可得） 转速环开环伯德图 结论： 在 PMSM 直接驱动柔性负载系统中，负载柔性对系统电流环影响较小，对转速环影响较大。 需要在 柔性负载振荡频率处 进行谐振补偿 三、柔性负载常用控制方法 转速环设计(1)PI设计[3] 转速环的开环传递函数(II型系统) （系统谐振模态幅值 η ） 在不考虑电流内环的影响，采用PI调节器 。转速外环的控制框图如下 (2)状态反馈 + PI 调节器控制[4] 在PI调节器的基础上，估计系统谐振模态幅值 η 和 负载转矩 TL 其中 GFF(s)是Wm与 TL 解耦得到 并存在 k1、k2、kP、kI 四个可调参数，因而四个极点能够任意配置. 参考文献[1]丁有爽,肖曦.基于负载位置反馈的永磁同步电机驱动柔性负载谐振抑制方法[J].电工技术学报,2017,32(11):96-110. [2]丁有爽,肖曦.永磁同步电机直接驱动柔性负载控制方法[J].电工技术学报,2017,32(04):123-132. [3]丁有爽,肖曦.基于极点配置的永磁同步电机驱动柔性负载PI调节器参数确定方法[J].中国电机工程学报,2017,37(04):1225-1239. [4]丁有爽,肖曦.基于状态反馈和转矩补偿的永磁同步电机驱动柔性负载控制方法[J].中国电机工程学报,2017,37(13):3892-3900. [5]丁有爽,肖曦.伺服系统柔性负载建模方法研究[J].中国电机工程学报,2016,36(03):818-827. [6] Hori Y，Sawada H，Chun Y．Slow resonance ratio control for vibration suppression and disturbance rejection in torsional system[J]．IEEE Transactions on Industrial Electronics，1999，46(1)：162-168]]></content>
      <tags>
        <tag>PMSM</tag>
        <tag>柔性负载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于加入站内搜索]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[今天按照网上的加入本站搜索功能 无论如何都加不进去，后来在查看 NEXT给的官方解读中看到解决方法网址如下，查看Local Search方法 https://theme-next.org/docs/third-party-services/search-services]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于DSP平台双UDE 参数调试]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.挑选了几组典型数据画图，这里面的滤波器参数都是随意设置的（因为现在还无法确定kp和alpha之间的关系） 2.xx_xxx3.fig 中红色为实际数值 蓝色为指令，绿色为经过滤波器的输出结果(画图程序在最后)。 3.图中的时间 10000点 = 5s 4.Main_twoloop190801.c为源程序。 5.文件夹中 01-07为电流环调试过程, 08-11为速度环调试过程, 12 给了一个比较极端的速度环滤波器参数。 数据对应参数： spd_Factor spd_kp spd_ki iq_Factor iq_kp iq_ki 01参数 0.1667 0.8 0.0015 0.007 1.0 0.0025 05参数 0.1667 0.8 0.0015 0.007 2.1 0.0025 06参数 0.1667 0.8 0.0015 0.007 2.5 0.0025 10参数 0.1667 3.0 0.0015 0.007 2.5 0.0025 12参数 0.0007 0.8 0.0015 0.007 2.5 0.0025 6.画图函数 1234567891011121314figure(1)plot(t,spd,'r','LineWidth',1)hold onplot(t,spdr-5,'g','LineWidth',1)hold onplot(t,spdc-5,'b','LineWidth',1)grid onfigure(2)plot(t,iq,'r','LineWidth',1)hold onplot(t,iqr,'g','LineWidth',1)hold onplot(t,iqc,'b','LineWidth',1)grid on]]></content>
      <tags>
        <tag>DSP平台</tag>
        <tag>PMSM</tag>
        <tag>UDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不懂的知识点 查阅 汇总]]></title>
    <url>%2F2019%2F08%2F01%2F%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[单工、半双工和全双工的区别 一、单工1、数据只在一个方向上传输，不能实现双方通信。 2、栗子：电视、广播。 二、半双工1、允许数据在两个方向上传输，但是同一时间数据只能在一个方向上传输，其实际上是切换的单工。 2、栗子：对讲机。 三、全双工1、允许数据在两个方向上同时传输。 2、栗子：手机通话。 TCP/IP （传输控制协议）Transmission Control Protocol TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。 TCP/IP 意味着 TCP 和 IP 在一起协同工作。TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。IP 负责将包发送至接受者。 api （应用程序编程接口）API 是一套明确定义的各种软件组件之间的通信方法。 http、MQTT、CoAPHTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。支持长连接！适用于抄表 CoAP 由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。 IETF的CoRE工作组提出了一种基于REST架构的CoAP协议;是一种在物联网世界的类web协议。不支持长连接 基于UDO 可靠性不高 适用于智能家居 OSI七层模型/TCP/IP五层模型：OSI七层模型(整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。) &lt;1&gt; 应用层 OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。 实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询&gt; 价单，等等。 &lt;2&gt;表示层 表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。 &lt;3&gt;会话 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。 &lt;4&gt;传输层 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的， TCP UDP 就是在这一层。端口号既是这里的“端”。 传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。 &lt;5&gt;网络层 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。 网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。 &lt;6&gt;数据链路层 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。 这个没找到合适的例子 &lt;7&gt; 物理层 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。 快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。 [ TCP/IP五层模型 TCP/IP五层协议和OSI的七层协议对应关系如下。 在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 在每一层实现的协议也各不同，即每一层的服务也不同。下图列出了每层主要的协议。 鉴权 鉴权（authentication）是指验证用户是否拥有访问系统的权利。 CIG、IOCM、DM Server、Mongo DBCIG (Cell Interconnection Gateway) 信元互连网关 $\color{red}{未完待续~~}$]]></content>
      <tags>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交流电机前言讲座考试总结]]></title>
    <url>%2F2019%2F07%2F29%2F%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简单的做一下知识点梳理。 电机的控制问题 交流电机 同步电机 附赠：电机的应用]]></content>
      <tags>
        <tag>PMSM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于404问题及感谢]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2%2F</url>
    <content type="text"><![CDATA[CNAME里面是写xxx.github.io 解析域名的时候最好用CNAME并 解析到 xxx.github.io GitHub 仓库里的Setting 最好也改成www.xxx.xxx 顺便感谢一下搭建博客参考网站 UP：CodeSheep UP：吃饱睡觉的猫 遇见西门]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于dsp平台电流环解耦]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6%2F</url>
    <content type="text"><![CDATA[120V电压 400rpm的给定电流 应该加的补偿值 ​ttt = 0.00105 \* \_IQmpy(pi_id.Fbk,pi_spd.Fbk) \* 4500 \* 9 /(volt1.DcBusVolt\*409.9) + 0.065 \* pi_spd.Fbk \* 4500 /(volt1.DcBusVolt\*409.9); 下面是解耦后应该的公式. ​ipark1.Qs = pi_iq.Out + ttt;​ 在未解耦的时候，测得ipark1.Qs = 0.515 . 换算成真实的电压值为(乘当前的电流值) 0.515 * 120 V=61.8V 测得ttt = 0.22 . 换算成真实的电压值为26.4V. ttt的主要成份是反电势 ​flux\*we=0.1552\*400\*4\*3.14/30=26.0V​ 所以证明电流环解耦 程序是正确的. 实验结果 （右为解耦）]]></content>
      <tags>
        <tag>DSP平台</tag>
        <tag>PMSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first generage blog]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一个博客 杠杠滴]]></content>
  </entry>
</search>
