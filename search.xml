<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DSP开发板灯光控制上位机]]></title>
    <url>%2F2019%2F08%2F12%2FDSP%E5%BC%80%E5%8F%91%E6%9D%BF%E7%81%AF%E5%85%89%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BD%8D%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[想法在前几天对PYQT5的学习以后，自己试着做了一个上位机 来对DSP开发板实现LED亮灭操作。 软硬件:pycharm + PYQT5 + CCS6.0 + DSP开发板 成果上位机界面 LED控制 描述：当按下 &lt;打开1灯&gt;时 1亮、2灭。当按下 &lt;打开2灯&gt;时 2亮、1灭。 遇到的问题 在CCS对GPIO进行写操作时(GPXDTA.bit = ) 无法成功写入，在顺华师兄建议下 改用SET CLEAR操作解决. 至于为何DAT不好用还未知？ 关于串口发送 16进制问题 代码 ui_demo.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'ui_demo_1.ui'## Created by: PyQt5 UI code generator 5.11.3## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_Form(object): def setupUi(self, Form): Form.setObjectName("Form") Form.resize(868, 452) self.formGroupBox = QtWidgets.QGroupBox(Form) self.formGroupBox.setGeometry(QtCore.QRect(20, 20, 167, 301)) self.formGroupBox.setObjectName("formGroupBox") self.formLayout = QtWidgets.QFormLayout(self.formGroupBox) self.formLayout.setContentsMargins(10, 10, 10, 10) self.formLayout.setSpacing(10) self.formLayout.setObjectName("formLayout") self.s1__lb_1 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_1.setObjectName("s1__lb_1") self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.s1__lb_1) self.s1__box_1 = QtWidgets.QPushButton(self.formGroupBox) self.s1__box_1.setAutoRepeatInterval(100) self.s1__box_1.setDefault(True) self.s1__box_1.setObjectName("s1__box_1") self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.s1__box_1) self.s1__lb_2 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_2.setObjectName("s1__lb_2") self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.s1__lb_2) self.s1__box_2 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_2.setObjectName("s1__box_2") self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.s1__box_2) self.s1__lb_3 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_3.setObjectName("s1__lb_3") self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.s1__lb_3) self.s1__box_3 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_3.setObjectName("s1__box_3") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.s1__box_3.addItem("") self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.s1__box_3) self.s1__lb_4 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_4.setObjectName("s1__lb_4") self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.s1__lb_4) self.s1__box_4 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_4.setObjectName("s1__box_4") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.s1__box_4.addItem("") self.formLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.s1__box_4) self.s1__lb_5 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_5.setObjectName("s1__lb_5") self.formLayout.setWidget(5, QtWidgets.QFormLayout.LabelRole, self.s1__lb_5) self.s1__box_5 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_5.setObjectName("s1__box_5") self.s1__box_5.addItem("") self.formLayout.setWidget(5, QtWidgets.QFormLayout.FieldRole, self.s1__box_5) self.open_button = QtWidgets.QPushButton(self.formGroupBox) self.open_button.setObjectName("open_button") self.formLayout.setWidget(7, QtWidgets.QFormLayout.SpanningRole, self.open_button) self.close_button = QtWidgets.QPushButton(self.formGroupBox) self.close_button.setObjectName("close_button") self.formLayout.setWidget(8, QtWidgets.QFormLayout.SpanningRole, self.close_button) self.s1__lb_6 = QtWidgets.QLabel(self.formGroupBox) self.s1__lb_6.setObjectName("s1__lb_6") self.formLayout.setWidget(6, QtWidgets.QFormLayout.LabelRole, self.s1__lb_6) self.s1__box_6 = QtWidgets.QComboBox(self.formGroupBox) self.s1__box_6.setObjectName("s1__box_6") self.s1__box_6.addItem("") self.formLayout.setWidget(6, QtWidgets.QFormLayout.FieldRole, self.s1__box_6) self.state_label = QtWidgets.QLabel(self.formGroupBox) self.state_label.setText("") self.state_label.setTextFormat(QtCore.Qt.AutoText) self.state_label.setScaledContents(True) self.state_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter) self.state_label.setObjectName("state_label") self.formLayout.setWidget(2, QtWidgets.QFormLayout.SpanningRole, self.state_label) self.verticalGroupBox = QtWidgets.QGroupBox(Form) self.verticalGroupBox.setGeometry(QtCore.QRect(210, 20, 401, 241)) self.verticalGroupBox.setObjectName("verticalGroupBox") self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalGroupBox) self.verticalLayout.setContentsMargins(10, 10, 10, 10) self.verticalLayout.setObjectName("verticalLayout") self.s2__receive_text = QtWidgets.QTextBrowser(self.verticalGroupBox) self.s2__receive_text.setObjectName("s2__receive_text") self.verticalLayout.addWidget(self.s2__receive_text) self.verticalGroupBox_2 = QtWidgets.QGroupBox(Form) self.verticalGroupBox_2.setGeometry(QtCore.QRect(210, 280, 401, 101)) self.verticalGroupBox_2.setObjectName("verticalGroupBox_2") self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalGroupBox_2) self.verticalLayout_2.setContentsMargins(10, 10, 10, 10) self.verticalLayout_2.setObjectName("verticalLayout_2") self.s3__send_text = QtWidgets.QTextEdit(self.verticalGroupBox_2) self.s3__send_text.setObjectName("s3__send_text") self.verticalLayout_2.addWidget(self.s3__send_text) self.s3__send_button = QtWidgets.QPushButton(Form) self.s3__send_button.setGeometry(QtCore.QRect(620, 310, 61, 31)) self.s3__send_button.setObjectName("s3__send_button") self.s3__clear_button = QtWidgets.QPushButton(Form) self.s3__clear_button.setGeometry(QtCore.QRect(620, 350, 61, 31)) self.s3__clear_button.setObjectName("s3__clear_button") self.formGroupBox1 = QtWidgets.QGroupBox(Form) self.formGroupBox1.setGeometry(QtCore.QRect(20, 340, 171, 101)) self.formGroupBox1.setObjectName("formGroupBox1") self.formLayout_2 = QtWidgets.QFormLayout(self.formGroupBox1) self.formLayout_2.setContentsMargins(10, 10, 10, 10) self.formLayout_2.setSpacing(10) self.formLayout_2.setObjectName("formLayout_2") self.label = QtWidgets.QLabel(self.formGroupBox1) self.label.setObjectName("label") self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.label) self.label_2 = QtWidgets.QLabel(self.formGroupBox1) self.label_2.setObjectName("label_2") self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.label_2) self.lineEdit = QtWidgets.QLineEdit(self.formGroupBox1) self.lineEdit.setObjectName("lineEdit") self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.lineEdit) self.lineEdit_2 = QtWidgets.QLineEdit(self.formGroupBox1) self.lineEdit_2.setObjectName("lineEdit_2") self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.lineEdit_2) self.hex_send = QtWidgets.QCheckBox(Form) self.hex_send.setGeometry(QtCore.QRect(620, 280, 71, 16)) self.hex_send.setObjectName("hex_send") self.hex_receive = QtWidgets.QCheckBox(Form) self.hex_receive.setGeometry(QtCore.QRect(620, 40, 71, 16)) self.hex_receive.setObjectName("hex_receive") self.s2__clear_button = QtWidgets.QPushButton(Form) self.s2__clear_button.setGeometry(QtCore.QRect(620, 80, 61, 31)) self.s2__clear_button.setObjectName("s2__clear_button") self.timer_send_cb = QtWidgets.QCheckBox(Form) self.timer_send_cb.setGeometry(QtCore.QRect(260, 390, 71, 16)) self.timer_send_cb.setObjectName("timer_send_cb") self.lineEdit_3 = QtWidgets.QLineEdit(Form) self.lineEdit_3.setGeometry(QtCore.QRect(350, 390, 61, 20)) self.lineEdit_3.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter) self.lineEdit_3.setObjectName("lineEdit_3") self.dw = QtWidgets.QLabel(Form) self.dw.setGeometry(QtCore.QRect(420, 390, 54, 20)) self.dw.setObjectName("dw") self.line = QtWidgets.QFrame(Form) self.line.setGeometry(QtCore.QRect(700, 30, 20, 351)) self.line.setFrameShape(QtWidgets.QFrame.VLine) self.line.setFrameShadow(QtWidgets.QFrame.Sunken) self.line.setObjectName("line") self.s4__open1_button = QtWidgets.QPushButton(Form) self.s4__open1_button.setGeometry(QtCore.QRect(740, 160, 61, 31)) self.s4__open1_button.setObjectName("s4__open1_button") self.s4__open2_button = QtWidgets.QPushButton(Form) self.s4__open2_button.setGeometry(QtCore.QRect(740, 210, 61, 31)) self.s4__open2_button.setObjectName("s4__open2_button") self.verticalGroupBox.raise_() self.verticalGroupBox_2.raise_() self.formGroupBox.raise_() self.s3__send_button.raise_() self.s3__clear_button.raise_() self.formGroupBox.raise_() self.hex_send.raise_() self.hex_receive.raise_() self.s2__clear_button.raise_() self.timer_send_cb.raise_() self.lineEdit_3.raise_() self.dw.raise_() self.line.raise_() self.s4__open1_button.raise_() self.s4__open2_button.raise_() self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate = QtCore.QCoreApplication.translate Form.setWindowTitle(_translate("Form", "Form")) self.formGroupBox.setTitle(_translate("Form", "串口设置")) self.s1__lb_1.setText(_translate("Form", "串口检测：")) self.s1__box_1.setText(_translate("Form", "检测串口")) self.s1__lb_2.setText(_translate("Form", "串口选择：")) self.s1__lb_3.setText(_translate("Form", "波特率：")) self.s1__box_3.setItemText(0, _translate("Form", "115200")) self.s1__box_3.setItemText(1, _translate("Form", "2400")) self.s1__box_3.setItemText(2, _translate("Form", "4800")) self.s1__box_3.setItemText(3, _translate("Form", "9600")) self.s1__box_3.setItemText(4, _translate("Form", "14400")) self.s1__box_3.setItemText(5, _translate("Form", "19200")) self.s1__box_3.setItemText(6, _translate("Form", "38400")) self.s1__box_3.setItemText(7, _translate("Form", "57600")) self.s1__box_3.setItemText(8, _translate("Form", "76800")) self.s1__box_3.setItemText(9, _translate("Form", "12800")) self.s1__box_3.setItemText(10, _translate("Form", "230400")) self.s1__box_3.setItemText(11, _translate("Form", "460800")) self.s1__lb_4.setText(_translate("Form", "数据位：")) self.s1__box_4.setItemText(0, _translate("Form", "8")) self.s1__box_4.setItemText(1, _translate("Form", "7")) self.s1__box_4.setItemText(2, _translate("Form", "6")) self.s1__box_4.setItemText(3, _translate("Form", "5")) self.s1__lb_5.setText(_translate("Form", "校验位：")) self.s1__box_5.setItemText(0, _translate("Form", "N")) self.open_button.setText(_translate("Form", "打开串口")) self.close_button.setText(_translate("Form", "关闭串口")) self.s1__lb_6.setText(_translate("Form", "停止位：")) self.s1__box_6.setItemText(0, _translate("Form", "1")) self.verticalGroupBox.setTitle(_translate("Form", "接受区")) self.verticalGroupBox_2.setTitle(_translate("Form", "发送区")) self.s3__send_text.setHtml(_translate("Form", "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\n""&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\n""p, li &#123; white-space: pre-wrap; &#125;\n""&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\"&gt;\n""&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;123456&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;")) self.s3__send_button.setText(_translate("Form", "发送")) self.s3__clear_button.setText(_translate("Form", "清除")) self.formGroupBox1.setTitle(_translate("Form", "串口状态")) self.label.setText(_translate("Form", "已接收：")) self.label_2.setText(_translate("Form", "已发送：")) self.hex_send.setText(_translate("Form", "Hex发送")) self.hex_receive.setText(_translate("Form", "Hex接收")) self.s2__clear_button.setText(_translate("Form", "清除")) self.timer_send_cb.setText(_translate("Form", "定时发送")) self.lineEdit_3.setText(_translate("Form", "1000")) self.dw.setText(_translate("Form", "ms/次")) self.s4__open1_button.setText(_translate("Form", "打开1灯")) self.s4__open2_button.setText(_translate("Form", "打开2灯")) ui_demo.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import sysimport serialimport serial.tools.list_portsfrom PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QMessageBoxfrom PyQt5.QtCore import QTimerfrom ui_demo_1 import Ui_Formclass Pyqt5_Serial(QtWidgets.QWidget, Ui_Form): def __init__(self): super(Pyqt5_Serial, self).__init__() self.setupUi(self) self.init() self.setWindowTitle("串口小助手") self.ser = serial.Serial() self.port_check() # 接收数据和发送数据数目置零 self.data_num_received = 0 self.lineEdit.setText(str(self.data_num_received)) self.data_num_sended = 0 self.lineEdit_2.setText(str(self.data_num_sended)) def init(self): # 串口检测按钮 self.s1__box_1.clicked.connect(self.port_check) # 串口信息显示 self.s1__box_2.currentTextChanged.connect(self.port_imf) # 打开串口按钮 self.open_button.clicked.connect(self.port_open) # 关闭串口按钮 self.close_button.clicked.connect(self.port_close) # 发送数据按钮 self.s3__send_button.clicked.connect(self.data_send) # 定时发送数据 self.timer_send = QTimer() self.timer_send.timeout.connect(self.data_send) self.timer_send_cb.stateChanged.connect(self.data_send_timer) # 定时器接收数据 self.timer = QTimer(self) self.timer.timeout.connect(self.data_receive) # 清除发送窗口 self.s3__clear_button.clicked.connect(self.send_data_clear) # 清除接收窗口 self.s2__clear_button.clicked.connect(self.receive_data_clear) # 打开1灯 self.s4__open1_button.clicked.connect(self.open_led1) # 打开2灯 self.s4__open2_button.clicked.connect(self.open_led2) # 串口检测 def port_check(self): # 检测所有存在的串口，将信息存储在字典中 self.Com_Dict = &#123;&#125; port_list = list(serial.tools.list_ports.comports()) self.s1__box_2.clear() for port in port_list: self.Com_Dict["%s" % port[0]] = "%s" % port[1] self.s1__box_2.addItem(port[0]) if len(self.Com_Dict) == 0: self.state_label.setText(" 无串口") # 串口信息 def port_imf(self): # 显示选定的串口的详细信息 imf_s = self.s1__box_2.currentText() if imf_s != "": self.state_label.setText(self.Com_Dict[self.s1__box_2.currentText()]) # 打开串口 def port_open(self): self.ser.port = self.s1__box_2.currentText() self.ser.baudrate = int(self.s1__box_3.currentText()) self.ser.bytesize = int(self.s1__box_4.currentText()) self.ser.stopbits = int(self.s1__box_6.currentText()) self.ser.parity = self.s1__box_5.currentText() try: self.ser.open() except: QMessageBox.critical(self, "Port Error", "此串口不能被打开！") return None # 打开串口接收定时器，周期为2ms self.timer.start(2) if self.ser.isOpen(): self.open_button.setEnabled(False) self.close_button.setEnabled(True) self.formGroupBox1.setTitle("串口状态（已开启）") # 关闭串口 def port_close(self): self.timer.stop() self.timer_send.stop() try: self.ser.close() except: pass self.open_button.setEnabled(True) self.close_button.setEnabled(False) self.lineEdit_3.setEnabled(True) # 接收数据和发送数据数目置零 self.data_num_received = 0 self.lineEdit.setText(str(self.data_num_received)) self.data_num_sended = 0 self.lineEdit_2.setText(str(self.data_num_sended)) self.formGroupBox1.setTitle("串口状态（已关闭）") # 发送数据 def data_send(self): if self.ser.isOpen(): input_s = self.s3__send_text.toPlainText() if input_s != "": # 非空字符串 if self.hex_send.isChecked(): # hex发送 input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) else: # ascii发送 input_s = (input_s + '\r\n').encode('utf-8') num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended)) else: pass # 接收数据 def data_receive(self): try: num = self.ser.inWaiting() except: self.port_close() return None if num &gt; 0: data = self.ser.read(num) num = len(data) # hex显示 if self.hex_receive.checkState(): out_s = '' for i in range(0, len(data)): out_s = out_s + '&#123;:02X&#125;'.format(data[i]) + ' ' self.s2__receive_text.insertPlainText(out_s) else: # 串口接收到的字符串为b'123',要转化成unicode字符串才能输出到窗口中去 self.s2__receive_text.insertPlainText(data.decode('iso-8859-1')) # 统计接收字符的数量 self.data_num_received += num self.lineEdit.setText(str(self.data_num_received)) # 获取到text光标 textCursor = self.s2__receive_text.textCursor() # 滚动到底部 textCursor.movePosition(textCursor.End) # 设置光标到text中去 self.s2__receive_text.setTextCursor(textCursor) else: pass # 定时发送数据 def data_send_timer(self): if self.timer_send_cb.isChecked(): self.timer_send.start(int(self.lineEdit_3.text())) self.lineEdit_3.setEnabled(False) else: self.timer_send.stop() self.lineEdit_3.setEnabled(True) # 清除显示 def send_data_clear(self): self.s3__send_text.setText("") def receive_data_clear(self): self.s2__receive_text.setText("") def open_led1(self): input_s = '1' input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended)) def open_led2(self): input_s = '2' input_s = input_s.strip() send_list = [] while input_s != '': try: num = int(input_s[0:2], 16) except ValueError: QMessageBox.critical(self, 'wrong data', '请输入十六进制数据，以空格分开!') return None input_s = input_s[2:].strip() send_list.append(num) input_s = bytes(send_list) num = self.ser.write(input_s) self.data_num_sended += num self.lineEdit_2.setText(str(self.data_num_sended))if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) myshow = Pyqt5_Serial() myshow.show() sys.exit(app.exec_()) CCS源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include "DSP2833x_Device.h" // DSP2833x 头文件#include "DSP2833x_Examples.h" // DSP2833x 例子相关头文件/**************************************函数声明************************************************/void scib_echoback_init(void);void scib_xmit(int a);void scib_msg(char *msg);/**********************************************************************************************/// 使用前，声明本文件中的相关函数；void configtestled(void);/**************************************宏定义************************************************/#define InitDIR() \ EALLOW; \ GpioCtrlRegs.GPBPUD.bit.GPIO49 = 0; \ GpioCtrlRegs.GPBDIR.bit.GPIO49 = 1; \ GpioDataRegs.GPBCLEAR.bit.GPIO49 = 1; \ EDIS;#define RX_EN GpioDataRegs.GPBCLEAR.bit.GPIO49 = 1;#define TX_EN GpioDataRegs.GPBSET.bit.GPIO49 = 1;/**********************************************************************************************/void main(void)&#123; Uint16 ReceivedChar; //变量定义 char *msg; //指针// 步骤 1. 初始化系统控制:// 设置PLL, WatchDog, 使能外设时钟// 下面这个函数可以从DSP2833x_SysCtrl.c文件中找到.. InitSysCtrl(); InitScibGpio();// 步骤 2. 初始化通用输入输出多路复用器GPIO:// 这个函数在DSP2833x_Gpio.c源文件中被定义了// 这个函数使GPIO控制类寄存器初始化到默认状态// InitGpio(); // 本例不用此子函数 InitDIR();// 本例使用下面的GPIO配置 configtestled();// 总线初始化函数 InitXintf16Gpio(); //zq// 步骤 3. 清除所有中断初始化中断向量表:// 禁止CPU全局中断 DINT;// 初始化PIE控制寄存器到他们的默认状态.// 这个默认状态就是禁止PIE中断及清除所有PIE中断标志// 这个函数放在DSP2833x_PieCtrl.c源文件里 InitPieCtrl();// 禁止CPU中断和清除所有CPU中断标志 IER = 0x0000; IFR = 0x0000;//初始化PIE中断向量表，并使其指向中断服务子程序（ISR）// 这些中断服务子程序被放在了DSP280x_DefaultIsr.c源文件中// 这个函数放在了DSP2833x_PieVect.c源文件里面. InitPieVectTable(); // 步骤 4. 初始化片内外设:// 这个函数可以在DSP280x_CpuTimers.c源文件中找到// InitCpuTimers(); // 这个例子仅初始化了Cpu定时器// 步骤 5. 用户特定的代码 scib_echoback_init(); msg = "\r\n\nled control\0"; //发送语句 scib_msg(msg); //发送函数 msg = "\r\n \n\0"; //发送语句 scib_msg(msg); //发送函数 GpioDataRegs.GPASET.bit.GPIO1 = 1; GpioDataRegs.GPASET.bit.GPIO2 = 1; for(;;) &#123; msg = "\r\n \0"; //发送语句 scib_msg(msg); //发送函数 //等待接收到数据，否则在此循环 while(ScibRegs.SCIRXST.bit.RXRDY !=1) &#123; &#125; // wait for XRDY =1 for empty state //把接收BUF里的数据赋值给ReceivedChar ReceivedChar = ScibRegs.SCIRXBUF.all; msg = " led open \0"; //发送语句 scib_msg(msg); //发送函数 scib_xmit(ReceivedChar); //发送ReceivedChar if(ScibRegs.SCIRXBUF.all == 1) &#123; GpioDataRegs.GPACLEAR.bit.GPIO1 = 1; GpioDataRegs.GPASET.bit.GPIO2 = 1; msg = "1"; scib_msg(msg); &#125; else if (ScibRegs.SCIRXBUF.all == 2) &#123; GpioDataRegs.GPACLEAR.bit.GPIO2 = 1; GpioDataRegs.GPASET.bit.GPIO1 = 1; msg = "2"; scib_msg(msg); &#125;&#125;void configtestled(void) //GPIO初始化函数&#123; EALLOW; GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 0; // GPIO0复用为GPIO功能 GpioCtrlRegs.GPADIR.bit.GPIO1 = 1; // GPIO0设置为输出 GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 0; // GPIO1复用为GPIO功能 GpioCtrlRegs.GPADIR.bit.GPIO2 = 1; // GPIO1设置为输出 EDIS;&#125;void scib_echoback_init()&#123; // Note: Clocks were turned on to the SCIA peripheral // in the InitSysCtrl() function //SCI的工作模式和参数需要用户在后面的学习中，深入的了解一个寄存器底层相关的资料了，多看看芯片手册和寄存器的意思。 //因为28335的寄存器太多了，所以在以后的学习过程中，就不会对寄存器进行详细的注释了。 ScibRegs.SCICTL1.bit.SWRESET =0; ScibRegs.SCICCR.all =0x0007; // 1 stop bit, No loopback // No parity,8 char bits, // async mode, idle-line protocol ScibRegs.SCICTL1.all =0x0003; // enable TX, RX, internal SCICLK, // Disable RX ERR, SLEEP, TXWAKE #if (CPU_FRQ_150MHZ) ScibRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 37.5MHz. ScibRegs.SCILBAUD =0x00E7; #endif #if (CPU_FRQ_100MHZ) ScibRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 20MHz. ScibRegs.SCILBAUD =0x0044; #endif ScibRegs.SCICTL1.all =0x0023; // Relinquish SCI from Reset&#125;// Transmit a character from the SCIvoid scib_xmit(int a) //发送字节的函数&#123; while (ScibRegs.SCICTL2.bit.TXRDY == 0) &#123;&#125; ScibRegs.SCITXBUF=a;&#125;void scib_msg(char * msg) //发送数组的函数&#123; int i; i = 0; TX_EN; while(msg[i] != '\0') &#123; scib_xmit(msg[i]); i++; &#125; RX_EN;&#125;//===========================================================================// No more.//=========================================================================== 参考[1] 参考的串口程序 [2] 王硕,孙洋洋.PyQt5快速开发与实战[M].电子工业出版社:北京,2017]]></content>
      <tags>
        <tag>上位机</tag>
        <tag>DSP开发板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP基础知识一览]]></title>
    <url>%2F2019%2F08%2F10%2FDSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[CCS编程基础CCS开发环境已经为我们封装好了许多片内外设寄存器的结构体，我们只需要包含相应的官方的头文件就可以使用了，那么它的内部具体是如何实现的呢？ 下面来一个典型的例子： 1.使用结构体和联合体A.用struct定义位域的作用：在DSP2833x_Sci.h中有一段: 1234567891011121314struct SCICCR_BITS &#123; // bit description Uint16 SCICHAR:3; // 2:0 Character length control Uint16 ADDRIDLE_MODE:1; // 3 ADDR/IDLE Mode control Uint16 LOOPBKENA:1; // 4 Loop Back enable Uint16 PARITYENA:1; // 5 Parity enable Uint16 PARITY:1; // 6 Even or Odd Parity Uint16 STOPBITS:1; // 7 Number of Stop Bits Uint16 rsvd1:8; // 15:8 reserved 保留&#125;; union SCICCR_REG &#123; Uint16 all; struct SCICCR_BITS bit;&#125;; Uint16 SCICHAR:3 表示定义SCICHAR，它占一个字节中的3位；*注意：必须以4字节对齐！观察上面的SCICCR_BITS的定义也会发现前面定义了3+1+1+1+1+1=8位=1字节 B.再来看union的作用 1234union SCICCR_REG&#123; Uint16 all; struct SCICCR_BITS bit;&#125; 这样定义有什么效果？当我想操作SCICCR_BITS中的每一位时，只需定义union SCICCR_REG reg即可 我们可以整体操作，如：reg.all = 0x0011; 我们可以操作其中一位：reg.bit.PARITY = 0; 还记得c语言中union中的共享同一个内存空间地址么？ 2.使用cmd文件进行数据段与存储器空间映射既然官方已经帮我们做好了上面的一切，上面的东西肯定可以直接使用，那么为什么可以直接使用呢？ 定义一个上面的变量就可以访问到真正硬件上的寄存器了吗？肯定不行！ 我们需要将上面的变量和实际硬件的寄存器存储空间绑定，怎么绑定，通过cmd文件。 下面是官方DSP2833x_GlobalVariableDefs.c中的一段代码： 1234567//----------------------------------------#ifdef __cplusplus#pragma DATA_SECTION("ScicRegsFile")#else#pragma DATA_SECTION(ScicRegs,"ScicRegsFile");#endifvolatile struct SCI_REGS ScicRegs; 官方定义了ScicRegs来操作串口SCI-C的相关的寄存器，但是肯定没法直接使用，还没有做绑定； 使用#pragma DATA_SECTION可以将变量与数据段绑定，变量和数据段是自己定义的，只需要将他们绑定即可； 这样绑定显然还不行，还需要通过cmd文件数据段映射到硬件的寄存器地址空间中去！ 查看DSP2833x_Headers_nonBIOS.cmd文件我们发现其中有这样几行： 12345678910111213141516171819MEMORY&#123; PAGE 0: /* Program Memory */ PAGE 1: /* Data Memory */ ADC : origin = 0x007100, length = 0x000020 /* ADC registers */ SCIB : origin = 0x007750, length = 0x000010 /* SCI-B registers */ SCIC : origin = 0x007770, length = 0x000010 /* SCI-C registers */ I2CA : origin = 0x007900, length = 0x000040 /* I2C-A registers */ &#125; SECTIONS&#123; AdcRegsFile : &gt; ADC, PAGE = 1 ScibRegsFile : &gt; SCIB, PAGE = 1 ScicRegsFile : &gt; SCIC, PAGE = 1 I2caRegsFile : &gt; I2CA, PAGE = 1&#125; MEMORY代表内存空间，PAGE0是程序空间， PAGE1是数据空间； (还记得第一课的介绍么？28335采样的哈佛总线结构，程序与数据分开了~) SECTIONS代表需要映射的段； 通过上面的映射后，操作ScicRegs就可以实际操作串口了，目的也就达到了； 时钟TMS320F28335上有一个基于PLL电路的片上时钟模块，如图1所示，为CPU及外设提供时钟有两种方式： 一种是用外部的时钟源，将其连接到X1引脚上或者XCLKIN引脚上，X2接地；另一种是使用振荡器产生时钟，用30MHz的晶体和两个20PF的电容组成的电路分别连接到X1和X2引脚上，XCLKIN引脚接地。 我们常用第二种来产生时钟。此时钟将通过一个内部PLL锁相环电路，进行倍频。由于F28335的最大工作频率是150M，所以倍频值最大是5。其中倍频值由PLLCR的低四位和PLLSTS的第7、8位来决定。其详细的倍频值可以参照TMS320F28335的Datasheet。 三种时钟输入的接法: 如果我们希望DSP工作在某一个频率下，我们就可以对Uint16 val, Uint16 divsel两个参数进行设定。说白了就相当于乘10，除2 (30*10/2 = 150MHZ) GPIO引脚GPIO（General-Purpose Input/Output）——通用输入/输出口 DSP28335 GPIO模块分为三类IO口：PORTA(0-31),PORTB(32-63),PORTC(64-87) 对GPIO模块的设置主要通过三类寄存器来完成，分别是：控制寄存器、数据寄存器、中断寄存器。 1、控制寄存器 12345678910111213141516171819 GPxCTRL; // GPIO x Control Register (GPIO0 to 31) //设置采样窗周期T=2*GPXCTRL*Tsysclk； GPxQSEL1; // GPIO x Qualifier Select 1 Register (GPIO0 to 15)(32-47) GPxQSEL2; // GPIO x Qualifier Select 2 Register (GPIO16 to 31)(48-63) //每两位控制一个引脚，确定是3周期采样还是6周期采样或者不用采样 GPxMUX1; // GPIO x Mux 1 Register (GPIO0 to 15)(32-47)(64-79) GPxMUX2; // GPIO x Mux 2 Register (GPIO16 to 31)(48-63)(80-95) //配置各个引脚的功能，0：I/O功能，1：外设功能。 GPxDIR; // GPIO x Direction Register (GPIO0 to 31)(32-63)(64-95) //配置每个引脚是输入还是输出，0：数字量输入；1：数字量输出。 GPxPUD; // GPIO x Pull Up Disable Register (GPIO0 to 31)(32-63)(64-95) //使能或禁止内部上拉 0：开启上拉，1：禁止上拉 2、数据寄存器 123456 GPxDAT; // GPIO Data Register (GPIO0 to 31)(32-63)(64-95) GPxSET; // GPIO Data Set Register (GPIO0 to 31)(32-63)(64-95)——置位 GPxCLEAR; // GPIO Data Clear Register (GPIO0 to 31)(32-63)(64-95) GPxTOGGLE; // GPIO Data Toggle Register (GPIO0 to 31)(32-63)(64-95)—反转 3、中断寄存器 12345678910111213141516 GPIOXINT1SEL; // XINT1 GPIO Input Selection GPIOXINT2SEL; // XINT2 GPIO Input Selection GPIOXNMISEL; // XNMI_Xint13 GPIO Input Selection GPIOXINT3SEL; // XINT3 GPIO Input Selection GPIOXINT4SEL; // XINT4 GPIO Input Selection GPIOXINT5SEL; // XINT5 GPIO Input Selection GPIOXINT6SEL; // XINT6 GPIO Input Selection GPIOXINT7SEL; // XINT7 GPIO Input Selection GPIOLPMSEL; // Low power modes GP I/O input select 可以对GPIO0-63进行外部中断设置； 具体定义在DSP28335Gpio.h中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct GPIO_CTRL_REGS &#123; union GPACTRL_REG GPACTRL; // GPIO A Control Register (GPIO0 to 31) union GPA1_REG GPAQSEL1; // GPIO A Qualifier Select 1 Register (GPIO0 to 15) union GPA2_REG GPAQSEL2; // GPIO A Qualifier Select 2 Register (GPIO16 to 31) union GPA1_REG GPAMUX1; // GPIO A Mux 1 Register (GPIO0 to 15) union GPA2_REG GPAMUX2; // GPIO A Mux 2 Register (GPIO16 to 31) union GPADAT_REG GPADIR; // GPIO A Direction Register (GPIO0 to 31) union GPADAT_REG GPAPUD; // GPIO A Pull Up Disable Register (GPIO0 to 31) Uint32 rsvd1; union GPBCTRL_REG GPBCTRL; // GPIO B Control Register (GPIO32 to 63) union GPB1_REG GPBQSEL1; // GPIO B Qualifier Select 1 Register (GPIO32 to 47) union GPB2_REG GPBQSEL2; // GPIO B Qualifier Select 2 Register (GPIO48 to 63) union GPB1_REG GPBMUX1; // GPIO B Mux 1 Register (GPIO32 to 47) union GPB2_REG GPBMUX2; // GPIO B Mux 2 Register (GPIO48 to 63) union GPBDAT_REG GPBDIR; // GPIO B Direction Register (GPIO32 to 63) union GPBDAT_REG GPBPUD; // GPIO B Pull Up Disable Register (GPIO32 to 63) Uint16 rsvd2[8]; union GPC1_REG GPCMUX1; // GPIO C Mux 1 Register (GPIO64 to 79) union GPC2_REG GPCMUX2; // GPIO C Mux 2 Register (GPIO80 to 95) union GPCDAT_REG GPCDIR; // GPIO C Direction Register (GPIO64 to 95) union GPCDAT_REG GPCPUD; // GPIO C Pull Up Disable Register (GPIO64 to 95)&#125;; struct GPIO_DATA_REGS &#123; union GPADAT_REG GPADAT; // GPIO Data Register (GPIO0 to 31) union GPADAT_REG GPASET; // GPIO Data Set Register (GPIO0 to 31) union GPADAT_REG GPACLEAR; // GPIO Data Clear Register (GPIO0 to 31) union GPADAT_REG GPATOGGLE; // GPIO Data Toggle Register (GPIO0 to 31) union GPBDAT_REG GPBDAT; // GPIO Data Register (GPIO32 to 63) union GPBDAT_REG GPBSET; // GPIO Data Set Register (GPIO32 to 63) union GPBDAT_REG GPBCLEAR; // GPIO Data Clear Register (GPIO32 to 63) union GPBDAT_REG GPBTOGGLE; // GPIO Data Toggle Register (GPIO32 to 63) union GPCDAT_REG GPCDAT; // GPIO Data Register (GPIO64 to 95) union GPCDAT_REG GPCSET; // GPIO Data Set Register (GPIO64 to 95) union GPCDAT_REG GPCCLEAR; // GPIO Data Clear Register (GPIO64 to 95) union GPCDAT_REG GPCTOGGLE; // GPIO Data Toggle Register (GPIO64 to 95) Uint16 rsvd1[8];&#125;; struct GPIO_INT_REGS &#123; union GPIOXINT_REG GPIOXINT1SEL; // XINT1 GPIO Input Selection union GPIOXINT_REG GPIOXINT2SEL; // XINT2 GPIO Input Selection union GPIOXINT_REG GPIOXNMISEL; // XNMI_Xint13 GPIO Input Selection union GPIOXINT_REG GPIOXINT3SEL; // XINT3 GPIO Input Selection union GPIOXINT_REG GPIOXINT4SEL; // XINT4 GPIO Input Selection union GPIOXINT_REG GPIOXINT5SEL; // XINT5 GPIO Input Selection union GPIOXINT_REG GPIOXINT6SEL; // XINT6 GPIO Input Selection union GPIOXINT_REG GPIOXINT7SEL; // XINT7 GPIO Input Selection union GPADAT_REG GPIOLPMSEL; // Low power modes GP I/O input select&#125;; 注意：GPIO相关寄存器介绍 1、GPxMUX寄存器（功能选择寄存器） 每个I/O口都有一个功能选择寄存器，功能选择寄存器主要用于选择I/O工作在特殊功能还是通用数组I/O模式。在复位时，所有GPIO配置成通用数字模式。 1）如果GPxMUX.bit = 0，配置成通用数字I/O功能； 2）如果GPxMUX.bit = 1 2 3，配置成特殊外设功能口（如SCI、CAN）； I/O的输入功能和外设的输入通道总是被使能的，输出通道是通用数组I/O和特殊外设复用的。如果引脚配置成通用数组I/O功能，相应的外设功能将被禁止。 2、GPxDIR（方向控制寄存器） 每个I/O口都有数据方向控制寄存器，数据方向控制寄存器用于设置通用数字I/O为输入还是输出口，在复位时，引脚的默认状态为输入状态。 1）如果GPxDIR.bit = 0，引脚设置为通用数字量输入； 2）如果GPxDIR.bit = 1，引脚设置为通用数字量输出； 复位时，GPxMUX和GPxDIR默认值都为0，所以在复位时，引脚的默认状态为数字I/O输入。 3、GPxDAT寄存器（数据寄存器） 每个I/O口都有一个数据寄存器，数据寄存器是可读可写寄存器。 1）I/O设置为输出功能时，如果GPxDAT.bit = 0，那么操作将会使相应的引脚拉低； 2）I/O口设置为输入功能时，如果GPxDAT.bit = 0，反映相应的引脚状态为低电平； 3）I/O口设置为输出功能时，如果GPxDAT.bit = 1，那么操作将会使相应的引脚拉高； 4）I/O口设置为输入功能时，如果GPxDAT.bit = 1，反映相应的引脚状态为高电平。 需要说明的是，当用户试图改变一个数字I/O的状态时，不要改变另一个I/O的引脚状态。 4、GOxSET寄存器（置位寄存器） 每个I/O口都有一个置位寄存器，置位寄存器是只写寄存器，任何读操作都返回0，如果相应的引脚配置成数据量输出，写1后相应的引脚会置高，写0时没有反映。 1）如果GPxSET.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxSET.bit = 1，那么操作将会使引脚置高。 5、GPxCLEAR寄存器（清除寄存器） 每个I/O口都有一个清除寄存器，清除寄存器是只写寄存器，任何读操作都返回0。 1）如果GPxCLEAR.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxCLEAR.bit = 1，将相应的引脚置成低电平。 6、GPxTOGGLE寄存器（取反触发寄存器） 每个I/O口都有一个取反触发寄存器，该寄存器是只写寄存器，任何读操作都返回0。 1）如果GPxTOGGLE.bit = 0，没有影响； 2）引脚设置为输出时，如果GPxTOGGLE.bit = 1，那么操作将使相应的引脚取反。 中断1.中断系统 在这里我们要十分清楚DSP的中断系统。C28XX一共有16个中断源，其中有2个不可屏蔽的中断RESET和NMI、定时器1和定时器2分别使用中断13和14。这样还有12个中断都直接连接到外设中断扩展模块PIE上。说的简单一点就是PIE通过12根线与28335核的12个中断线相连。而PIE的另外一侧有12*8根线分别连接到外设，如AD、SPI、EXINT等等。 PIE共管理12*8=96个外部中断。这12组大中断由28335核的中断寄存器IER来控制，即IER确定每个中断到底属于哪一组大中断（如IER |= M_INT12; 说明我们要用第12组的中断，但是第12组里面的什么中断CPU并不知道需要再由PIEIER确定）。 接下来再由PIE模块中的寄存器PIEIER中的低8确定该中断是这一组的第几个中断，这些配置都要告诉CPU（我们不难想象到PIEIER共有12总即从PIEIER1-PIEIER12）。另外，PIE模块还有中断标志寄存器PIEIFR，同样它的低8位是来自外部中断的8个标志位，同样CPU的IFR寄存器是中断组的标志寄存器。由此看来，CPU的所有中断寄存器控制12组的中断，PIE的所有中断寄存器控制每组内8个的中断。除此之外，我们用到哪一个外部中断，相应的还有外部中断的寄存器，需要注意的就是外部中断的标志要自己通过软件来清零。而PIE和CPU的中断标志寄存器由硬件来清零。 12345678EALLOW; // This is needed to write to EALLOW protected registers PieVectTable.XINT2 = &amp;ISRExint; //告诉中断入口地址EDIS; // This is needed to disable write to EALLOW protected registersPieCtrlRegs.PIECTRL.bit.ENPIE = 1; // Enable the PIE block使能PIEPieCtrlRegs.PIEIER1.bit.INTx5= 1; //使能第一组中的中断5IER |= M_INT1; // Enable CPU 第一组中断EINT; // Enable Global interrupt INTMERTM; // Enable Global realtime interrupt DBGM 也就是说，12组中的每个中断都要完成上面的相同配置，剩下的才是去配置自己的中断。如我们提到的EXINT，即外面来个低电平我们就进入中断，完成我们的程序。在这里要介绍一下，DSP的GPIO口都可以配置为外部中断口，其配置方法如下： 1234567891011121314151617181920212223242526272829GpioCtrlRegs.GPBMUX2.bit.GPIO54 = 0; //选择他们是GPIO口GpioCtrlRegs.GPBMUX2.bit.GPIO55 = 0;GpioCtrlRegs.GPBMUX2.bit.GPIO56 = 0;GpioCtrlRegs.GPBMUX2.bit.GPIO57 = 0; GpioCtrlRegs.GPBDIR.bit.GPIO54 = 0;//选择他们都是输入口GpioCtrlRegs.GPBDIR.bit.GPIO55 = 0;GpioCtrlRegs.GPBDIR.bit.GPIO56 = 0;GpioCtrlRegs.GPBDIR.bit.GPIO57 = 0; GpioCtrlRegs.GPBQSEL2.bit.GPIO54= 0;//使GPIO时钟和系统时钟一样 且支持GPIOGpioCtrlRegs.GPBQSEL2.bit.GPIO55= 0;GpioCtrlRegs.GPBQSEL2.bit.GPIO56= 0;//配置输入口权限，对于选择为输入口的需配置GPACTRL,GPBCTRL,GPAQSEL1GpioCtrlRegs.GPBQSEL2.bit.GPIO57= 0;//GPAQSEL2, GPBQSEL1, and GPBQSEL2寄存器所有输入信号与CPU输出系统时钟同步； GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = 54;//中断3选择GPIOGpioIntRegs.GPIOXINT4SEL.bit.GPIOSEL = 55;GpioIntRegs.GPIOXINT5SEL.bit.GPIOSEL = 56;GpioIntRegs.GPIOXINT6SEL.bit.GPIOSEL = 57; XIntruptRegs.XINT3CR.bit.POLARITY= 0;//触发模式为下降沿触发XIntruptRegs.XINT4CR.bit.POLARITY= 0;XIntruptRegs.XINT5CR.bit.POLARITY= 0;XIntruptRegs.XINT6CR.bit.POLARITY= 0; XIntruptRegs.XINT3CR.bit.ENABLE = 1;//使能中断XIntruptRegs.XINT4CR.bit.ENABLE = 1;XIntruptRegs.XINT5CR.bit.ENABLE = 1;XIntruptRegs.XINT6CR.bit.ENABLE = 1; 注意一点就是外部中断1和2只能对GPIO0—GPIO31配置；外部中断3和4、5、6、7只对GPIO32—GPIO63配置。 GPIO分为A(0-31)、B(32-63)、C(64-87);C组的不能配置为外部中断； 2.如何开启某个中断？ 设置中断向量。例如：PieVectTable.ADCINT = &amp;adc_isr;等打开PIE控制器。PieCtrlRegs.PIECTRL.bit.ENPIE = 1;使能PIE中对应外设的中断（相应group的相应pin）。例如：PieCtrlRegs.PIEIER1.bit.INTx8 = 1; PieCtrlRegs.PIEIER1.bit.INTx6 = 1;等使能CPU的相应中断（INT1~INT12）IER |= M_INT1;使能CPU响应中断EINT、ERTM;; 3.中断标志有几级？作用是什么？ 中断标志主要有三级CPU（有16个标志位）、PIE（有12组每组有12个标志位）和外设（有的外设没有）。 标志位在中断发生后锁存中断状态，即表示中断发生。在CPU响应中断后，会自动清除cpu级别的标志位IFR bit，同时将INTM bit 置位，以防止其它中断的发生； CPU在从PIE中取中断向量时PIE会自动清除PIE级别的标志位PIEIFRx.y。所以在进入中断处理程序后除了外设所有中断位都已经清除。 而中断处理程序中需要清除PIEACKx和外设的中断标志位（如果有的话）。 在CPU响应一个中断后，在进入ISR的时候，默认会关断全局中断，即在执行中断服务程序时，不会有其他中断来打断CPU，包括本次的中断事件。另外，如果外设的中断标志位不清除，不会循环进入这个中断服务函数，这个外设中断被阻断了。所以只有清除外设的中断服务程序，才能响应下一次的外设中断。PIEACK同理，如果没有PIEACK，这组所有中断都被阻断。 参考文献[1] TMS320F2833x Datasheet [2] 风雨也无晴 CSDN [3] GPIO blog]]></content>
      <tags>
        <tag>DSP28335</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP 串口接口及通信通信]]></title>
    <url>%2F2019%2F08%2F09%2F%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[对串口通信进行简单知识点梳理串行通信可以分为两大类： 同步通信：典型 I2C,SPI 异步通信：典型 SCI(serial communication interface,串行通信接口) 进行串口异步通信接口，一般可以看作UART口(Universal Asynchronous Receiver Transmitter：通用异步收发器/异步串行通信口) UART、COM指物理接口形式(硬件), TTL、RS232、RS485 指电平标准(电信号) SCI 串口先来补充一个概念:FIFO（First Input First Output），即先进先出队列。 SCI模块介绍TMS320F28335内部有三个SCI模块，SCIA、SCIB、SCIC。 每一个SCI模块都有一个接收器和发送器，SCI的接收器和发送器各有一个16级的FIFO(First In First Out先入先出)队列，它们都还有自己独立的使能位和中断位；可以工作在半双工或全双工模式。 1. SCI的CPU 接口SCI 模块具有两个引脚， SCITXDA 和 SCIRXDA，分别实现发送数据和接收数据的功能，这两个引脚对应于 GPIOF 模块的第4和第5位，在编程初始化的时候，需要将GPIOFMUX 寄存器的第4和第5位置为1，才能使得这两个引脚具有发送和接收的功能，否则就是普通的I/O引脚。外部晶振通 PLL 模块产生了CPU 的系统时钟SYSCLKOUT，然后SYSCLKOUT经过低速预定标器之后输出低速时钟LSPCLK 供给SCI。要保证SCI的正常运行，系统控制模块下必须使能SCI的时钟，也就是在系统初始化函数中需要将外设时钟控制寄存器PCLKCR的SCIAENCLK位置1。从下图，我们可以清楚的看到SCIA可以产生两个中断，SCIRXINTA 和SCITXINTA，即发送中断和接收中断。 2. SCI相关寄存器 SCICR：SCI通信参数设置寄存器，设置数据位，停止位，奇偶校验位。 SCICTL1：使能SCI的发送接收功能 注：SW RESET需置1 SCILBAUD、SCIHBAUD：通信速率（波特率）的设置。 SCICTL2：使能接收发送中断，以及发送中断标志位。 SCIRXST：接收相关标志位。 SCIRXBUF：8位发送缓存寄存器 SCITXBUF：8位接收缓存寄存器。 SCI中断配置： SCI的中断采用三级中断管理。分别是SCI外设中断，PIE中断，CPU中断。SCIA的PIE中断是第九组，分别是INT９.１和INT９.２.PIE中断的配置在前面已经说过了，此处不多说。注意：在中断不要忘记将PIEACK写１清除。 SCI的FIFO模式： FIFO：先入先出队列。SCI采用这种模式时，接收或者发送完指定字节数量的数据后，才进入中断处理。这样可以节省了CPU的使用效率，CPU不用每次接收完一个字节的数据后就进入中断处理。 相关寄存器： SCIFFTX：配置发送的数据量，使能SCI的FIFO模式，使能中断等 SCIFFRX：配置接收的数据量，使能接收中断等。 在学习FIFO模式时，遇到一个问题，就是接收完指定数量字节的数据后，总是重复进入两次发送中断，一次找不到原因。下面贴出代码，希望各位读者不吝赐教。 3. SCI 模块发送和接收数据的工作原理 SCI 模块的工作原理如下图所示，之所以SCI 能工作于全双工模式，是因为它有独立的数据发送器和数据接收器，这样能够保证SCI既能够同时进行，也能够独立进行发送和接收的操作。 SCI 发送数据的过程如下：如下图右半部分所示， 在FIFO功能使能的情况下， 首先，发送数据缓冲寄存器SCITXBUF从TX FIFO 中获取由 CPU 加载的需要发送的数据，然后 SCITXBUF将数据传输给发送移位寄存器TXSHF， 如果SCI的发送功能使能， TXSHF 则将接收到的数据逐位逐位的移到 SCITXD 引脚上。 SCI接收数据的过程如下：如X下图的左半部分所示，首先，接收移位寄存器 RXSHF 逐位逐位的接收来自于 SCIRXD 引脚的数据， 如果 SCI 的接收功能使能， RXSHF 将这些数据传输给接收缓冲寄存器 SCIRXBUF，CPU 就能从 SCIRXBUF 读取外部发送来的数据。当然，如果 FIFO 功能使能的话， SCIRXBUF 会将数据加载到RX FIFO 的队列中， CPU 再从FIFO 的队列读取数据。 4. SCI数据格式 在 SCI 中，通信协议体现在 SCI 的数据格式上。 通常将 SCI 的数据格式称之为可编程的数据格式，原因就是可以通过 SCI 的通信控制寄存器 SCICCR 来进行设置，规定通信过程中所使用的数据格式。 在空闲线模式下， SCI 发送或者接收一帧的数据格式如图 4 所示，其中 LSB 是数据的最低位， MSB 是数据的最高位。 使用 SCICCR 进行数据格式编程 12345678SciaRegs.SCICCR.bit.SCICHAR=8;//选择数据长度，为 8 个数据位SciaRegs.SCICCR.bit.PARITYENA=1;//开启极性功能，值为 0 的时候取消极性功能SciaRegs.SCICCR.bit.PARITY=0;//在开启极性功能的前提下，该位值为 0 时选择偶极性，值为 1 时选择奇极性SciaRegs.SCICCR.bit.STOPBITS=0;//选择停止位，该位为 0 时有 1 个停止位，该位为 1 时有 2 个停止位 当然，上述这几个语句，我们也可以合并成如下的语句： 1SciaRegs.SCICCR.all=0x13; 5. SCI通信波特率 所谓的波特率就是指每秒所能发送的位数。SCI波特率设置寄存器SCIHBAUD和SCILBAUD，0-15是高字节与低字节连在一起，构成16位波特率设置寄存器BRR。BRR = SCIHBAUD + SCILBAUD 如果1&lt;= BRR &lt;=65535，那么SCI波特率=LSPCLK / ( (BRR+1) * 8 )，由此，可以带入你需要的波特率，既可以得到BRR的值；如果BRR = 0，那么SCI波特率=LSPCLK/ 16 我们举例来进行说明。例如外部晶振位 30M，经过 PLL 之后 SYSCLKOUT 为 150MHz，然后，当低速预定标器 LOSPCP 的值为 2 的时候， SYSCLKOUT 经过低速预定标器之后产生&gt;低速外设时钟 LSPCLK 为 37.5MHz，也就是说 SCI 的时钟为 37.5MHz。如果我们需要 SCI 的波特率为 19200，则将 LSPCLK 和波特率的数值代入式 1，便可得到BRR=243.14，由于寄存器都是正整数，所以省略掉小数后可以得到 BRR=243。将 243 转换成 16 进制是 0xF3，因此 SCIHBAUD 的值为 0， SCIHBAUD 的值为 0XF3。由于省略了小数，将会产生 0.06%的误差。 当 LSPCLK 为 37.5M 时，对于 SCI 常见的波特率，其寄存器的值如下表所示： 6. 串口SCI编程 A. 先初始化IO管脚 (以SCI-A为例，SCI-B、SCI-C的初始化方法一样，就是照着改对应的管脚就行) 1234567891011121314void InitSciaGpio() //初始化SCIA的GPIO管脚为例子&#123;EALLOW;//根据硬件设计决定采用GPIO28/29和GPIO35/36中的哪一组。这里以35/36为例//定义管脚为上拉GpioCtrlRegs.GPBPUD.bit.GPIO36 = 0;GpioCtrlRegs.GPBPUD.bit.GPIO35 = 0;//定义管脚为异步输入GpioCtrlRegs.GPBQSEL1.bit.GPIO36 = 3;//配置管脚为SCI功能管脚GpioCtrlRegs.GPBMUX1.bit.GPIO36 = 1;GpioCtrlRegs.GPBMUX1.bit.GPIO35 = 1;EDIS;&#125; B. SCI初始化配置 12345678910111213void scia_init()&#123;SciaRegs.SCICCR.all =0x0007; // 1 stop bit, No loopback// No parity,8 char bits,// async mode, idle-line protocolSciaRegs.SCICTL1.all =0x0003; // enable TX, RX, internal SCICLK,// Disable RX ERR, SLEEP, TXWAKESciaRegs.SCICTL2.bit.TXINTENA =1; //发送中断使能SciaRegs.SCICTL2.bit.RXBKINTENA =1;//接收中断使能SciaRegs.SCIHBAUD =0x0001; // 9600 baud @LSPCLK = 37.5MHz.SciaRegs.SCILBAUD =0x00E7;SciaRegs.SCICTL1.all =0x0023; // Relinquish SCI from Reset&#125; C. 接着进行中断的配置 123456EALLOW; // This is needed to write to EALLOW protected registersPieVectTable.SCIRXINTA = &amp;sciaRxIsr;PieVectTable.SCITXINTA = &amp;sciaTxIsr;PieVectTable.SCIRXINTB = &amp;scibRxIsr;PieVectTable.SCITXINTB = &amp;scibTxIsr;EDIS; // This is needed to disable write to EALLOW protected registers D. 上面是将SCIA和SCIB的中断服务程序连到PIE的中断表中，发生中断就会跑到你的ISR去了，下面是开中断： 1234567PieCtrlRegs.PIECTRL.bit.ENPIE = 1; // Enable the PIE blockPieCtrlRegs.PIEIER9.bit.INTx1=1; // PIE Group 9, int1PieCtrlRegs.PIEIER9.bit.INTx2=1; // PIE Group 9, INT2PieCtrlRegs.PIEIER9.bit.INTx3=1; // PIE Group 9, INT3PieCtrlRegs.PIEIER9.bit.INTx4=1; // PIE Group 9, INT4IER = 0x100; // Enable CPU INTEINT; 这样串口基本就OK了。 参考文献[1] 接口及协议总结[2] SCI通信]]></content>
      <tags>
        <tag>上位机</tag>
        <tag>串口通信</tag>
        <tag>DSP28335</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP电机平台上位机编写(Python+pyqt)]]></title>
    <url>%2F2019%2F08%2F06%2FDSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[准备给DSP电机平台增加一个电机转速调节的上位机。 目的： 1.学习python，并利用它做点东西 2.对串口通信有更加深刻的了解 计划步骤： 1.先把Python的基础知识有大体了解 2.学习pyqt并绘制上位机界面 3.做好串口通信的工作 环境的搭建环境搭建参考： 环境搭建 再由.ui转成.py时，再最后添加：参考 Ui_MainWindow 要和前面类名一致 1234567891011class MyWindow(QtWidgets.QMainWindow, Ui_MainWindow): def __init__(self): super(MyWindow, self).__init__() self.setupUi(self)if __name__ == '__main__': import sys app = QtWidgets.QApplication(sys.argv) mywindow = MyWindow() mywindow.show() sys.exit(app.exec_()) 槽函数 未完待续~~]]></content>
      <tags>
        <tag>DSP平台</tag>
        <tag>上位机</tag>
        <tag>Python</tag>
        <tag>pyqt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业岗位要求]]></title>
    <url>%2F2019%2F08%2F06%2F%E4%BC%81%E4%B8%9A%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[几家企业的岗位要求，激励自己不断前进！]]></content>
      <tags>
        <tag>岗位要求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柔性负载]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[中心刚体-悬臂梁系统 (欧拉-伯努利梁)[5]如工业机器人中的柔性机械臂等。单柔性连杆伺服驱动系统如图所示。图中：u(x,t)为挠性负载在x处的挠度；θm(t)为伺服电机转轴的转角；Ta为伺服电机驱动转矩。 单柔性连杆伺服电机驱动系统动力学方程(ξ为各阶振动模态阻尼系数矩阵): 简化后的挠性连杆伺服系统状态方程: 该系统的传递函数如下: PMSM直接驱动柔性负载[2]PMSM直接驱动柔性负载 状态方程 转速环和电流环 开环传递函数 为： 参考文献[1]丁有爽,肖曦.基于负载位置反馈的永磁同步电机驱动柔性负载谐振抑制方法[J].电工技术学报,2017,32(11):96-110. [2]丁有爽,肖曦.永磁同步电机直接驱动柔性负载控制方法[J].电工技术学报,2017,32(04):123-132. [3]丁有爽,肖曦.基于极点配置的永磁同步电机驱动柔性负载PI调节器参数确定方法[J].中国电机工程学报,2017,37(04):1225-1239. [4]丁有爽,肖曦.基于状态反馈和转矩补偿的永磁同步电机驱动柔性负载控制方法[J].中国电机工程学报,2017,37(13):3892-3900. [5]丁有爽,肖曦.伺服系统柔性负载建模方法研究[J].中国电机工程学报,2016,36(03):818-827.]]></content>
      <tags>
        <tag>PMSM</tag>
        <tag>柔性负载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于DSP平台双UDE 参数调试]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.挑选了几组典型数据画图，这里面的滤波器参数都是随意设置的（因为现在还无法确定kp和alpha之间的关系） 2.xx_xxx3.fig 中红色为实际数值 蓝色为指令，绿色为经过滤波器的输出结果(画图程序在最后)。 3.图中的时间 10000点 = 5s 4.Main_twoloop190801.c为源程序。 5.文件夹中 01-07为电流环调试过程, 08-11为速度环调试过程, 12 给了一个比较极端的速度环滤波器参数。 数据对应参数： spd_Factor spd_kp spd_ki iq_Factor iq_kp iq_ki 01参数 0.1667 0.8 0.0015 0.007 1.0 0.0025 05参数 0.1667 0.8 0.0015 0.007 2.1 0.0025 06参数 0.1667 0.8 0.0015 0.007 2.5 0.0025 10参数 0.1667 3.0 0.0015 0.007 2.5 0.0025 12参数 0.0007 0.8 0.0015 0.007 2.5 0.0025 6.画图函数 1234567891011121314figure(1)plot(t,spd,'r','LineWidth',1)hold onplot(t,spdr-5,'g','LineWidth',1)hold onplot(t,spdc-5,'b','LineWidth',1)grid onfigure(2)plot(t,iq,'r','LineWidth',1)hold onplot(t,iqr,'g','LineWidth',1)hold onplot(t,iqc,'b','LineWidth',1)grid on]]></content>
      <tags>
        <tag>DSP平台</tag>
        <tag>PMSM</tag>
        <tag>UDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于加入站内搜索]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[今天按照网上的加入本站搜索功能 无论如何都加不进去，后来在查看 NEXT给的官方解读中看到解决方法网址如下，查看Local Search方法 https://theme-next.org/docs/third-party-services/search-services]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不懂的知识点 查阅 汇总]]></title>
    <url>%2F2019%2F08%2F01%2F%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[单工、半双工和全双工的区别 一、单工1、数据只在一个方向上传输，不能实现双方通信。 2、栗子：电视、广播。 二、半双工1、允许数据在两个方向上传输，但是同一时间数据只能在一个方向上传输，其实际上是切换的单工。 2、栗子：对讲机。 三、全双工1、允许数据在两个方向上同时传输。 2、栗子：手机通话。 TCP/IP （传输控制协议）Transmission Control Protocol TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。 TCP/IP 意味着 TCP 和 IP 在一起协同工作。TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。IP 负责将包发送至接受者。 api （应用程序编程接口）API 是一套明确定义的各种软件组件之间的通信方法。 http、MQTT、CoAPHTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。支持长连接！适用于抄表 CoAP 由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。 IETF的CoRE工作组提出了一种基于REST架构的CoAP协议;是一种在物联网世界的类web协议。不支持长连接 基于UDO 可靠性不高 适用于智能家居 OSI七层模型/TCP/IP五层模型：OSI七层模型(整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。) &lt;1&gt; 应用层 OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。 实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询&gt; 价单，等等。 &lt;2&gt;表示层 表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。 &lt;3&gt;会话 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。 &lt;4&gt;传输层 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的， TCP UDP 就是在这一层。端口号既是这里的“端”。 传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。 &lt;5&gt;网络层 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。 网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。 &lt;6&gt;数据链路层 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。 这个没找到合适的例子 &lt;7&gt; 物理层 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。 快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。 [ TCP/IP五层模型 TCP/IP五层协议和OSI的七层协议对应关系如下。 在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 在每一层实现的协议也各不同，即每一层的服务也不同。下图列出了每层主要的协议。 鉴权 鉴权（authentication）是指验证用户是否拥有访问系统的权利。 CIG、IOCM、DM Server、Mongo DBCIG (Cell Interconnection Gateway) 信元互连网关 $\color{red}{未完待续~~}$]]></content>
      <tags>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交流电机前言讲座考试总结]]></title>
    <url>%2F2019%2F07%2F29%2F%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简单的做一下知识点梳理。 电机的控制问题 交流电机 同步电机 附赠：电机的应用]]></content>
      <tags>
        <tag>PMSM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于404问题及感谢]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2%2F</url>
    <content type="text"><![CDATA[CNAME里面是写xxx.github.io 解析域名的时候最好用CNAME并 解析到 xxx.github.io GitHub 仓库里的Setting 最好也改成www.xxx.xxx 顺便感谢一下搭建博客参考网站 UP：CodeSheep UP：吃饱睡觉的猫 遇见西门]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于dsp平台电流环解耦]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6%2F</url>
    <content type="text"><![CDATA[120V电压 400rpm的给定电流 应该加的补偿值 ​ttt = 0.00105 \* \_IQmpy(pi_id.Fbk,pi_spd.Fbk) \* 4500 \* 9 /(volt1.DcBusVolt\*409.9) + 0.065 \* pi_spd.Fbk \* 4500 /(volt1.DcBusVolt\*409.9); 下面是解耦后应该的公式. ​ipark1.Qs = pi_iq.Out + ttt;​ 在未解耦的时候，测得ipark1.Qs = 0.515 . 换算成真实的电压值为(乘当前的电流值) 0.515 * 120 V=61.8V 测得ttt = 0.22 . 换算成真实的电压值为26.4V. ttt的主要成份是反电势 ​flux\*we=0.1552\*400\*4\*3.14/30=26.0V​ 所以证明电流环解耦 程序是正确的. 实验结果 （右为解耦）]]></content>
      <tags>
        <tag>DSP平台</tag>
        <tag>PMSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first generage blog]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一个博客 杠杠滴]]></content>
  </entry>
</search>
