<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DSP基础知识一览</title>
      <link href="/2019/08/10/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88/"/>
      <url>/2019/08/10/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="CCS编程基础"><a href="#CCS编程基础" class="headerlink" title="CCS编程基础"></a>CCS编程基础</h2><p>CCS开发环境已经为我们封装好了许多片内外设寄存器的结构体，我们只需要包含相应的官方的头文件就可以使用了，那么它的内部具体是如何实现的呢？</p><p>下面来一个典型的例子：</p><h3 id="1-使用结构体和联合体"><a href="#1-使用结构体和联合体" class="headerlink" title="1.使用结构体和联合体"></a>1.使用结构体和联合体</h3><p><strong>A.用struct定义位域的作用：在DSP2833x_Sci.h中有一段:</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">SCICCR_BITS</span> &#123;</span>        <span class="comment">// bit    description</span></span><br><span class="line">   Uint16 SCICHAR:<span class="number">3</span>;         <span class="comment">// 2:0    Character length control</span></span><br><span class="line">   Uint16 ADDRIDLE_MODE:<span class="number">1</span>;   <span class="comment">// 3      ADDR/IDLE Mode control</span></span><br><span class="line">   Uint16 LOOPBKENA:<span class="number">1</span>;       <span class="comment">// 4      Loop Back enable</span></span><br><span class="line">   Uint16 PARITYENA:<span class="number">1</span>;       <span class="comment">// 5      Parity enable</span></span><br><span class="line">   Uint16 PARITY:<span class="number">1</span>;          <span class="comment">// 6      Even or Odd Parity</span></span><br><span class="line">   Uint16 STOPBITS:<span class="number">1</span>;        <span class="comment">// 7      Number of Stop Bits</span></span><br><span class="line">   Uint16 rsvd1:<span class="number">8</span>;           <span class="comment">// 15:8   reserved 保留</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> SCICCR_REG &#123;</span><br><span class="line">   Uint16              all;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SCICCR_BITS</span>  <span class="title">bit</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Uint16 SCICHAR:3 表示定义SCICHAR，它占一个字节中的3位；<strong>*注意：必须以4字节对齐！观察上面的SCICCR_BITS的定义也会发现前面定义了3+1+1+1+1+1=8位=1字节</strong></p><p><strong>B.再来看union的作用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> SCICCR_REG&#123;</span><br><span class="line">      Uint16     all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">SCICCR_BITS</span> <span class="title">bit</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义有什么效果？<br>当我想操作SCICCR_BITS中的每一位时，只需定义union SCICCR_REG reg即可</p><p>我们可以整体操作，如：reg.all = 0x0011;</p><p>我们可以操作其中一位：reg.bit.PARITY = 0;</p><p>还记得c语言中union中的共享同一个内存空间地址么？</p><h3 id="2-使用cmd文件进行数据段与存储器空间映射"><a href="#2-使用cmd文件进行数据段与存储器空间映射" class="headerlink" title="2.使用cmd文件进行数据段与存储器空间映射"></a>2.使用cmd文件进行数据段与存储器空间映射</h3><p>既然官方已经帮我们做好了上面的一切，上面的东西肯定可以直接使用，那么为什么可以直接使用呢？</p><p>定义一个上面的变量就可以访问到真正硬件上的寄存器了吗？肯定不行！</p><p>我们需要将上面的变量和实际硬件的寄存器存储空间绑定，怎么绑定，通过cmd文件。</p><p>下面是官方DSP2833x_GlobalVariableDefs.c中的一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">"ScicRegsFile"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(ScicRegs,<span class="meta-string">"ScicRegsFile"</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">SCI_REGS</span> <span class="title">ScicRegs</span>;</span></span><br></pre></td></tr></table></figure><p>官方定义了ScicRegs来操作串口SCI-C的相关的寄存器，但是肯定没法直接使用，还没有做绑定；</p><p>使用#pragma DATA_SECTION可以将变量与数据段绑定，变量和数据段是自己定义的，只需要将他们绑定即可；</p><p>这样绑定显然还不行，还需要通过cmd文件数据段映射到硬件的寄存器地址空间中去！</p><p>查看DSP2833x_Headers_nonBIOS.cmd文件我们发现其中有这样几行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line"> PAGE <span class="number">0</span>:    <span class="comment">/* Program Memory */</span></span><br><span class="line"> </span><br><span class="line"> PAGE <span class="number">1</span>:    <span class="comment">/* Data Memory */</span> </span><br><span class="line">   </span><br><span class="line">   ADC         : origin = <span class="number">0x007100</span>, length = <span class="number">0x000020</span>     <span class="comment">/* ADC registers */</span></span><br><span class="line">   SCIB        : origin = <span class="number">0x007750</span>, length = <span class="number">0x000010</span>     <span class="comment">/* SCI-B registers */</span></span><br><span class="line">   SCIC        : origin = <span class="number">0x007770</span>, length = <span class="number">0x000010</span>     <span class="comment">/* SCI-C registers */</span>   </span><br><span class="line">   I2CA        : origin = <span class="number">0x007900</span>, length = <span class="number">0x000040</span>     <span class="comment">/* I2C-A registers */</span> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   AdcRegsFile       : &gt; ADC,         PAGE = <span class="number">1</span></span><br><span class="line">   ScibRegsFile      : &gt; SCIB,        PAGE = <span class="number">1</span></span><br><span class="line">   ScicRegsFile      : &gt; SCIC,        PAGE = <span class="number">1</span></span><br><span class="line">   I2caRegsFile      : &gt; I2CA,        PAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MEMORY代表内存空间，PAGE0是程序空间， PAGE1是数据空间；</p><p>(还记得第一课的介绍么？28335采样的哈佛总线结构，程序与数据分开了~)</p><p>SECTIONS代表需要映射的段；</p><p>通过上面的映射后，操作ScicRegs就可以实际操作串口了，目的也就达到了；</p><hr><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>TMS320F28335上有一个基于PLL电路的片上时钟模块，如图1所示，为CPU及外设提供时钟有两种方式：</p><blockquote><p>一种是用外部的时钟源，将其连接到X1引脚上或者XCLKIN引脚上，X2接地；<br>另一种是使用振荡器产生时钟，用30MHz的晶体和两个20PF的电容组成的电路分别连接到X1和X2引脚上，XCLKIN引脚接地。</p></blockquote><p>我们常用第二种来产生时钟。此时钟将通过一个内部PLL锁相环电路，进行倍频。由于F28335的最大工作频率是150M，所以倍频值最大是5。其中倍频值由PLLCR的低四位和PLLSTS的第7、8位来决定。其详细的倍频值可以参照TMS320F28335的Datasheet。</p><p><img src="https://s2.ax1x.com/2019/08/10/eXpGTJ.png" alt="eXpGTJ.png"></p><p>三种时钟输入的接法:</p><p><img src="https://s2.ax1x.com/2019/08/10/eXpr0e.png" alt="eXpr0e.png"></p><p>如果我们希望DSP工作在某一个频率下，我们就可以对Uint16 val, Uint16 divsel两个参数进行设定。说白了就相当于乘10，除2 (30*10/2 = 150MHZ)</p><hr><h2 id="GPIO引脚"><a href="#GPIO引脚" class="headerlink" title="GPIO引脚"></a>GPIO引脚</h2><p><strong>GPIO（General-Purpose Input/Output）——通用输入/输出口</strong></p><p>DSP28335 GPIO模块分为三类IO口：PORTA(0-31),PORTB(32-63),PORTC(64-87) 对GPIO模块的设置主要通过三类寄存器来完成，分别是：控制寄存器、数据寄存器、中断寄存器。</p><p><strong>1、控制寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  GPxCTRL;    <span class="comment">// GPIO x Control Register (GPIO0 to 31)</span></span><br><span class="line">              <span class="comment">//设置采样窗周期T=2*GPXCTRL*Tsysclk；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxQSEL1;   <span class="comment">// GPIO x Qualifier Select 1 Register (GPIO0 to 15)(32-47)            </span></span><br><span class="line">  GPxQSEL2;   <span class="comment">// GPIO x Qualifier Select 2 Register (GPIO16 to 31)(48-63)</span></span><br><span class="line">              <span class="comment">//每两位控制一个引脚，确定是3周期采样还是6周期采样或者不用采样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxMUX1;    <span class="comment">// GPIO x Mux 1 Register (GPIO0 to 15)(32-47)(64-79)</span></span><br><span class="line"></span><br><span class="line">  GPxMUX2;    <span class="comment">// GPIO x Mux 2 Register (GPIO16 to 31)(48-63)(80-95)</span></span><br><span class="line">              <span class="comment">//配置各个引脚的功能，0：I/O功能，1：外设功能。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxDIR;     <span class="comment">// GPIO x Direction Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">              <span class="comment">//配置每个引脚是输入还是输出，0：数字量输入；1：数字量输出。</span></span><br><span class="line">  GPxPUD;     <span class="comment">// GPIO x Pull Up Disable Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">              <span class="comment">//使能或禁止内部上拉 0：开启上拉，1：禁止上拉</span></span><br></pre></td></tr></table></figure><p><strong>2、数据寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  GPxDAT;     <span class="comment">// GPIO Data Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">  GPxSET;     <span class="comment">// GPIO Data Set Register (GPIO0 to 31)(32-63)(64-95)——置位</span></span><br><span class="line"></span><br><span class="line">  GPxCLEAR;   <span class="comment">// GPIO Data Clear Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line"></span><br><span class="line">  GPxTOGGLE;  <span class="comment">// GPIO Data Toggle Register (GPIO0 to 31)(32-63)(64-95)—反转</span></span><br></pre></td></tr></table></figure><p><strong>3、中断寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   GPIOXINT1SEL; <span class="comment">// XINT1 GPIO Input Selection</span></span><br><span class="line">   GPIOXINT2SEL; <span class="comment">// XINT2 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXNMISEL;  <span class="comment">// XNMI_Xint13 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT3SEL; <span class="comment">// XINT3 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT4SEL; <span class="comment">// XINT4 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT5SEL; <span class="comment">// XINT5 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT6SEL; <span class="comment">// XINT6 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT7SEL; <span class="comment">// XINT7 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOLPMSEL;   <span class="comment">// Low power modes GP I/O input select</span></span><br></pre></td></tr></table></figure><blockquote><p>可以对GPIO0-63进行外部中断设置；</p></blockquote><p>具体定义在DSP28335Gpio.h中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_CTRL_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPACTRL_REG  GPACTRL;   <span class="comment">// GPIO A Control Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA1_REG     GPAQSEL1;  <span class="comment">// GPIO A Qualifier Select 1 Register (GPIO0 to 15)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA2_REG     GPAQSEL2;  <span class="comment">// GPIO A Qualifier Select 2 Register (GPIO16 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA1_REG     GPAMUX1;   <span class="comment">// GPIO A Mux 1 Register (GPIO0 to 15)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA2_REG     GPAMUX2;   <span class="comment">// GPIO A Mux 2 Register (GPIO16 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG   GPADIR;    <span class="comment">// GPIO A Direction Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG   GPAPUD;    <span class="comment">// GPIO A Pull Up Disable Register (GPIO0 to 31)</span></span><br><span class="line">   Uint32              rsvd1;</span><br><span class="line">   <span class="keyword">union</span>  GPBCTRL_REG  GPBCTRL;   <span class="comment">// GPIO B Control Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB1_REG     GPBQSEL1;  <span class="comment">// GPIO B Qualifier Select 1 Register (GPIO32 to 47)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB2_REG     GPBQSEL2;  <span class="comment">// GPIO B Qualifier Select 2 Register (GPIO48 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB1_REG     GPBMUX1;   <span class="comment">// GPIO B Mux 1 Register (GPIO32 to 47)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB2_REG     GPBMUX2;   <span class="comment">// GPIO B Mux 2 Register (GPIO48 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG   GPBDIR;    <span class="comment">// GPIO B Direction Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG   GPBPUD;    <span class="comment">// GPIO B Pull Up Disable Register (GPIO32 to 63)</span></span><br><span class="line">   Uint16              rsvd2[<span class="number">8</span>];</span><br><span class="line">   <span class="keyword">union</span>  GPC1_REG     GPCMUX1;   <span class="comment">// GPIO C Mux 1 Register (GPIO64 to 79)</span></span><br><span class="line">   <span class="keyword">union</span>  GPC2_REG     GPCMUX2;   <span class="comment">// GPIO C Mux 2 Register (GPIO80 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG   GPCDIR;    <span class="comment">// GPIO C Direction Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG   GPCPUD;    <span class="comment">// GPIO C Pull Up Disable Register (GPIO64 to 95)</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_DATA_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPADAT;       <span class="comment">// GPIO Data Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPASET;       <span class="comment">// GPIO Data Set Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPACLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPATOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO0 to 31) </span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBDAT;       <span class="comment">// GPIO Data Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBSET;       <span class="comment">// GPIO Data Set Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBCLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBTOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCDAT;       <span class="comment">// GPIO Data Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCSET;       <span class="comment">// GPIO Data Set Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCCLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCTOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO64 to 95)</span></span><br><span class="line">   Uint16                  rsvd1[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_INT_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT1SEL; <span class="comment">// XINT1 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT2SEL; <span class="comment">// XINT2 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXNMISEL;  <span class="comment">// XNMI_Xint13 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT3SEL; <span class="comment">// XINT3 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT4SEL; <span class="comment">// XINT4 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT5SEL; <span class="comment">// XINT5 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT6SEL; <span class="comment">// XINT6 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT7SEL; <span class="comment">// XINT7 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPIOLPMSEL;   <span class="comment">// Low power modes GP I/O input select</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：GPIO相关寄存器介绍</strong></p><blockquote><p>1、GPxMUX寄存器（功能选择寄存器）</p><p>每个I/O口都有一个功能选择寄存器，功能选择寄存器主要用于选择I/O工作在特殊功能还是通用数组I/O模式。在复位时，所有GPIO配置成通用数字模式。</p><p>1）如果GPxMUX.bit = 0，配置成通用数字I/O功能；</p><p>2）如果GPxMUX.bit = 1，配置成特殊外设功能口（如SCI、CAN）；</p><p>I/O的输入功能和外设的输入通道总是被使能的，输出通道是通用数组I/O和特殊外设复用的。如果引脚配置成通用数组I/O功能，相应的外设功能将被禁止。</p><p>2、GPxDIR（方向控制寄存器）</p><p>每个I/O口都有数据方向控制寄存器，数据方向控制寄存器用于设置通用数字I/O为输入还是输出口，在复位时，引脚的默认状态为输入状态。</p><p>1）如果GPxDIR.bit = 0，引脚设置为通用数字量输入；</p><p>2）如果GPxDIR.bit = 1，引脚设置为通用数字量输出；</p><p>复位时，GPxMUX和GPxDIR默认值都为0，所以在复位时，引脚的默认状态为数字I/O输入。</p><p>3、GPxDAT寄存器（数据寄存器）</p><p>每个I/O口都有一个数据寄存器，数据寄存器是可读可写寄存器。</p><p>1）I/O设置为输出功能时，如果GPxDAT.bit = 0，那么操作将会使相应的引脚拉低；</p><p>2）I/O口设置为输入功能时，如果GPxDAT.bit = 0，反映相应的引脚状态为低电平；</p><p>3）I/O口设置为输出功能时，如果GPxDAT.bit = 1，那么操作将会使相应的引脚拉高；</p><p>4）I/O口设置为输入功能时，如果GPxDAT.bit = 1，反映相应的引脚状态为高电平。</p><p>需要说明的是，当用户试图改变一个数字I/O的状态时，不要改变另一个I/O的引脚状态。</p><p>4、GOxSET寄存器（置位寄存器）</p><p>每个I/O口都有一个置位寄存器，置位寄存器是只写寄存器，任何读操作都返回0，如果相应的引脚配置成数据量输出，写1后相应的引脚会置高，写0时没有反映。</p><p> 1）如果GPxSET.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxSET.bit = 1，那么操作将会使引脚置高。</p><p>5、GPxCLEAR寄存器（清除寄存器）</p><p>每个I/O口都有一个清除寄存器，清除寄存器是只写寄存器，任何读操作都返回0。</p><p>1）如果GPxCLEAR.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxCLEAR.bit = 1，将相应的引脚置成低电平。</p><p>6、GPxTOGGLE寄存器（取反触发寄存器）</p><p>每个I/O口都有一个取反触发寄存器，该寄存器是只写寄存器，任何读操作都返回0。</p><p>1）如果GPxTOGGLE.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxTOGGLE.bit = 1，那么操作将使相应的引脚取反。</p></blockquote><hr><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>1.中断系统</strong></p><p>   在这里我们要十分清楚DSP的中断系统。C28XX一共有16个中断源，其中有2个不可屏蔽的中断RESET和NMI、定时器1和定时器2分别使用中断13和14。这样还有12个中断都直接连接到外设中断扩展模块PIE上。说的简单一点就是PIE通过12根线与28335核的12个中断线相连。而PIE的另外一侧有12*8根线分别连接到外设，如AD、SPI、EXINT等等。</p><p>   PIE共管理12*8=96个外部中断。这12组大中断由28335核的中断寄存器IER来控制，即IER确定每个中断到底属于哪一组大中断（如IER |= M_INT12; 说明我们要用第12组的中断，但是第12组里面的什么中断CPU并不知道需要再由PIEIER确定）。</p><p>   接下来再由PIE模块中的寄存器PIEIER中的低8确定该中断是这一组的第几个中断，这些配置都要告诉CPU（我们不难想象到PIEIER共有12总即从PIEIER1-PIEIER12）。另外，PIE模块还有中断标志寄存器PIEIFR，同样它的低8位是来自外部中断的8个标志位，同样CPU的IFR寄存器是中断组的标志寄存器。由此看来，CPU的所有中断寄存器控制12组的中断，PIE的所有中断寄存器控制每组内8个的中断。除此之外，我们用到哪一个外部中断，相应的还有外部中断的寄存器，需要注意的就是<strong>外部中断的标志要自己通过软件来清零</strong>。而<strong>PIE和CPU的中断标志寄存器由硬件来清零。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EALLOW;  <span class="comment">// This is needed to write to EALLOW protected registers </span></span><br><span class="line">PieVectTable.XINT2 = &amp;ISRExint;          <span class="comment">//告诉中断入口地址</span></span><br><span class="line">EDIS;    <span class="comment">// This is needed to disable write to EALLOW protected registers</span></span><br><span class="line">PieCtrlRegs.PIECTRL.bit.ENPIE = <span class="number">1</span>;       <span class="comment">// Enable the PIE block使能PIE</span></span><br><span class="line">PieCtrlRegs.PIEIER1.bit.INTx5= <span class="number">1</span>;        <span class="comment">//使能第一组中的中断5</span></span><br><span class="line">IER |= M_INT1;                           <span class="comment">// Enable CPU 第一组中断</span></span><br><span class="line">EINT;                                    <span class="comment">// Enable Global interrupt INTM</span></span><br><span class="line">ERTM;                                    <span class="comment">// Enable Global realtime interrupt DBGM</span></span><br></pre></td></tr></table></figure><p>也就是说，12组中的每个中断都要完成上面的相同配置，剩下的才是去配置自己的中断。如我们提到的EXINT，即外面来个低电平我们就进入中断，完成我们的程序。在这里要介绍一下，DSP的GPIO口都可以配置为外部中断口，其配置方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO54 = <span class="number">0</span>; <span class="comment">//选择他们是GPIO口</span></span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO55 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO56 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO57 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO54 = <span class="number">0</span>;<span class="comment">//选择他们都是输入口</span></span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO55 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO56 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO57 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO54= <span class="number">0</span>;<span class="comment">//使GPIO时钟和系统时钟一样 且支持GPIO</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO55= <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO56= <span class="number">0</span>;<span class="comment">//配置输入口权限，对于选择为输入口的需配置GPACTRL,GPBCTRL,GPAQSEL1</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO57= <span class="number">0</span>;<span class="comment">//GPAQSEL2, GPBQSEL1, and GPBQSEL2寄存器所有输入信号与CPU输出系统时钟同步；</span></span><br><span class="line"> </span><br><span class="line">GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = <span class="number">54</span>;<span class="comment">//中断3选择GPIO</span></span><br><span class="line">GpioIntRegs.GPIOXINT4SEL.bit.GPIOSEL = <span class="number">55</span>;</span><br><span class="line">GpioIntRegs.GPIOXINT5SEL.bit.GPIOSEL = <span class="number">56</span>;</span><br><span class="line">GpioIntRegs.GPIOXINT6SEL.bit.GPIOSEL = <span class="number">57</span>; </span><br><span class="line"> </span><br><span class="line">XIntruptRegs.XINT3CR.bit.POLARITY= <span class="number">0</span>;<span class="comment">//触发模式为下降沿触发</span></span><br><span class="line">XIntruptRegs.XINT4CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line">XIntruptRegs.XINT5CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line">XIntruptRegs.XINT6CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">XIntruptRegs.XINT3CR.bit.ENABLE = <span class="number">1</span>;<span class="comment">//使能中断</span></span><br><span class="line">XIntruptRegs.XINT4CR.bit.ENABLE = <span class="number">1</span>;</span><br><span class="line">XIntruptRegs.XINT5CR.bit.ENABLE = <span class="number">1</span>;</span><br><span class="line">XIntruptRegs.XINT6CR.bit.ENABLE = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意一点就是外部中断1和2只能对GPIO0—GPIO31配置；外部中断3和4、5、6、7只对GPIO32—GPIO63配置。</p><p>GPIO分为A(0-31)、B(32-63)、C(64-87);C组的不能配置为外部中断；</p><p><strong>2.如何开启某个中断？</strong></p><p>设置中断向量。例如：<code>PieVectTable.ADCINT = &amp;adc_isr;</code>等<br>打开PIE控制器。<code>PieCtrlRegs.PIECTRL.bit.ENPIE = 1;</code><br>使能PIE中对应外设的中断（相应group的相应pin）。例如：<code>PieCtrlRegs.PIEIER1.bit.INTx8 = 1; PieCtrlRegs.PIEIER1.bit.INTx6 = 1;</code>等<br>使能CPU的相应中断<code>（INT1~INT12）IER |= M_INT1;</code><br>使能CPU响应中断EINT、ERTM;;</p><p><strong>3.中断标志有几级？作用是什么？</strong></p><p>中断标志主要有三级CPU（有16个标志位）、PIE（有12组每组有12个标志位）和外设（有的外设没有）。</p><p>标志位在中断发生后锁存中断状态，即表示中断发生。在CPU响应中断后，会自动清除cpu级别的标志位IFR bit，同时将INTM bit 置位，以防止其它中断的发生；</p><p>CPU在从PIE中取中断向量时PIE会自动清除PIE级别的标志位PIEIFRx.y。所以在进入中断处理程序后除了外设所有中断位都已经清除。</p><p>而中断处理程序中需要清除PIEACKx和外设的中断标志位（如果有的话）。</p><p>在CPU响应一个中断后，在进入ISR的时候，默认会关断全局中断，即在执行中断服务程序时，不会有其他中断来打断CPU，包括本次的中断事件。另外，如果外设的中断标志位不清除，不会循环进入这个中断服务函数，这个外设中断被阻断了。所以只有清除外设的中断服务程序，才能响应下一次的外设中断。PIEACK同理，如果没有PIEACK，这组所有中断都被阻断。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://www.ti.com/lit/ds/symlink/tms320f28335.pdf" target="_blank" rel="noopener">TMS320F2833x Datasheet</a></p><p>[2] <a href="https://blog.csdn.net/scottly1" target="_blank" rel="noopener">风雨也无晴 CSDN</a></p><p>[3] <a href="http://blog.sina.com.cn/s/blog_a7c071b30102wp2c.html" target="_blank" rel="noopener">GPIO blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP28335 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP 串口接口及通信通信</title>
      <link href="/2019/08/09/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/08/09/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="对串口通信进行简单知识点梳理"><a href="#对串口通信进行简单知识点梳理" class="headerlink" title="对串口通信进行简单知识点梳理"></a>对串口通信进行简单知识点梳理</h2><p>串行通信可以分为两大类：</p><p>同步通信：典型 I2C,SPI</p><p>异步通信：典型 SCI(serial communication interface,串行通信接口)</p><blockquote><p>进行串口异步通信接口，一般可以看作UART口(Universal Asynchronous Receiver Transmitter：通用异步收发器/异步串行通信口)</p></blockquote><blockquote><p>UART、COM指物理接口形式(硬件), TTL、RS232、RS485 指电平标准(电信号)</p></blockquote><hr><h2 id="SCI-串口"><a href="#SCI-串口" class="headerlink" title="SCI 串口"></a>SCI 串口</h2><p>先来补充一个概念:FIFO（First Input First Output），即先进先出队列。</p><h3 id="SCI模块介绍"><a href="#SCI模块介绍" class="headerlink" title="SCI模块介绍"></a>SCI模块介绍</h3><p>TMS320F28335内部有三个SCI模块，SCIA、SCIB、SCIC。</p><p>每一个SCI模块都有一个接收器和发送器，SCI的接收器和发送器各有一个16级的FIFO(First In First Out先入先出)队列，它们都还有自己独立的使能位和中断位；可以工作在半双工或全双工模式。</p><p><strong>1. SCI的CPU 接口</strong><br>SCI 模块具有两个引脚， SCITXDA 和 SCIRXDA，分别实现发送数据和接收数据的功能，这两个引脚对应于 GPIOF 模块的第4和第5位，在编程初始化的时候，需要将GPIOFMUX 寄存器的第4和第5位置为1，才能使得这两个引脚具有发送和接收的功能，否则就是普通的I/O引脚。外部晶振通 PLL 模块产生了CPU 的系统时钟SYSCLKOUT，然后SYSCLKOUT经过低速预定标器之后输出低速时钟LSPCLK 供给SCI。要保证SCI的正常运行，系统控制模块下必须使能SCI的时钟，也就是在系统初始化函数中需要将外设时钟控制寄存器PCLKCR的SCIAENCLK位置1。从下图，我们可以清楚的看到SCIA可以产生两个中断，SCIRXINTA 和SCITXINTA，即发送中断和接收中断。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOLCtK.png" alt="eOLCtK.png"></p><p><strong>2. SCI相关寄存器</strong></p><p>SCICR：SCI通信参数设置寄存器，设置数据位，停止位，奇偶校验位。</p><p>SCICTL1：使能SCI的发送接收功能 <strong>注：SW RESET需置1</strong></p><p>SCILBAUD、SCIHBAUD：通信速率（波特率）的设置。</p><p>SCICTL2：使能接收发送中断，以及发送中断标志位。</p><p>SCIRXST：接收相关标志位。</p><p>SCIRXBUF：8位发送缓存寄存器</p><p>SCITXBUF：8位接收缓存寄存器。</p><p>SCI中断配置：</p><p>SCI的中断采用三级中断管理。分别是SCI外设中断，PIE中断，CPU中断。SCIA的PIE中断是第九组，分别是INT９.１和INT９.２.PIE中断的配置在前面已经说过了，此处不多说。<strong>注意：在中断不要忘记将PIEACK写１清除。</strong></p><p>SCI的FIFO模式：</p><p>FIFO：先入先出队列。SCI采用这种模式时，接收或者发送完指定字节数量的数据后，才进入中断处理。这样可以节省了CPU的使用效率，CPU不用每次接收完一个字节的数据后就进入中断处理。</p><p>相关寄存器：</p><p>SCIFFTX：配置发送的数据量，使能SCI的FIFO模式，使能中断等</p><p>SCIFFRX：配置接收的数据量，使能接收中断等。</p><p>在学习FIFO模式时，遇到一个问题，就是接收完指定数量字节的数据后，总是重复进入两次发送中断，一次找不到原因。下面贴出代码，希望各位读者不吝赐教。</p><p><strong>3. SCI 模块发送和接收数据的工作原理</strong></p><p>SCI 模块的工作原理如下图所示，之所以SCI 能工作于全双工模式，是因为它有独立的数据发送器和数据接收器，这样能够保证SCI既能够同时进行，也能够独立进行发送和接收的操作。</p><p>SCI 发送数据的过程如下：如下图右半部分所示， 在FIFO功能使能的情况下， 首先，发送数据缓冲寄存器SCITXBUF从TX FIFO 中获取由 CPU 加载的需要发送的数据，然后 SCITXBUF将数据传输给发送移位寄存器TXSHF， 如果SCI的发送功能使能， TXSHF 则将接收到的数据逐位逐位的移到 SCITXD 引脚上。</p><p>SCI接收数据的过程如下：如X下图的左半部分所示，首先，接收移位寄存器 RXSHF 逐位逐位的接收来自于 SCIRXD 引脚的数据， 如果 SCI 的接收功能使能， RXSHF 将这些数据传输给接收缓冲寄存器 SCIRXBUF，CPU 就能从 SCIRXBUF 读取外部发送来的数据。当然，如果 FIFO 功能使能的话， SCIRXBUF 会将数据加载到RX FIFO 的队列中， CPU 再从FIFO 的队列读取数据。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOL09U.png" alt="eOL09U.png"></p><p><strong>4. SCI数据格式</strong></p><p>在 SCI 中，通信协议体现在 SCI 的数据格式上。 通常将 SCI 的数据格式称之为可编程的数据格式，原因就是可以通过 SCI 的通信控制寄存器 SCICCR 来进行设置，规定通信过程中所使用的数据格式。 </p><p>在<strong>空闲线模式</strong>下， SCI 发送或者接收一帧的数据格式如图 4 所示，其中 LSB 是数据的最低位， MSB 是数据的最高位。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOOCbn.png" alt="eOOCbn.png"></p><blockquote><p>使用 SCICCR 进行数据格式编程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SciaRegs.SCICCR.bit.SCICHAR=<span class="number">8</span>;</span><br><span class="line"><span class="comment">//选择数据长度，为 8 个数据位</span></span><br><span class="line">SciaRegs.SCICCR.bit.PARITYENA=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//开启极性功能，值为 0 的时候取消极性功能</span></span><br><span class="line">SciaRegs.SCICCR.bit.PARITY=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//在开启极性功能的前提下，该位值为 0 时选择偶极性，值为 1 时选择奇极性</span></span><br><span class="line">SciaRegs.SCICCR.bit.STOPBITS=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//选择停止位，该位为 0 时有 1 个停止位，该位为 1 时有 2 个停止位</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，上述这几个语句，我们也可以合并成如下的语句：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SciaRegs.SCICCR.all=<span class="number">0x13</span>;</span><br></pre></td></tr></table></figure><p><strong>5. SCI通信波特率</strong></p><p>所谓的波特率就是指每秒所能发送的位数。<br>SCI波特率设置寄存器SCIHBAUD和SCILBAUD，0-15是高字节与低字节连在一起，构成16位波特率设置寄存器BRR。BRR = SCIHBAUD + SCILBAUD</p><p>如果1&lt;= BRR &lt;=65535，那么SCI波特率=LSPCLK / ( (BRR+1) * 8 )，由此，可以带入你需要的波特率，既可以得到BRR的值；<br>如果BRR = 0，那么SCI波特率=LSPCLK/ 16</p><p> 我们举例来进行说明。例如外部晶振位 30M，经过 PLL 之后 SYSCLKOUT 为 150MHz，然后，当低速预定标器 LOSPCP 的值为 2 的时候， SYSCLKOUT 经过低速预定标器之后产生&gt;低速外设时钟 LSPCLK 为 37.5MHz，也就是说 SCI 的时钟为 37.5MHz。如果我们需要 SCI 的波特率为 19200，则将 LSPCLK 和波特率的数值代入式 1，便可得到BRR=243.14，由于寄存器都是正整数，所以省略掉小数后可以得到 BRR=243。将 243 转换成 16 进制是 0xF3，因此 SCIHBAUD 的值为 0， SCIHBAUD 的值为 0XF3。由于省略了小数，将会产生 0.06%的误差。 当 LSPCLK 为 37.5M 时，对于 SCI 常见的波特率，其寄存器的值如下表所示：</p><p><img src="https://s2.ax1x.com/2019/08/10/eOXO1S.png" alt="eOXO1S.png"></p><p><strong>6. 串口SCI编程</strong></p><p><strong>A.</strong></p><blockquote><p>先初始化IO管脚 (以SCI-A为例，SCI-B、SCI-C的初始化方法一样，就是照着改对应的管脚就行)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSciaGpio</span><span class="params">()</span> <span class="comment">//初始化SCIA的GPIO管脚为例子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EALLOW;</span><br><span class="line"><span class="comment">//根据硬件设计决定采用GPIO28/29和GPIO35/36中的哪一组。这里以35/36为例</span></span><br><span class="line"><span class="comment">//定义管脚为上拉</span></span><br><span class="line">GpioCtrlRegs.GPBPUD.bit.GPIO36 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBPUD.bit.GPIO35 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义管脚为异步输入</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL1.bit.GPIO36 = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//配置管脚为SCI功能管脚</span></span><br><span class="line">GpioCtrlRegs.GPBMUX1.bit.GPIO36 = <span class="number">1</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX1.bit.GPIO35 = <span class="number">1</span>;</span><br><span class="line">EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B.</strong></p><blockquote><p>SCI初始化配置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scia_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SciaRegs.SCICCR.all =<span class="number">0x0007</span>; <span class="comment">// 1 stop bit, No loopback</span></span><br><span class="line"><span class="comment">// No parity,8 char bits,</span></span><br><span class="line"><span class="comment">// async mode, idle-line protocol</span></span><br><span class="line">SciaRegs.SCICTL1.all =<span class="number">0x0003</span>; <span class="comment">// enable TX, RX, internal SCICLK,</span></span><br><span class="line"><span class="comment">// Disable RX ERR, SLEEP, TXWAKE</span></span><br><span class="line">SciaRegs.SCICTL2.bit.TXINTENA =<span class="number">1</span>; <span class="comment">//发送中断使能</span></span><br><span class="line">SciaRegs.SCICTL2.bit.RXBKINTENA =<span class="number">1</span>;<span class="comment">//接收中断使能</span></span><br><span class="line">SciaRegs.SCIHBAUD =<span class="number">0x0001</span>; <span class="comment">// 9600 baud @LSPCLK = 37.5MHz.</span></span><br><span class="line">SciaRegs.SCILBAUD =<span class="number">0x00E7</span>;</span><br><span class="line">SciaRegs.SCICTL1.all =<span class="number">0x0023</span>; <span class="comment">// Relinquish SCI from Reset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C.</strong></p><blockquote><p>接着进行中断的配置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EALLOW; <span class="comment">// This is needed to write to EALLOW protected registers</span></span><br><span class="line">PieVectTable.SCIRXINTA = &amp;sciaRxIsr;</span><br><span class="line">PieVectTable.SCITXINTA = &amp;sciaTxIsr;</span><br><span class="line">PieVectTable.SCIRXINTB = &amp;scibRxIsr;</span><br><span class="line">PieVectTable.SCITXINTB = &amp;scibTxIsr;</span><br><span class="line">EDIS; <span class="comment">// This is needed to disable write to EALLOW protected registers</span></span><br></pre></td></tr></table></figure><p><strong>D.</strong></p><blockquote><p>上面是将SCIA和SCIB的中断服务程序连到PIE的中断表中，发生中断就会跑到你的ISR去了，下面是开中断：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PieCtrlRegs.PIECTRL.bit.ENPIE = <span class="number">1</span>; <span class="comment">// Enable the PIE block</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx1=<span class="number">1</span>; <span class="comment">// PIE Group 9, int1</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx2=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT2</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx3=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT3</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx4=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT4</span></span><br><span class="line">IER = <span class="number">0x100</span>; <span class="comment">// Enable CPU INT</span></span><br><span class="line">EINT;</span><br></pre></td></tr></table></figure><p>这样串口基本就OK了。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/forever5325/p/9590141.html" target="_blank" rel="noopener">接口及协议总结</a><br>[2] <a href="https://blog.csdn.net/LSG_Down/article/details/80898638" target="_blank" rel="noopener">SCI通信</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 上位机 </tag>
            
            <tag> 串口通信 </tag>
            
            <tag> DSP28335 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP电机平台上位机编写(Python+pyqt)</title>
      <link href="/2019/08/06/DSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
      <url>/2019/08/06/DSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><strong>准备给DSP电机平台增加一个电机转速调节的上位机。</strong></p><blockquote><p><strong>目的：</strong></p><p>1.学习python，并利用它做点东西</p><p>2.对串口通信有更加深刻的了解</p></blockquote><blockquote><p><strong>计划步骤：</strong></p><p>1.先把Python的基础知识有大体了解</p><p>2.学习pyqt并绘制上位机界面</p><p>3.做好串口通信的工作</p></blockquote><h1 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h1><p>环境搭建参考： <a href="http://www.roselady.vip/a/cangjingge/boke/2018/0227/691.html" target="_blank" rel="noopener">环境搭建</a></p><p>再由.ui转成.py时，再最后添加：<a href="https://jingyan.baidu.com/article/656db918264acbe380249c50.html" target="_blank" rel="noopener">参考</a></p><p>Ui_MainWindow 要和前面类名一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span><span class="params">(QtWidgets.QMainWindow, Ui_MainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyWindow, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    mywindow = MyWindow()</span><br><span class="line">    mywindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h1 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h1><hr><p>未完待续~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> 上位机 </tag>
            
            <tag> Python </tag>
            
            <tag> pyqt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业岗位要求</title>
      <link href="/2019/08/06/%E4%BC%81%E4%B8%9A%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/"/>
      <url>/2019/08/06/%E4%BC%81%E4%B8%9A%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="几家企业的岗位要求，激励自己不断前进！"><a href="#几家企业的岗位要求，激励自己不断前进！" class="headerlink" title="几家企业的岗位要求，激励自己不断前进！"></a>几家企业的岗位要求，激励自己不断前进！</h1><p><img src="https://s2.ax1x.com/2019/08/06/ehuVgO.png" alt="ehuVgO.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/ehuZvD.png" alt="ehuZvD.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/ehumKe.png" alt="ehumKe.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/ehuAC6.png" alt="ehuAC6.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/ehuE8K.png" alt="ehuE8K.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 岗位要求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性负载</title>
      <link href="/2019/08/05/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD/"/>
      <url>/2019/08/05/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="中心刚体-悬臂梁系统-欧拉-伯努利梁-5"><a href="#中心刚体-悬臂梁系统-欧拉-伯努利梁-5" class="headerlink" title="中心刚体-悬臂梁系统 (欧拉-伯努利梁)[5]"></a>中心刚体-悬臂梁系统 (欧拉-伯努利梁)[5]</h2><p>如工业机器人中的柔性机械臂等。单柔性连杆伺服驱动系统如图所示。图中：u(x,t)为挠性负载在x处的挠度；θm(t)为伺服电机转轴的转角；Ta为伺服电机驱动转矩。</p><p><img src="https://s2.ax1x.com/2019/08/05/eRZ4G4.png" alt="eRZ4G4.png"></p><p>单柔性连杆伺服电机驱动系统动力学方程(ξ为各阶振动模态阻尼系数矩阵):</p><p><img src="https://s2.ax1x.com/2019/08/05/eRulwt.png" alt="eRulwt.png"></p><p>简化后的挠性连杆伺服系统状态方程:</p><p><img src="https://s2.ax1x.com/2019/08/05/eRuwmn.png" alt="eRuwmn.png"></p><p>该系统的传递函数如下:</p><p><img src="https://s2.ax1x.com/2019/08/05/eRuIk6.png" alt="eRuIk6.png"></p><hr><h2 id="PMSM直接驱动柔性负载-2"><a href="#PMSM直接驱动柔性负载-2" class="headerlink" title="PMSM直接驱动柔性负载[2]"></a>PMSM直接驱动柔性负载[2]</h2><p>PMSM直接驱动柔性负载 状态方程 转速环和电流环 开环传递函数 为：</p><p><img src="https://s2.ax1x.com/2019/08/06/eh7eSg.png" alt="eh7eSg.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/eh7EY8.png" alt="eh7EY8.png"></p><p><img src="https://s2.ax1x.com/2019/08/06/eh7VfS.png" alt="eh7VfS.png"></p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]丁有爽,肖曦.基于负载位置反馈的永磁同步电机驱动柔性负载谐振抑制方法[J].电工技术学报,2017,32(11):96-110.</p><p>[2]丁有爽,肖曦.永磁同步电机直接驱动柔性负载控制方法[J].电工技术学报,2017,32(04):123-132.</p><p>[3]丁有爽,肖曦.基于极点配置的永磁同步电机驱动柔性负载PI调节器参数确定方法[J].中国电机工程学报,2017,37(04):1225-1239.</p><p>[4]丁有爽,肖曦.基于状态反馈和转矩补偿的永磁同步电机驱动柔性负载控制方法[J].中国电机工程学报,2017,37(13):3892-3900.</p><p>[5]丁有爽,肖曦.伺服系统柔性负载建模方法研究[J].中国电机工程学报,2016,36(03):818-827.</p>]]></content>
      
      
      
        <tags>
            
            <tag> PMSM </tag>
            
            <tag> 柔性负载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于DSP平台双UDE 参数调试</title>
      <link href="/2019/08/02/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95/"/>
      <url>/2019/08/02/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>1.挑选了几组典型数据画图，这里面的滤波器参数都是随意设置的（因为现在还无法确定kp和alpha之间的关系）</strong></p></li><li><p><strong>2.xx_xxx3.fig 中红色为实际数值 蓝色为指令，绿色为经过滤波器的输出结果(画图程序在最后)。</strong></p></li></ul><ul><li><p><strong>3.图中的时间 10000点 = 5s</strong></p></li><li><p><strong>4.Main_twoloop190801.c为源程序。</strong></p></li><li><p><strong>5.文件夹中</strong></p><p>  01-07为电流环调试过程,<br>  08-11为速度环调试过程,<br>  12 给了一个比较极端的速度环滤波器参数。</p></li></ul><blockquote><p>数据对应参数：</p></blockquote><table><thead><tr><th align="center"></th><th align="center">spd_Factor</th><th align="center">spd_kp</th><th align="center">spd_ki</th><th align="center">iq_Factor</th><th align="center">iq_kp</th><th align="center">iq_ki</th></tr></thead><tbody><tr><td align="center">01参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">1.0</td><td align="center">0.0025</td></tr><tr><td align="center">05参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.1</td><td align="center">0.0025</td></tr><tr><td align="center">06参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr><tr><td align="center">10参数</td><td align="center">0.1667</td><td align="center">3.0</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr><tr><td align="center">12参数</td><td align="center">0.0007</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr></tbody></table><ul><li><p><strong>6.画图函数</strong></p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,spd,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,spdr<span class="number">-5</span>,<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,spdc<span class="number">-5</span>,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line">grid on</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,iq,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,iqr,<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,iqc,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> PMSM </tag>
            
            <tag> UDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于加入站内搜索</title>
      <link href="/2019/08/02/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/2019/08/02/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>今天按照网上的加入本站搜索功能 无论如何都加不进去，后来在查看 NEXT给的官方解读中看到解决方法<br>网址如下，查看Local Search方法</p><blockquote><p><a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/search-services</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不懂的知识点 查阅 汇总</title>
      <link href="/2019/08/01/%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/08/01/%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="单工、半双工和全双工的区别"><a href="#单工、半双工和全双工的区别" class="headerlink" title="单工、半双工和全双工的区别"></a>单工、半双工和全双工的区别</h2><ul><li>一、单工<br>1、数据只在一个方向上传输，不能实现双方通信。</li></ul><p>2、栗子：电视、广播。</p><ul><li>二、半双工<br>1、允许数据在两个方向上传输，但是同一时间数据只能在一个方向上传输，其实际上是切换的单工。</li></ul><p>2、栗子：对讲机。</p><ul><li>三、全双工<br>1、允许数据在两个方向上同时传输。</li></ul><p>2、栗子：手机通话。</p><hr><h2 id="TCP-IP-（传输控制协议）Transmission-Control-Protocol"><a href="#TCP-IP-（传输控制协议）Transmission-Control-Protocol" class="headerlink" title="TCP/IP （传输控制协议）Transmission Control Protocol"></a>TCP/IP （传输控制协议）Transmission Control Protocol</h2><ul><li><p>TCP 用于应用程序之间的通信。<br>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p></li><li><p>IP 用于计算机之间的通信。<br>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p></li><li><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。<br>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。<br>IP 负责计算机之间的通信。<br>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。<br>IP 负责将包发送至接受者。</p></li></ul><hr><h2 id="api-（应用程序编程接口）"><a href="#api-（应用程序编程接口）" class="headerlink" title="api （应用程序编程接口）"></a>api （应用程序编程接口）</h2><p>API 是一套明确定义的各种软件组件之间的通信方法。</p><hr><h3 id="http、MQTT、CoAP"><a href="#http、MQTT、CoAP" class="headerlink" title="http、MQTT、CoAP"></a>http、MQTT、CoAP</h3><p>HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。<strong>支持长连接！适用于抄表</strong></p><blockquote><p><img src="https://s2.ax1x.com/2019/08/03/eDkio6.png" alt="eDkio6.png"></p></blockquote><p>CoAP 由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。 IETF的CoRE工作组提出了一种基于REST架构的CoAP协议;是一种在物联网世界的类web协议。<strong>不支持长连接 基于UDO 可靠性不高 适用于智能家居</strong></p><p><img src="https://s2.ax1x.com/2019/08/03/eDk8fS.png" alt="eDk8fS.png"></p><hr><h2 id="OSI七层模型-TCP-IP五层模型："><a href="#OSI七层模型-TCP-IP五层模型：" class="headerlink" title="OSI七层模型/TCP/IP五层模型："></a>OSI七层模型/TCP/IP五层模型：</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>(整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。)</p><ul><li>&lt;1&gt;    应用层</li></ul><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p><blockquote><p>实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询&gt; 价单，等等。</p></blockquote><ul><li>&lt;2&gt;表示层</li></ul><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><blockquote><p>由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p></blockquote><ul><li>&lt;3&gt;会话</li></ul><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><blockquote><p>会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p></blockquote><ul><li>&lt;4&gt;传输层</li></ul><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的， <strong>TCP UDP</strong> 就是在这一层。端口号既是这里的“端”。</p><blockquote><p>传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p></blockquote><ul><li>&lt;5&gt;网络层</li></ul><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p><blockquote><p>网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p></blockquote><ul><li>&lt;6&gt;数据链路层 </li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p><blockquote><p>这个没找到合适的例子</p></blockquote><ul><li>&lt;7&gt; 物理层  </li></ul><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><blockquote><p>快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p></blockquote><p>[<img src="https://s2.ax1x.com/2019/08/02/e0sspV.png" alt="e0sspV.png"></p><hr><h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><p> TCP/IP五层协议和OSI的七层协议对应关系如下。 在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。<br><img src="https://s2.ax1x.com/2019/08/02/e0sHXD.png" alt="e0sHXD.png"><br> 在每一层实现的协议也各不同，即每一层的服务也不同。下图列出了每层主要的协议。<br><img src="https://s2.ax1x.com/2019/08/02/e0sqne.png" alt="e0sqne.png"></p><hr><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p>  鉴权（authentication）是指验证用户是否拥有访问系统的权利。</p><hr><h2 id="CIG、IOCM、DM-Server、Mongo-DB"><a href="#CIG、IOCM、DM-Server、Mongo-DB" class="headerlink" title="CIG、IOCM、DM Server、Mongo DB"></a>CIG、IOCM、DM Server、Mongo DB</h2><p>CIG (Cell Interconnection Gateway) 信元互连网关</p><hr><h2 id="color-red-未完待续"><a href="#color-red-未完待续" class="headerlink" title="$\color{red}{未完待续~~}$"></a><strong>$\color{red}{未完待续~~}$</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交流电机前言讲座考试总结</title>
      <link href="/2019/07/29/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/29/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>简单的做一下知识点梳理。</p><h1 id="电机的控制问题"><a href="#电机的控制问题" class="headerlink" title="电机的控制问题"></a>电机的控制问题</h1><p><img src="https://s2.ax1x.com/2019/07/27/eMwp1H.png" alt="eMwp1H.png"></p><h1 id="交流电机"><a href="#交流电机" class="headerlink" title="交流电机"></a>交流电机</h1><p><img src="https://s2.ax1x.com/2019/07/27/eMdBtS.png" alt="eMdBtS.png"></p><h1 id="同步电机"><a href="#同步电机" class="headerlink" title="同步电机"></a>同步电机</h1><p><a href="https://imgchr.com/i/e881Jg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/29/e881Jg.png" alt="e881Jg.png"></a></p><h1 id="附赠：电机的应用"><a href="#附赠：电机的应用" class="headerlink" title="附赠：电机的应用"></a>附赠：电机的应用</h1><p><img src="https://s2.ax1x.com/2019/07/28/e1kE8g.jpg" alt="e1kE8g.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kmKs.jpg" alt="e1kmKs.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kV2Q.jpg" alt="e1kV2Q.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1knrn.jpg" alt="e1knrn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kZvj.jpg" alt="e1kZvj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kubq.jpg" alt="e1kubq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kMV0.jpg" alt="e1kMV0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kQaV.jpg" alt="e1kQaV.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kl5T.jpg" alt="e1kl5T.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k3PU.jpg" alt="e1k3PU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k8GF.jpg" alt="e1k8GF.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kG24.jpg" alt="e1kG24.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kJxJ.jpg" alt="e1kJxJ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ktM9.jpg" alt="e1ktM9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kNrR.jpg" alt="e1kNrR.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kUq1.jpg" alt="e1kUq1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kdVx.jpg" alt="e1kdVx.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kwa6.jpg" alt="e1kwa6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k0IK.jpg" alt="e1k0IK.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kDPO.jpg" alt="e1kDPO.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1krGD.jpg" alt="e1krGD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ksRe.jpg" alt="e1ksRe.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kyxH.jpg" alt="e1kyxH.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kcMd.jpg" alt="e1kcMd.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kgsA.jpg" alt="e1kgsA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k2qI.jpg" alt="e1k2qI.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kWZt.jpg" alt="e1kWZt.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kfdP.jpg" alt="e1kfdP.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1khIf.jpg" alt="e1khIf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k5i8.jpg" alt="e1k5i8.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kIJS.jpg" alt="e1kIJS.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1koRg.jpg" alt="e1koRg.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kTzQ.jpg" alt="e1kTzQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kHMj.jpg" alt="e1kHMj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kbss.jpg" alt="e1kbss.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kqLn.jpg" alt="e1kqLn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kOZq.jpg" alt="e1kOZq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kXd0.jpg" alt="e1kXd0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kxiT.jpg" alt="e1kxiT.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kzJU.jpg" alt="e1kzJU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Apz4.jpg" alt="e1Apz4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ACQJ.jpg" alt="e1ACQJ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1APy9.jpg" alt="e1APy9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ake1.jpg" alt="e1Ake1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AEo6.jpg" alt="e1AEo6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AmWD.jpg" alt="e1AmWD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AKQH.jpg" alt="e1AKQH.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AQOA.jpg" alt="e1AQOA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A1eI.jpg" alt="e1A1eI.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AJFf.jpg" alt="e1AJFf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AUSg.jpg" alt="e1AUSg.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AalQ.jpg" alt="e1AalQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AwOs.jpg" alt="e1AwOs.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ABmn.jpg" alt="e1ABmn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ADwq.jpg" alt="e1ADwq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ArT0.jpg" alt="e1ArT0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A6YT.jpg" alt="e1A6YT.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AcfU.jpg" alt="e1AcfU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A2pF.jpg" alt="e1A2pF.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ARl4.jpg" alt="e1ARl4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AW6J.jpg" alt="e1AW6J.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AfX9.jpg" alt="e1AfX9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A4mR.jpg" alt="e1A4mR.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A501.jpg" alt="e1A501.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AITx.jpg" alt="e1AITx.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ATk6.jpg" alt="e1ATk6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A7tK.jpg" alt="e1A7tK.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AHfO.jpg" alt="e1AHfO.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AqpD.jpg" alt="e1AqpD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AL1e.jpg" alt="e1AL1e.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AO6H.jpg" alt="e1AO6H.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AXXd.jpg" alt="e1AXXd.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AvnA.jpg" alt="e1AvnA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Az7t.jpg" alt="e1Az7t.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EpAP.jpg" alt="e1EpAP.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1E9tf.jpg" alt="e1E9tf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ECh8.jpg" alt="e1ECh8.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ei9S.jpg" alt="e1Ei9S.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EF1g.jpg" alt="e1EF1g.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EkcQ.jpg" alt="e1EkcQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EAXj.jpg" alt="e1EAXj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EVns.jpg" alt="e1EVns.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EZBn.jpg" alt="e1EZBn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ee7q.jpg" alt="e1Ee7q.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EnA0.jpg" alt="e1EnA0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EuNV.jpg" alt="e1EuNV.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EQ9U.jpg" alt="e1EQ9U.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1E1c4.jpg" alt="e1E1c4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EGu9.jpg" alt="e1EGu9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EYH1.jpg" alt="e1EYH1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EUN6.jpg" alt="e1EUN6.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PMSM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于404问题及感谢</title>
      <link href="/2019/07/24/%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2/"/>
      <url>/2019/07/24/%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>CNAME里面是写xxx.github.io</p></li><li><p>解析域名的时候最好用CNAME并 解析到 xxx.github.io</p></li><li><p>GitHub 仓库里的Setting 最好也改成<a href="http://www.xxx.xxx" target="_blank" rel="noopener">www.xxx.xxx</a></p></li></ol><p><strong>顺便感谢一下搭建博客参考网站</strong></p><p><a href="https://www.bilibili.com/video/av44544186" title="CodeSheep" target="_blank" rel="noopener">UP：CodeSheep</a></p><p><a href="https://www.bilibili.com/video/av23913382" title="吃饱睡觉的猫" target="_blank" rel="noopener">UP：吃饱睡觉的猫</a></p><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial" title="遇见西门" target="_blank" rel="noopener"> 遇见西门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于dsp平台电流环解耦</title>
      <link href="/2019/07/23/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6/"/>
      <url>/2019/07/23/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>120V电压 400rpm的给定电流</strong></p><p>应该加的补偿值</p><p>​<br><code>ttt = 0.00105 \* \_IQmpy(pi_id.Fbk,pi_spd.Fbk) \* 4500 \* 9 /(volt1.DcBusVolt\*409.9) + 0.065 \* pi_spd.Fbk \* 4500 /(volt1.DcBusVolt\*409.9);</code></p><p>下面是解耦后应该的公式.</p><p>​<code>ipark1.Qs = pi_iq.Out + ttt;​</code></p><p>在未解耦的时候，测得ipark1.Qs = 0.515 . 换算成真实的电压值为(乘当前的电流值) 0.515 * 120 V=61.8V</p><p>测得ttt = 0.22 . 换算成真实的电压值为26.4V.</p><p>ttt的主要成份是反电势 ​<code>flux\*we=0.1552\*400\*4\*3.14/30=26.0V​</code></p><p>所以证明电流环解耦 程序是正确的.</p><p><img src="https://s2.ax1x.com/2019/07/24/eAzypd.png" alt="解耦前后对比"></p><p>实验结果 （右为解耦）</p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> PMSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first generage blog</title>
      <link href="/2019/07/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>第一个博客 杠杠滴</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
