<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PySpark学习回顾</title>
      <link href="/2020/05/01/PySpark%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/05/01/PySpark%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote><p><strong>三人行必有我师焉</strong> – 中国古代谚语</p></blockquote><p>本文是在GitHub上无意间找到的有关PySpark的宝贵学习资料，很全面。希望借此对之前的学习有更加深入的理解！</p><h1 id="2-为什么是-Spark-和-Python"><a href="#2-为什么是-Spark-和-Python" class="headerlink" title="2. 为什么是 Spark 和 Python"></a>2. 为什么是 Spark 和 Python</h1><blockquote><p><strong>磨刀不误砍柴工。</strong> – 中国古代谚语</p></blockquote><p>我想从以下两个部分回答这个问题：</p><h2 id="2-1-为什么是-Spark"><a href="#2-1-为什么是-Spark" class="headerlink" title="2.1. 为什么是 Spark"></a>2.1. 为什么是 Spark</h2><p>我认为 <a href="http://spark.apache.org/" target="_blank" rel="noopener">Apache Spark™</a> 官网的以下四个主要原因足以说服您使用 Spark。</p><ol><li><p>速度</p><p>在内存中运行程序比 Hadoop MapReduce 快 100 倍，或者比磁盘上运行快 10 倍。</p><p>Apache Spark 拥有先进的 DAG 执行引擎，支持非循环数据流和内存计算。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/logistic-regression.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/logistic-regression.png"></p><p>Hadoop 和 Spark 中的逻辑回归</p></blockquote></li><li><p>易于使用</p><p>使用 Java，Scala，Python，R 快速编写应用。</p><p>Spark 提供 80 多个高级操作符，可以轻松构建并行应用。 您可以从 Scala，Python 和 R shell 中以交互方式使用它。</p></li><li><p>通用性</p><p>结合SQL，流式和复杂的分析。</p><p>Spark 支持很多库，包括 SQL 和 DataFrames，用于机器学习的 MLlib，GraphX 和 Spark Streaming。您可以在同一个应用中无缝地组合这些库。</p><blockquote><p><a href="https://runawayhorse001.github.io/LearningApacheSpark/_images/stack.png" target="_blank" rel="noopener"><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/stack.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/stack.png"></a></p><p>Spark 技术栈</p></blockquote></li><li><p>随处运行</p><p>Spark 在 Hadoop，Mesos，独立或云端运行。 它可以访问各种数据源，包括 HDFS，Cassandra，HBase 和 S3。</p><blockquote><p><a href="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-runs-everywhere.png" target="_blank" rel="noopener"><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-runs-everywhere.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-runs-everywhere.png"></a></p><p>Spark 平台</p></blockquote></li></ol><h2 id="2-2-为什么是-PySpark"><a href="#2-2-为什么是-PySpark" class="headerlink" title="2.2. 为什么是 PySpark?"></a>2.2. 为什么是 PySpark?</h2><p>无论你喜欢与否，Python 都是最受欢迎的编程语言之一。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/languages.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/languages.jpg"></p><p>KDnuggets 分析/数据科学 2017 软件调查，来自 <a href="http://www.kdnuggets.com/2017/05/poll-analytics-data-science-machine-learning-software-leaders.html" target="_blank" rel="noopener">kdnuggets</a>。</p></blockquote><h1 id="3-配置运行平台"><a href="#3-配置运行平台" class="headerlink" title="3. 配置运行平台"></a>3. 配置运行平台</h1><blockquote><p><strong>工欲善其事，必先利其器。</strong> – 中国古代谚语</p></blockquote><p>一个好的编程平台可以为您节省大量的麻烦和时间。 在这里，我将仅介绍如何安装我最喜欢的编程平台，并且只展示我在 Linux 系统上设置它的最简单的方法。 如果要在其他操作系统上安装，可以通过搜索引擎。 在本节中，您可以学习如何在相应的编程平台和包上设置 Pyspark。</p><h2 id="3-1-在-Databricks-社区云上运行"><a href="#3-1-在-Databricks-社区云上运行" class="headerlink" title="3.1. 在 Databricks 社区云上运行"></a>3.1. 在 Databricks 社区云上运行</h2><p>如果您对 Linux 或 Unix 操作系统没有任何经验，我很乐意建议您在 Databricks 社区云上使用 Spark。 因为你不需要设置 Spark，它对于社区版来说完全是免费的**。 请按照下面列出的步骤操作。</p><ol><li><p>在 <a href="https://community.cloud.databricks.com/login.html" target="_blank" rel="noopener">https://community.cloud.databricks.com/login.html</a> 建立账户：</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/login.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/login.png"></p></li><li><p>使用您的帐户登录，然后您可以创建集群（计算机），表（数据集）和笔记本（代码）。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/workspace.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/workspace.png"></p></li><li><p>创建运行代码的集群</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/cluster.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/cluster.png"></p></li><li><p>导入你的数据集</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/table.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/table.png"></p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/dataset1.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/dataset1.png"></p><blockquote><p>注意</p><p>您需要保存<code>Uploaded to DBFS</code>中显示的路径: <code>/FileStore/tables/05rmhuqv1489687378010/</code>，由于我们会使用这个路径来上传数据集。</p></blockquote></li><li><p>创建你的笔记本</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/notebook.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/notebook.png"> </p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/codenotebook.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/codenotebook.png"></p></li></ol><p>完成上述 5 个步骤后，您就可以在 Databricks 社区云上运行 Spark 代码了。 我将在 Databricks 社区云上运行以下所有演示。在运行演示代码时，希望您将获得以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|_c0|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|  1|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">|  2| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">|  3| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|  4|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|  5|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- _c0: integer (nullable = true)</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><h2 id="3-2-在-Mac-和-Ubuntu-上配置-Spark"><a href="#3-2-在-Mac-和-Ubuntu-上配置-Spark" class="headerlink" title="3.2. 在 Mac 和 Ubuntu 上配置 Spark"></a>3.2. 在 Mac 和 Ubuntu 上配置 Spark</h2><h3 id="3-2-1-安装先决条件"><a href="#3-2-1-安装先决条件" class="headerlink" title="3.2.1. 安装先决条件"></a>3.2.1. 安装先决条件</h3><p>我强烈建议您安装 <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda</a>，因为它包含大部分先决条件并支持多个操作系统。</p><p><strong>安装 Python</strong></p><p>转到 Ubuntu 软件中心并按照以下步骤操作：</p><ol><li>打开 Ubuntu 软件中心</li><li>搜索 python</li><li>并点击“安装”</li></ol><p>或者打开终端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential checkinstall</span><br><span class="line">sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev</span><br><span class="line">                 libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev</span><br><span class="line">sudo apt-get install python</span><br><span class="line">sudo easy_install pip</span><br><span class="line">sudo pip install ipython</span><br></pre></td></tr></table></figure><h3 id="3-2-2-安装-Java"><a href="#3-2-2-安装-Java" class="headerlink" title="3.2.2. 安装 Java"></a>3.2.2. 安装 Java</h3><p>Java 被许多其他软件使用。 所以你很可能已经安装了它。 您可以在命令提示符中使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>否则，您可以按照<a href="https://java.com/en/download/help/mac_install.xml" target="_blank" rel="noopener">如何为我的 Mac 安装 Java？</a>中的步骤，在 Mac 上安装 java 并在命令提示符中使用以下命令来在 Ubuntu 上安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure><h3 id="3-2-3-安装-JRE"><a href="#3-2-3-安装-JRE" class="headerlink" title="3.2.3. 安装 JRE"></a>3.2.3. 安装 JRE</h3><p>我安装了 ORACLE <a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html" target="_blank" rel="noopener">Java JDK</a>。</p><blockquote><p>警告</p><p><strong>安装 Java 和 Java SE 运行时环境的步骤非常重要，因为 Spark 是一种用 Java 编写的领域特定语言。</strong></p></blockquote><p>您可以在命令提示符中使用以下命令检查 Java 是否可用并找到它的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>如果您的 Java 安装成功，您将获得如下的类似结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="3-2-4-安装-Apache-Spark"><a href="#3-2-4-安装-Apache-Spark" class="headerlink" title="3.2.4. 安装 Apache Spark"></a>3.2.4. 安装 Apache Spark</h3><p>实际上，预构建版本不需要安装。 你在解包时可以使用它。</p><ol><li>下载：您可以从 <a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">下载 Apache Spark™</a> 获得预构建的 Apache Spark™。</li><li>解压缩：将 Apache Spark™ 解压缩到您要安装 Spark 的路径。</li><li>测试：测试先决条件：修改路径<code>spark-#.#.#-bin-hadoop#.#/bin</code>并运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pyspark</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7.13 |Anaconda 4.4.0 (x86_64)| (default, Dec 20 2016, 23:05:08)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Anaconda is brought to you by Continuum Analytics.</span><br><span class="line">Please check out: http://continuum.io/thanks and https://anaconda.org</span><br><span class="line">Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR,</span><br><span class="line">use setLogLevel(newLevel).</span><br><span class="line">17/08/30 13:30:12 WARN NativeCodeLoader: Unable to load native-hadoop</span><br><span class="line">library for your platform... using builtin-java classes where applicable</span><br><span class="line">17/08/30 13:30:17 WARN ObjectStore: Failed to get database global_temp,</span><br><span class="line">returning NoSuchObjectException</span><br><span class="line">Welcome to</span><br><span class="line">       ____              __</span><br><span class="line">      / __/__  ___ _____/ /__</span><br><span class="line">     _\ \/ _ \/ _ `/ __/  &apos;_/</span><br><span class="line">    /__ / .__/\_,_/_/ /_/\_\   version 2.1.1</span><br><span class="line">       /_/</span><br><span class="line"></span><br><span class="line">Using Python version 2.7.13 (default, Dec 20 2016 23:05:08)</span><br><span class="line">SparkSession available as &apos;spark&apos;.</span><br></pre></td></tr></table></figure><h3 id="3-2-5-配置-Spark"><a href="#3-2-5-配置-Spark" class="headerlink" title="3.2.5. 配置 Spark"></a>3.2.5. 配置 Spark</h3><ol><li><p><strong>Mac 操作系统：</strong>在终端打开你的<code>bash_profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>并将以下行添加到<code>bash_profile</code>（记得改变路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 spark 添加</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=your_spark_installation_path</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/sbin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PYSPARK_DRIVE_PYTHON=<span class="string">"jupyter"</span></span><br><span class="line"><span class="built_in">export</span> PYSPARK_DRIVE_PYTHON_OPTS=<span class="string">"notebook"</span></span><br></pre></td></tr></table></figure><p>最后，记得执行你的<code>bash_profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p><strong>Ubuntu 操作系统：</strong>在终端打开<code>bashrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>并将以下行添加到<code>bashrc</code>（记得改变路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 spark 添加</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=your_spark_installation_path</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/sbin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PYSPARK_DRIVE_PYTHON=<span class="string">"jupyter"</span></span><br><span class="line"><span class="built_in">export</span> PYSPARK_DRIVE_PYTHON_OPTS=<span class="string">"notebook"</span></span><br></pre></td></tr></table></figure><p>最后，记得执行你的<code>bash_profile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-3-在-Windows-上配置-Spark"><a href="#3-3-在-Windows-上配置-Spark" class="headerlink" title="3.3. 在 Windows 上配置 Spark"></a>3.3. 在 Windows 上配置 Spark</h2><p>在 Windows 上安装开源软件对我来说总是一场噩梦。 感谢 Deelesh Mandloi。 您可以按照博客<a href="http://deelesh.github.io/pyspark-windows.html" target="_blank" rel="noopener"> Windows 上的 PySpark 入门</a>中的详细步骤，在 Windows 操作系统上安装 Apache Spark™。</p><h2 id="3-4-PySpark-和文本编辑器或-IDE"><a href="#3-4-PySpark-和文本编辑器或-IDE" class="headerlink" title="3.4. PySpark 和文本编辑器或 IDE"></a>3.4. PySpark 和文本编辑器或 IDE</h2><h3 id="3-4-1-PySpark-和-Jupyter-笔记本"><a href="#3-4-1-PySpark-和-Jupyter-笔记本" class="headerlink" title="3.4.1. PySpark 和 Jupyter 笔记本"></a>3.4.1. PySpark 和 Jupyter 笔记本</h3><p>完成<a href="#setup-up-ubuntu">在 Mac 和 Ubuntu 上配置 Spark</a>中的上述设置步骤后，您应该在 Jupyter 笔 记本中编写和运行 PySpark 代码。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/jupyterWithPySpark.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/jupyterWithPySpark.png"></p></blockquote><h3 id="3-4-2-PySpark-和-Apache-Zeppelin"><a href="#3-4-2-PySpark-和-Apache-Zeppelin" class="headerlink" title="3.4.2. PySpark 和 Apache Zeppelin"></a>3.4.2. PySpark 和 Apache Zeppelin</h3><p>完成<a href="#setup-up-ubuntu">在 Mac 和 Ubuntu 上配置 Spark</a>中的上述设置步骤后，您应该在 Apache Zeppelin 中编写和运行 PySpark 代码。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/zeppelin.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/zeppelin.png"></p></blockquote><h3 id="3-4-3-PySpark-和-Sublime-Text"><a href="#3-4-3-PySpark-和-Sublime-Text" class="headerlink" title="3.4.3. PySpark 和 Sublime Text"></a>3.4.3. PySpark 和 Sublime Text</h3><p>完成<a href="#setup-up-ubuntu">在 Mac 和 Ubuntu 上配置 Spark</a>中的上述设置步骤后，您应该可以使用 Sublime Text 编写 PySpark 代码,并在终端中将代码作为普通的 python 代码运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test_pyspark.py</span><br></pre></td></tr></table></figure><p>然后你应该在你的终端获得输出结果。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/sublimeWithPySpark.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/sublimeWithPySpark.png"></p></blockquote><h3 id="3-4-4-PySpark-和-Eclipse"><a href="#3-4-4-PySpark-和-Eclipse" class="headerlink" title="3.4.4. PySpark 和 Eclipse"></a>3.4.4. PySpark 和 Eclipse</h3><p>如果要在 Eclipse 上运行 PySpark 代码，则需要为<strong>当前项目</strong>添加<strong>外部库</strong>的路径，如下所示：</p><ol><li><p>打开你的项目的属性</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/PyDevProperties.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/PyDevProperties.png"></p></li><li><p>为<strong>外部</strong>添加路径</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/pydevPath.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/pydevPath.png"></p></li></ol><p>然后你应该足以用 PyDev 在 Eclipse 上运行你的代码。</p><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/pysparkWithEclipse.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/pysparkWithEclipse.png"></p></blockquote><h2 id="3-5-PySparkling-水-Spark-H2O"><a href="#3-5-PySparkling-水-Spark-H2O" class="headerlink" title="3.5. PySparkling 水: Spark + H2O"></a>3.5. PySparkling 水: Spark + H2O</h2><ol><li><p>从 <a href="https://s3.amazonaws.com/h2o-release/sparkling-water/rel-2.4/5/index.html" target="_blank" rel="noopener">https://s3.amazonaws.com/h2o-release/sparkling-water/rel-2.4/5/index.html</a> 下载<code>Sparkling Water</code>：</p></li><li><p>测试 PySparking</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip sparkling-water-2.4.5.zip</span><br><span class="line"><span class="built_in">cd</span>  ~/sparkling-water-2.4.5/bin</span><br><span class="line">./pysparkling</span><br></pre></td></tr></table></figure><p>如果您有正确设置了 PySpark，那么您将获得以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Using Spark defined in the SPARK_HOME=/Users/dt216661/spark environmental property</span><br><span class="line"></span><br><span class="line">Python 3.7.1 (default, Dec 14 2018, 13:28:58)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">2019-02-15 14:08:30 WARN  NativeCodeLoader:62 - Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">2019-02-15 14:08:31 WARN  Utils:66 - Service &apos;SparkUI&apos; could not bind on port 4040\. Attempting port 4041.</span><br><span class="line">2019-02-15 14:08:31 WARN  Utils:66 - Service &apos;SparkUI&apos; could not bind on port 4041\. Attempting port 4042.</span><br><span class="line">17/08/30 13:30:12 WARN NativeCodeLoader: Unable to load native-hadoop</span><br><span class="line">library for your platform... using builtin-java classes where applicable</span><br><span class="line">17/08/30 13:30:17 WARN ObjectStore: Failed to get database global_temp,</span><br><span class="line">returning NoSuchObjectException</span><br><span class="line">Welcome to</span><br><span class="line">       ____              __</span><br><span class="line">      / __/__  ___ _____/ /__</span><br><span class="line">     _\ \/ _ \/ _ `/ __/  &apos;_/</span><br><span class="line">    /__ / .__/\_,_/_/ /_/\_\   version 2.4.0</span><br><span class="line">       /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.7.1 (default, Dec 14 2018 13:28:58)</span><br><span class="line">SparkSession available as &apos;spark&apos;.</span><br></pre></td></tr></table></figure></li><li><p>使用 Jupyter notebook <code>pysparkling</code></p><p>将以下别名添加到<code>bashrc</code>（Linux 系统）或<code>bash_profile</code>（Mac 系统）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> sparkling=<span class="string">"PYSPARK_DRIVER_PYTHON="</span>ipython<span class="string">" PYSPARK_DRIVER_PYTHON_OPTS=    "</span>notebook<span class="string">" /~/~/sparkling-water-2.4.5/bin/pysparkling"</span></span><br></pre></td></tr></table></figure></li><li><p>在终端打开<code>pysparkling</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparkling</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-6-在云上配置-Spark"><a href="#3-6-在云上配置-Spark" class="headerlink" title="3.6. 在云上配置 Spark"></a>3.6. 在云上配置 Spark</h2><p>按照<a href="#setup-up-ubuntu">在 Mac 和 Ubuntu 上配置 Spark</a>中的设置步骤，您可以在云上设置自己的集群，例如 AWS，Google Cloud。 实际上，对于那些云，他们有自己的大数据工具。 你可以直接在任何设置上运行它们，就像 Databricks 社区云一样。 如果您想了解更多详情，请随时与作者联系。</p><h2 id="3-7-这一节的示例代码"><a href="#3-7-这一节的示例代码" class="headerlink" title="3.7. 这一节的示例代码"></a>3.7. 这一节的示例代码</h2><p>此部分的代码可在<a href="static/test_pyspark.py"><code>test_pyspark</code></a>下载，Jupyter 笔记本可从<a href="static/test_pyspark.ipynb"><code>test_pyspark_ipynb</code></a>下载。</p><ul><li>Python 源代码</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 建立 SparkSession</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark SQL basic example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">df = spark.read.format(<span class="string">'com.databricks.spark.csv'</span>).\</span><br><span class="line">                               options(header=<span class="string">'true'</span>, \</span><br><span class="line">                               inferschema=<span class="string">'true'</span>).\</span><br><span class="line">                     load(<span class="string">"/home/feng/Spark/Code/data/Advertising.csv"</span>,header=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">df.show(<span class="number">5</span>)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><h1 id="4-Apache-Spark-入门"><a href="#4-Apache-Spark-入门" class="headerlink" title="4. Apache Spark 入门"></a>4. Apache Spark 入门</h1><p><strong>知己知彼，百战百胜。</strong> – 《孙子兵法》</p><h2 id="4-1-核心概念"><a href="#4-1-核心概念" class="headerlink" title="4.1. 核心概念"></a>4.1. 核心概念</h2><p>以下大部分内容来自 <a href="reference.html#kirillov2016">[Kirillov2016]</a>。 所以版权属于 <strong>Anton Kirillov</strong>。我向您推荐<a href="http://datastrophic.io/core-concepts-architecture-and-internals-of-apache-spark/" target="_blank" rel="noopener"> Apache Spark 核心概念，架构和内部</a>来获取更多详细信息。</p><p>在深入研究 Apache Spark 之前，让我们阅读 Apache Spark 的行话。</p><ul><li>作业：从 HDFS 或本地读取一些输入的代码，对数据执行一些计算并写入一些输出数据。</li><li>阶段：工作分为几个阶段。 阶段被分类为映射或归约阶段（如果您已经使用过 Hadoop 并希望关联，则更容易理解）。 阶段基于计算边界划分，所有计算（操作符）不能在单个阶段中更新。 它发生在很多阶段。</li><li>任务：每个阶段都有一些任务，每个任务一个分区。 一个任务执行在一个执行器（机器）上的一个数据分区上。</li><li>DAG：DAG 代表有向无环图，在本文中是操作符的 DAG。</li><li>执行器：负责执行任务的进程。</li><li>主机：运行驱动程序的机器</li><li>从机：运行执行程序的机器</li></ul><h2 id="4-2-Spark-组件"><a href="#4-2-Spark-组件" class="headerlink" title="4.2. Spark 组件"></a>4.2. Spark 组件</h2><blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-components.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-components.png"></p></blockquote><ol><li><p>Spark 驱动</p><ul><li>隔离进程来执行用户应用</li><li>创建<code>SparkContext</code>来调度任务执行并与集群管理器协商</li></ul></li><li><p>执行器</p><ul><li>运行由驱动调度的任务</li><li>在内存、磁盘或者 off-heap 中储存计算结果</li><li>与储存系统个交互</li></ul></li><li><p>集群管理器</p><ul><li>Mesos</li><li>YARN</li><li>Spark Standalone</li></ul><p>Spark 驱动包含更多组件，负责将用户代码转换为集群上的实际作业：</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-components1.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/spark-components1.png"></p></li></ol><ul><li><p><code>SparkContext</code></p><ul><li>表示 spark 集群的连接，可用于在该集群上创建 RDD，累加器和广播变量</li></ul></li><li><p><code>DAGScheduler</code></p><ul><li>计算机每个作业的阶段的 DAG 并将它们提交给<code>TaskScheduler</code>，来确定任务的首选位置（基于缓存状态或随机文件位置）并找到运行作业的最小调度</li></ul></li><li><p><code>TaskScheduler</code></p><ul><li>负责将任务发送到集群，运行它们，在发生故障时重试，以及减轻负担</li></ul></li><li><p><code>SchedulerBackend</code></p><ul><li>用于调度系统的后端接口，允许插入不同的实现（mesos，yarn，standalone，local）</li></ul></li><li><p><code>BlockManager</code></p><ul><li>提供接口，用于在本地和远程将块放置到各种存储（内存，磁盘和堆外）和检索</li></ul></li></ul><h2 id="4-3-架构"><a href="#4-3-架构" class="headerlink" title="4.3. 架构"></a>4.3. 架构</h2><h2 id="4-4-Spark-的工作原理"><a href="#4-4-Spark-的工作原理" class="headerlink" title="4.4. Spark 的工作原理"></a>4.4. Spark 的工作原理</h2><p>Spark 具有较小的代码库，系统分为不同的层。 每一层都有一些责任。 这些层彼此独立。</p><p>第一层是解释器，Spark 使用 Scala 解释器，并进行了一些修改。 当您在 spark 控制台中输入代码（创建 RDD 并应用操作符）时，Spark 会创建一个操作符图。 当用户运行操作（如收集）时，图将提交给 DAG 调度器。 DAG 调度器将操作符图分为（映射和归约）阶段。 阶段由基于输入数据的分区的任务组成。 DAG 调度器将操作符连接在一起来优化图。 例如 许多图的操作符可以安排在一个阶段中。 此优化是 Sparks 性能的关键。 DAG 调度器的最终结果是一组阶段。 这些阶段将传递给任务调度器。 任务调度器通过集群管理器启动任务（Spark Standalone/Yarn/Mesos）。 任务调度器不知道阶段之间的依赖关系。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/work_flow.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/work_flow.png"></p><h1 id="5-使用-RDD-的编程"><a href="#5-使用-RDD-的编程" class="headerlink" title="5. 使用 RDD 的编程"></a>5. 使用 RDD 的编程</h1><p><strong>知彼知己，百战不殆；不知彼而知己，一胜一负；不知彼，不知己，每战必殆。</strong> – 《孙子兵法》</p><p>RDD 表示<strong>弹性分布式数据集</strong>。 Spark 中的 RDD 只是对象集的不可变分布式集合。 每个 RDD 被分成多个分区（具有较小集合的类似模式），可以在集群的不同节点上计算。</p><h2 id="5-1-创建-RDD"><a href="#5-1-创建-RDD" class="headerlink" title="5.1. 创建 RDD"></a>5.1. 创建 RDD</h2><p>通常，有两种创建 RDD 的流行方法：加载外部数据集或分发一组对象集合。 以下示例显示了一些使用<code>parallelize()</code>函数创建 RDD 的最简单方法，该方法接受程序中已有的集合，并将其传递给 Spark 上下文。</p><p>通过使用<code>parallelize( )</code>函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark create RDD example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">df = spark.sparkContext.parallelize([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a b c'</span>),</span><br><span class="line">             (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">'d e f'</span>),</span><br><span class="line">             (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="string">'g h i'</span>)]).toDF([<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>,<span class="string">'col4'</span>])</span><br></pre></td></tr></table></figure><p>然后你将获得 RDD 数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.show()</span><br><span class="line"></span><br><span class="line">+----+----+----+-----+</span><br><span class="line">|col1|col2|col3| col4|</span><br><span class="line">+----+----+----+-----+</span><br><span class="line">|   <span class="number">1</span>|   <span class="number">2</span>|   <span class="number">3</span>|a b c|</span><br><span class="line">|   <span class="number">4</span>|   <span class="number">5</span>|   <span class="number">6</span>|d e f|</span><br><span class="line">|   <span class="number">7</span>|   <span class="number">8</span>|   <span class="number">9</span>|g h i|</span><br><span class="line">+----+----+----+-----+</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark create RDD example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">myData = spark.sparkContext.parallelize([(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">7</span>,<span class="number">8</span>), (<span class="number">9</span>,<span class="number">10</span>)])</span><br></pre></td></tr></table></figure><p>然后你将获得 RDD 数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myData.collect()</span><br><span class="line"></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>), (<span class="number">9</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>通过使用<code>createDataFrame( )</code>函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark create RDD example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">Employee = spark.createDataFrame([</span><br><span class="line">                        (<span class="string">'1'</span>, <span class="string">'Joe'</span>,   <span class="string">'70000'</span>, <span class="string">'1'</span>),</span><br><span class="line">                        (<span class="string">'2'</span>, <span class="string">'Henry'</span>, <span class="string">'80000'</span>, <span class="string">'2'</span>),</span><br><span class="line">                        (<span class="string">'3'</span>, <span class="string">'Sam'</span>,   <span class="string">'60000'</span>, <span class="string">'2'</span>),</span><br><span class="line">                        (<span class="string">'4'</span>, <span class="string">'Max'</span>,   <span class="string">'90000'</span>, <span class="string">'1'</span>)],</span><br><span class="line">                        [<span class="string">'Id'</span>, <span class="string">'Name'</span>, <span class="string">'Sallary'</span>,<span class="string">'DepartmentId'</span>]</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure><p>然后你将获得 RDD 数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---+-----+-------+------------+</span><br><span class="line">| Id| Name|Sallary|DepartmentId|</span><br><span class="line">+---+-----+-------+------------+</span><br><span class="line">|  <span class="number">1</span>|  Joe|  <span class="number">70000</span>|           <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|Henry|  <span class="number">80000</span>|           <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|  Sam|  <span class="number">60000</span>|           <span class="number">2</span>|</span><br><span class="line">|  <span class="number">4</span>|  Max|  <span class="number">90000</span>|           <span class="number">1</span>|</span><br><span class="line">+---+-----+-------+------------+</span><br></pre></td></tr></table></figure><p>通过使用<code>read</code>和<code>load</code>函数</p><p><strong>从 .csv 文件读取数据集</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 建立 SparkSession</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark create RDD example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">df = spark.read.format(<span class="string">'com.databricks.spark.csv'</span>).\</span><br><span class="line">                               options(header=<span class="string">'true'</span>, \</span><br><span class="line">                               inferschema=<span class="string">'true'</span>).\</span><br><span class="line">                load(<span class="string">"/home/feng/Spark/Code/data/Advertising.csv"</span>,header=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">df.show(<span class="number">5</span>)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><p>然后你将获得 RDD 数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|_c0|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|  <span class="number">1</span>|<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|</span><br><span class="line">|  <span class="number">2</span>| <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|</span><br><span class="line">|  <span class="number">3</span>| <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|</span><br><span class="line">|  <span class="number">4</span>|<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|</span><br><span class="line">|  <span class="number">5</span>|<span class="number">180.8</span>| <span class="number">10.8</span>|     <span class="number">58.4</span>| <span class="number">12.9</span>|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">only showing top <span class="number">5</span> rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- _c0: integer (nullable = true)</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><p>创建后，RDD 提供两种类型的操作：转换和动作。</p><p><strong>从数据库读取数据集</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 建立 SparkSession</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">            .builder \</span><br><span class="line">            .appName(<span class="string">"Python Spark create RDD example"</span>) \</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 用户信息</span></span><br><span class="line">user = <span class="string">'your_username'</span></span><br><span class="line">pw   = <span class="string">'your_password'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 数据库信息</span></span><br><span class="line">table_name = <span class="string">'table_name'</span></span><br><span class="line">url = <span class="string">'jdbc:postgresql://##.###.###.##:5432/dataset?user='</span>+user+<span class="string">'&amp;password='</span>+pw</span><br><span class="line">properties =&#123;<span class="string">'driver'</span>: <span class="string">'org.postgresql.Driver'</span>, <span class="string">'password'</span>: pw,<span class="string">'user'</span>: user&#125;</span><br><span class="line"></span><br><span class="line">df = spark.read.jdbc(url=url, table=table_name, properties=properties)</span><br><span class="line"></span><br><span class="line">df.show(<span class="number">5</span>)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><p>然后你将获得 RDD 数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|_c0|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">|  <span class="number">1</span>|<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|</span><br><span class="line">|  <span class="number">2</span>| <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|</span><br><span class="line">|  <span class="number">3</span>| <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|</span><br><span class="line">|  <span class="number">4</span>|<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|</span><br><span class="line">|  <span class="number">5</span>|<span class="number">180.8</span>| <span class="number">10.8</span>|     <span class="number">58.4</span>| <span class="number">12.9</span>|</span><br><span class="line">+---+-----+-----+---------+-----+</span><br><span class="line">only showing top <span class="number">5</span> rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- _c0: integer (nullable = true)</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>从数据库中读取表，需要相应数据库的正确驱动。 例如，上面的演示需要<code>org.postgresql.Driver</code>，你需要下载它并将它放在你的 spark 安装路径的<code>jars</code>文件夹中。 我从官方网站下载<code>postgresql-42.1.1.jar</code>并将其放在<code>jars</code>文件夹中。</p></blockquote><p><strong>从 HDFS 读取数据</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.conf <span class="keyword">import</span> SparkConf</span><br><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> HiveContext</span><br><span class="line"></span><br><span class="line">sc= SparkContext(<span class="string">'local'</span>,<span class="string">'example'</span>)</span><br><span class="line">hc = HiveContext(sc)</span><br><span class="line">tf1 = sc.textFile(<span class="string">"hdfs://cdhstltest/user/data/demo.CSV"</span>)</span><br><span class="line">print(tf1.first())</span><br><span class="line"></span><br><span class="line">hc.sql(<span class="string">"use intg_cme_w"</span>)</span><br><span class="line">spf = hc.sql(<span class="string">"SELECT * FROM spf LIMIT 100"</span>)</span><br><span class="line">print(spf.show(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="5-2-Spark-操作"><a href="#5-2-Spark-操作" class="headerlink" title="5.2. Spark 操作"></a>5.2. Spark 操作</h2><blockquote><p>警告</p><p>以下所有数据均来自J effrey Thompson。 感兴趣的读者可以参考 <a href="https://github.com/jkthompson/pyspark-pictures" target="_blank" rel="noopener">pyspark 图片</a>。</p><p>Spark 操作有两种主要类型：转换和动作 <a href="reference.html#karau2015">[Karau2015]</a>。</p></blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/visualapi_006.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/visualapi_006.png"></p><blockquote><p>注意</p><p>有些人定义了三种类型的操作：转换，动作和打乱。</p></blockquote><h3 id="5-2-1-Spark-转换"><a href="#5-2-1-Spark-转换" class="headerlink" title="5.2.1. Spark 转换"></a>5.2.1. Spark 转换</h3><p>转换从前一个 RDD 构建新的 RDD。 例如，一个常见的转换是过滤匹配谓词的数据。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/transforms1.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/transforms1.png"></p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/transforms2.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/transforms2.png"></p><h3 id="5-2-2-Spark-动作"><a href="#5-2-2-Spark-动作" class="headerlink" title="5.2.2. Spark 动作"></a>5.2.2. Spark 动作</h3><p>另一方面，动作基于 RDD 计算结果，并将其返回到驱动，或将其保存到外部存储系统（例如，HDFS）。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/actions1.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/actions1.png"></p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/actions2.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/actions2.png"></p><h2 id="5-3-rdd-DataFrame-VS-pd-DataFrame"><a href="#5-3-rdd-DataFrame-VS-pd-DataFrame" class="headerlink" title="5.3. rdd.DataFrame VS pd.DataFrame"></a>5.3. <code>rdd.DataFrame</code> VS <code>pd.DataFrame</code></h2><h3 id="5-3-1-创建DataFrame"><a href="#5-3-1-创建DataFrame" class="headerlink" title="5.3.1. 创建DataFrame"></a>5.3.1. 创建<code>DataFrame</code></h3><p><strong>来自列表</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="string">'b'</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="string">'c'</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">col_name = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意 columns=</span></span><br><span class="line">pd.DataFrame(my_list,columns= col_name)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">spark.createDataFrame(my_list, col_name).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                  +---+---+---+</span><br><span class="line">                  |  A|  B|  C|</span><br><span class="line">   A  B  C        +---+---+---+</span><br><span class="line"><span class="number">0</span>  a  <span class="number">1</span>  <span class="number">2</span>        |  a|  <span class="number">1</span>|  <span class="number">2</span>|</span><br><span class="line"><span class="number">1</span>  b  <span class="number">2</span>  <span class="number">3</span>        |  b|  <span class="number">2</span>|  <span class="number">3</span>|</span><br><span class="line"><span class="number">2</span>  c  <span class="number">3</span>  <span class="number">4</span>        |  c|  <span class="number">3</span>|  <span class="number">4</span>|</span><br><span class="line">                  +---+---+---+</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>注意<code>pd.DataFrame</code>中的参数<code>columns=</code>，由于默认值将使列表成为行。</p></blockquote><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意 columns=</span></span><br><span class="line">pd.DataFrame(my_list, columns= col_name)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">pd.DataFrame(my_list, col_name)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   A  B  C             <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  a  <span class="number">1</span>  <span class="number">2</span>          A  a  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  b  <span class="number">2</span>  <span class="number">3</span>          B  b  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  c  <span class="number">3</span>  <span class="number">4</span>          C  c  <span class="number">3</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>来自字典</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'A'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">     <span class="string">'B'</span>: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">     <span class="string">'C'</span>: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]&#125;</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(d)<span class="keyword">for</span></span><br><span class="line"><span class="comment"># PySpark 很麻烦</span></span><br><span class="line">spark.createDataFrame(np.array(list(d.values())).T.tolist(),list(d.keys())).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   +---+---+---+</span><br><span class="line">                   |  A|  B|  C|</span><br><span class="line">   A  B  C         +---+---+---+</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>         |  <span class="number">0</span>|  <span class="number">1</span>|  <span class="number">1</span>|</span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>         |  <span class="number">1</span>|  <span class="number">0</span>|  <span class="number">0</span>|</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>         |  <span class="number">0</span>|  <span class="number">1</span>|  <span class="number">0</span>|</span><br><span class="line">                   +---+---+---+</span><br></pre></td></tr></table></figure><h3 id="5-3-2-加载DataFrame"><a href="#5-3-2-加载DataFrame" class="headerlink" title="5.3.2. 加载DataFrame"></a>5.3.2. 加载<code>DataFrame</code></h3><p><strong>来自数据库</strong></p><p>大多数情况下，您需要与同事共享代码，或为了代码审查或质量保证（QA）发布代码。 您肯定不希望在代码中包含您的“用户信息”。 所以你可以将它们保存在<code>login.txt</code>中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runawayhorse001</span><br><span class="line">PythonTips</span><br></pre></td></tr></table></figure><p>并使用以下代码导入您的“用户信息”：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户信息</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    login = pd.read_csv(<span class="string">r'login.txt'</span>, header=<span class="literal">None</span>)</span><br><span class="line">    user = login[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    pw = login[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">'User information is ready!'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Login information is not available!!!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库信息</span></span><br><span class="line">host = <span class="string">'##.###.###.##'</span></span><br><span class="line">db_name = <span class="string">'db_name'</span></span><br><span class="line">table_name = <span class="string">'table_name'</span></span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn = psycopg2.connect(host=host, database=db_name, user=user, password=pw)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"""</span></span><br><span class="line"><span class="string">      select *</span></span><br><span class="line"><span class="string">      from &#123;table_name&#125;</span></span><br><span class="line"><span class="string">      """</span>.format(table_name=table_name)</span><br><span class="line">dp = pd.read_sql(sql, conn)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">url = <span class="string">'jdbc:postgresql://'</span>+host+<span class="string">':5432/'</span>+db_name+<span class="string">'?user='</span>+user+<span class="string">'&amp;password='</span>+pw</span><br><span class="line">properties =&#123;<span class="string">'driver'</span>: <span class="string">'org.postgresql.Driver'</span>, <span class="string">'password'</span>: pw,<span class="string">'user'</span>: user&#125;</span><br><span class="line">ds = spark.read.jdbc(url=url, table=table_name, properties=properties)</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>使用 PySpark 从数据库中读取表，需要相应数据库的正确驱动。 例如，上面的演示需要<code>org.postgresql.Driver</code>，你需要下载它并将它放在你的 spark 安装路径的<code>jars</code>文件夹中。 我从官方网站下载<code>postgresql-42.1.1.jar</code>并将其放在<code>jars</code>文件夹中。</p></blockquote><p><strong>来自<code>.csv</code></strong></p><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pd.DataFrame dp: DataFrame pandas</span></span><br><span class="line">dp = pd.read_csv(<span class="string">'Advertising.csv'</span>)</span><br><span class="line"><span class="comment">#rdd.DataFrame. dp: DataFrame spark</span></span><br><span class="line">ds = spark.read.csv(path=<span class="string">'Advertising.csv'</span>,</span><br><span class="line"><span class="comment">#                sep=',',</span></span><br><span class="line"><span class="comment">#                encoding='UTF-8',</span></span><br><span class="line"><span class="comment">#                comment=None,</span></span><br><span class="line">               header=<span class="literal">True</span>,</span><br><span class="line">               inferSchema=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>来自<code>.json</code></strong></p><p>数据来自：<a href="http://api.luftdaten.info/static/v1/data.json" target="_blank" rel="noopener">http://api.luftdaten.info/static/v1/data.json</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp = pd.read_json(<span class="string">"data/data.json"</span>)</span><br><span class="line">ds = spark.read.json(<span class="string">'data/data.json'</span>)</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[[<span class="string">'id'</span>,<span class="string">'timestamp'</span>]].head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds[[<span class="string">'id'</span>,<span class="string">'timestamp'</span>]].show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +----------+-------------------+</span><br><span class="line">                                                |        id|          timestamp|</span><br><span class="line">            id  timestamp                       +----------+-------------------+</span><br><span class="line"><span class="number">0</span>   <span class="number">2994551481</span>  <span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>             |<span class="number">2994551481</span>|<span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">2994551482</span>  <span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>             |<span class="number">2994551482</span>|<span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">2994551483</span>  <span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>             |<span class="number">2994551483</span>|<span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>|</span><br><span class="line"><span class="number">3</span>   <span class="number">2994551484</span>  <span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>             |<span class="number">2994551484</span>|<span class="number">2019</span><span class="number">-02</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">23</span>:<span class="number">52</span>|</span><br><span class="line">                                                +----------+-------------------+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-3-前n行"><a href="#5-3-3-前n行" class="headerlink" title="5.3.3. 前n行"></a>5.3.3. 前<code>n</code>行</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                        +-----+-----+---------+-----+</span><br><span class="line">                                        |   TV|Radio|Newspaper|Sales|</span><br><span class="line">      TV  Radio  Newspaper  Sales       +-----+-----+---------+-----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>       <span class="number">69.2</span>   <span class="number">22.1</span>       |<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>       <span class="number">45.1</span>   <span class="number">10.4</span>       | <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>       <span class="number">69.3</span>    <span class="number">9.3</span>       | <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>       <span class="number">58.5</span>   <span class="number">18.5</span>       |<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|</span><br><span class="line">                                        +-----+-----+---------+-----+</span><br><span class="line">                                        only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-4-列名"><a href="#5-3-4-列名" class="headerlink" title="5.3.4. 列名"></a>5.3.4. 列名</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.columns</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.columns</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index([<span class="string">'TV'</span>, <span class="string">'Radio'</span>, <span class="string">'Newspaper'</span>, <span class="string">'Sales'</span>], dtype=<span class="string">'object'</span>)</span><br><span class="line">[<span class="string">'TV'</span>, <span class="string">'Radio'</span>, <span class="string">'Newspaper'</span>, <span class="string">'Sales'</span>]</span><br></pre></td></tr></table></figure><h3 id="5-3-5-数据类型"><a href="#5-3-5-数据类型" class="headerlink" title="5.3.5. 数据类型"></a>5.3.5. 数据类型</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.dtypes</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.dtypes</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TV           float64                    [(<span class="string">'TV'</span>, <span class="string">'double'</span>),</span><br><span class="line">Radio        float64                     (<span class="string">'Radio'</span>, <span class="string">'double'</span>),</span><br><span class="line">Newspaper    float64                     (<span class="string">'Newspaper'</span>, <span class="string">'double'</span>),</span><br><span class="line">Sales        float64                     (<span class="string">'Sales'</span>, <span class="string">'double'</span>)]</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><h3 id="5-3-6-填充空值"><a href="#5-3-6-填充空值" class="headerlink" title="5.3.6. 填充空值"></a>5.3.6. 填充空值</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="string">'a'</span>, <span class="number">1</span>, <span class="literal">None</span>], [<span class="string">'b'</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="string">'c'</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">dp = pd.DataFrame(my_list,columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</span><br><span class="line">ds = spark.createDataFrame(my_list, [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">dp.head()</span><br><span class="line">ds.show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                        +------+---+----+</span><br><span class="line">                                        |     A|  B|   C|</span><br><span class="line">        A  B    C                       +------+---+----+</span><br><span class="line"><span class="number">0</span>    male  <span class="number">1</span>  NaN                       |  male|  <span class="number">1</span>|null|</span><br><span class="line"><span class="number">1</span>  female  <span class="number">2</span>  <span class="number">3.0</span>                       |female|  <span class="number">2</span>|   <span class="number">3</span>|</span><br><span class="line"><span class="number">2</span>    male  <span class="number">3</span>  <span class="number">4.0</span>                       |  male|  <span class="number">3</span>|   <span class="number">4</span>|</span><br><span class="line">                                        +------+---+----+</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.fillna(<span class="number">-99</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.fillna(<span class="number">-99</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                        +------+---+----+</span><br><span class="line">                                        |     A|  B|   C|</span><br><span class="line">        A  B    C                       +------+---+----+</span><br><span class="line"><span class="number">0</span>    male  <span class="number">1</span>  <span class="number">-99</span>                       |  male|  <span class="number">1</span>| <span class="number">-99</span>|</span><br><span class="line"><span class="number">1</span>  female  <span class="number">2</span>  <span class="number">3.0</span>                       |female|  <span class="number">2</span>|   <span class="number">3</span>|</span><br><span class="line"><span class="number">2</span>    male  <span class="number">3</span>  <span class="number">4.0</span>                       |  male|  <span class="number">3</span>|   <span class="number">4</span>|</span><br><span class="line">                                        +------+---+----+</span><br></pre></td></tr></table></figure><h3 id="5-3-7-替换值"><a href="#5-3-7-替换值" class="headerlink" title="5.3.7. 替换值"></a>5.3.7. 替换值</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警告：您需要选择特定的列</span></span><br><span class="line">dp.A.replace([<span class="string">'male'</span>, <span class="string">'female'</span>],[<span class="number">1</span>, <span class="number">0</span>], inplace=<span class="literal">True</span>)</span><br><span class="line">dp</span><br><span class="line"><span class="comment"># 警告：不支持混合类型替换</span></span><br><span class="line">ds.na.replace([<span class="string">'male'</span>,<span class="string">'female'</span>],[<span class="string">'1'</span>,<span class="string">'0'</span>]).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                +---+---+----+</span><br><span class="line">                                |  A|  B|   C|</span><br><span class="line">   A  B    C                    +---+---+----+</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  NaN                    |  <span class="number">1</span>|  <span class="number">1</span>|null|</span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">3.0</span>                    |  <span class="number">0</span>|  <span class="number">2</span>|   <span class="number">3</span>|</span><br><span class="line"><span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">4.0</span>                    |  <span class="number">1</span>|  <span class="number">3</span>|   <span class="number">4</span>|</span><br><span class="line">                                +---+---+----+</span><br></pre></td></tr></table></figure><h3 id="5-3-8-重命名列"><a href="#5-3-8-重命名列" class="headerlink" title="5.3.8. 重命名列"></a>5.3.8. 重命名列</h3><p><strong>重命名所有列</strong></p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp.columns = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line">dp.head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.toDF(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+----+----+----+</span><br><span class="line">                                                |    a|   b|   c|   d|</span><br><span class="line">       a     b     c     d                      +-----+----+----+----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>  <span class="number">37.8</span>  <span class="number">69.2</span>  <span class="number">22.1</span>                      |<span class="number">230.1</span>|<span class="number">37.8</span>|<span class="number">69.2</span>|<span class="number">22.1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>  <span class="number">39.3</span>  <span class="number">45.1</span>  <span class="number">10.4</span>                      | <span class="number">44.5</span>|<span class="number">39.3</span>|<span class="number">45.1</span>|<span class="number">10.4</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>  <span class="number">45.9</span>  <span class="number">69.3</span>   <span class="number">9.3</span>                      | <span class="number">17.2</span>|<span class="number">45.9</span>|<span class="number">69.3</span>| <span class="number">9.3</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>  <span class="number">41.3</span>  <span class="number">58.5</span>  <span class="number">18.5</span>                      |<span class="number">151.5</span>|<span class="number">41.3</span>|<span class="number">58.5</span>|<span class="number">18.5</span>|</span><br><span class="line">                                                +-----+----+----+----+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><p><strong>重命名一列或多列</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping = &#123;<span class="string">'Newspaper'</span>:<span class="string">'C'</span>,<span class="string">'Sales'</span>:<span class="string">'D'</span>&#125;</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp.rename(columns=mapping).head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">new_names = [mapping.get(col,col) <span class="keyword">for</span> col <span class="keyword">in</span> ds.columns]</span><br><span class="line">ds.toDF(*new_names).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                        +-----+-----+----+----+</span><br><span class="line">                                        |   TV|Radio|   C|   D|</span><br><span class="line">      TV  Radio     C     D             +-----+-----+----+----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>  <span class="number">69.2</span>  <span class="number">22.1</span>             |<span class="number">230.1</span>| <span class="number">37.8</span>|<span class="number">69.2</span>|<span class="number">22.1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>  <span class="number">45.1</span>  <span class="number">10.4</span>             | <span class="number">44.5</span>| <span class="number">39.3</span>|<span class="number">45.1</span>|<span class="number">10.4</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>  <span class="number">69.3</span>   <span class="number">9.3</span>             | <span class="number">17.2</span>| <span class="number">45.9</span>|<span class="number">69.3</span>| <span class="number">9.3</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>  <span class="number">58.5</span>  <span class="number">18.5</span>             |<span class="number">151.5</span>| <span class="number">41.3</span>|<span class="number">58.5</span>|<span class="number">18.5</span>|</span><br><span class="line">                                        +-----+-----+----+----+</span><br><span class="line">                                        only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>您还可以使用<code>withColumnRenamed</code>重命名 PySpark 中的一列。</p></blockquote><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.withColumnRenamed(<span class="string">'Newspaper'</span>,<span class="string">'Paper'</span>).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+-----+-----+</span><br><span class="line">|   TV|Radio|Paper|Sales|</span><br><span class="line">+-----+-----+-----+-----+</span><br><span class="line">|<span class="number">230.1</span>| <span class="number">37.8</span>| <span class="number">69.2</span>| <span class="number">22.1</span>|</span><br><span class="line">| <span class="number">44.5</span>| <span class="number">39.3</span>| <span class="number">45.1</span>| <span class="number">10.4</span>|</span><br><span class="line">| <span class="number">17.2</span>| <span class="number">45.9</span>| <span class="number">69.3</span>|  <span class="number">9.3</span>|</span><br><span class="line">|<span class="number">151.5</span>| <span class="number">41.3</span>| <span class="number">58.5</span>| <span class="number">18.5</span>|</span><br><span class="line">+-----+-----+-----+-----+</span><br><span class="line">only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-9-丢弃列"><a href="#5-3-9-丢弃列" class="headerlink" title="5.3.9. 丢弃列"></a>5.3.9. 丢弃列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop_name = [<span class="string">'Newspaper'</span>,<span class="string">'Sales'</span>]</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.drop(drop_name,axis=<span class="number">1</span>).head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.drop(*drop_name).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                +-----+-----+</span><br><span class="line">                                |   TV|Radio|</span><br><span class="line">      TV  Radio                 +-----+-----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>                 |<span class="number">230.1</span>| <span class="number">37.8</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>                 | <span class="number">44.5</span>| <span class="number">39.3</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>                 | <span class="number">17.2</span>| <span class="number">45.9</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>                 |<span class="number">151.5</span>| <span class="number">41.3</span>|</span><br><span class="line">                                +-----+-----+</span><br><span class="line">                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-10-过滤"><a href="#5-3-10-过滤" class="headerlink" title="5.3.10. 过滤"></a>5.3.10. 过滤</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = pd.read_csv(<span class="string">'Advertising.csv'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds = spark.read.csv(path=<span class="string">'Advertising.csv'</span>,</span><br><span class="line">                    header=<span class="literal">True</span>,</span><br><span class="line">                    inferSchema=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[dp.Newspaper&lt;<span class="number">20</span>].head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds[ds.Newspaper&lt;<span class="number">20</span>].show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|</span><br><span class="line">       TV  Radio  Newspaper  Sales              +-----+-----+---------+-----+</span><br><span class="line"><span class="number">7</span>   <span class="number">120.2</span>   <span class="number">19.6</span>       <span class="number">11.6</span>   <span class="number">13.2</span>              |<span class="number">120.2</span>| <span class="number">19.6</span>|     <span class="number">11.6</span>| <span class="number">13.2</span>|</span><br><span class="line"><span class="number">8</span>     <span class="number">8.6</span>    <span class="number">2.1</span>        <span class="number">1.0</span>    <span class="number">4.8</span>              |  <span class="number">8.6</span>|  <span class="number">2.1</span>|      <span class="number">1.0</span>|  <span class="number">4.8</span>|</span><br><span class="line"><span class="number">11</span>  <span class="number">214.7</span>   <span class="number">24.0</span>        <span class="number">4.0</span>   <span class="number">17.4</span>              |<span class="number">214.7</span>| <span class="number">24.0</span>|      <span class="number">4.0</span>| <span class="number">17.4</span>|</span><br><span class="line"><span class="number">13</span>   <span class="number">97.5</span>    <span class="number">7.6</span>        <span class="number">7.2</span>    <span class="number">9.7</span>              | <span class="number">97.5</span>|  <span class="number">7.6</span>|      <span class="number">7.2</span>|  <span class="number">9.7</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[(dp.Newspaper&lt;<span class="number">20</span>)&amp;(dp.TV&gt;<span class="number">100</span>)].head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds[(ds.Newspaper&lt;<span class="number">20</span>)&amp;(ds.TV&gt;<span class="number">100</span>)].show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|</span><br><span class="line">       TV  Radio  Newspaper  Sales              +-----+-----+---------+-----+</span><br><span class="line"><span class="number">7</span>   <span class="number">120.2</span>   <span class="number">19.6</span>       <span class="number">11.6</span>   <span class="number">13.2</span>              |<span class="number">120.2</span>| <span class="number">19.6</span>|     <span class="number">11.6</span>| <span class="number">13.2</span>|</span><br><span class="line"><span class="number">11</span>  <span class="number">214.7</span>   <span class="number">24.0</span>        <span class="number">4.0</span>   <span class="number">17.4</span>              |<span class="number">214.7</span>| <span class="number">24.0</span>|      <span class="number">4.0</span>| <span class="number">17.4</span>|</span><br><span class="line"><span class="number">19</span>  <span class="number">147.3</span>   <span class="number">23.9</span>       <span class="number">19.1</span>   <span class="number">14.6</span>              |<span class="number">147.3</span>| <span class="number">23.9</span>|     <span class="number">19.1</span>| <span class="number">14.6</span>|</span><br><span class="line"><span class="number">25</span>  <span class="number">262.9</span>    <span class="number">3.5</span>       <span class="number">19.5</span>   <span class="number">12.0</span>              |<span class="number">262.9</span>|  <span class="number">3.5</span>|     <span class="number">19.5</span>| <span class="number">12.0</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-11-添加新列"><a href="#5-3-11-添加新列" class="headerlink" title="5.3.11. 添加新列"></a>5.3.11. 添加新列</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'tv_norm'</span>] = dp.TV/sum(dp.TV)</span><br><span class="line">dp.head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.withColumn(<span class="string">'tv_norm'</span>, ds.TV/ds.groupBy().agg(F.sum(<span class="string">"TV"</span>)).collect()[<span class="number">0</span>][<span class="number">0</span>]).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+--------------------+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|             tv_norm|</span><br><span class="line">      TV  Radio  Newspaper  Sales   tv_norm     +-----+-----+---------+-----+--------------------+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>       <span class="number">69.2</span>   <span class="number">22.1</span>  <span class="number">0.007824</span>     |<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|<span class="number">0.007824268493802813</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>       <span class="number">45.1</span>   <span class="number">10.4</span>  <span class="number">0.001513</span>     | <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|<span class="number">0.001513167961643</span>...|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>       <span class="number">69.3</span>    <span class="number">9.3</span>  <span class="number">0.000585</span>     | <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|<span class="number">5.848649200061207E-4</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>       <span class="number">58.5</span>   <span class="number">18.5</span>  <span class="number">0.005152</span>     |<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|<span class="number">0.005151571824472517</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+--------------------+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'cond'</span>] = dp.apply(<span class="keyword">lambda</span> c: <span class="number">1</span> <span class="keyword">if</span> ((c.TV&gt;<span class="number">100</span>)&amp;(c.Radio&lt;<span class="number">40</span>)) <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">if</span> c.Sales&gt; <span class="number">10</span> <span class="keyword">else</span> <span class="number">3</span>,axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.withColumn(<span class="string">'cond'</span>,F.when((ds.TV&gt;<span class="number">100</span>)&amp;(ds.Radio&lt;<span class="number">40</span>),<span class="number">1</span>)\</span><br><span class="line">                      .when(ds.Sales&gt;<span class="number">10</span>, <span class="number">2</span>)\</span><br><span class="line">                      .otherwise(<span class="number">3</span>)).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+----+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|cond|</span><br><span class="line">      TV  Radio  Newspaper  Sales  cond         +-----+-----+---------+-----+----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>       <span class="number">69.2</span>   <span class="number">22.1</span>     <span class="number">1</span>         |<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|   <span class="number">1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>       <span class="number">45.1</span>   <span class="number">10.4</span>     <span class="number">2</span>         | <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|   <span class="number">2</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>       <span class="number">69.3</span>    <span class="number">9.3</span>     <span class="number">3</span>         | <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|   <span class="number">3</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>       <span class="number">58.5</span>   <span class="number">18.5</span>     <span class="number">2</span>         |<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|   <span class="number">2</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+----+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'log_tv'</span>] = np.log(dp.TV)</span><br><span class="line">dp.head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.withColumn(<span class="string">'log_tv'</span>,F.log(ds.TV)).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+------------------+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|            log_tv|</span><br><span class="line">      TV  Radio  Newspaper  Sales    log_tv     +-----+-----+---------+-----+------------------+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>       <span class="number">69.2</span>   <span class="number">22.1</span>  <span class="number">5.438514</span>     |<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|  <span class="number">5.43851399704132</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>       <span class="number">45.1</span>   <span class="number">10.4</span>  <span class="number">3.795489</span>     | <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>|<span class="number">3.7954891891721947</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>       <span class="number">69.3</span>    <span class="number">9.3</span>  <span class="number">2.844909</span>     | <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>|<span class="number">2.8449093838194073</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>       <span class="number">58.5</span>   <span class="number">18.5</span>  <span class="number">5.020586</span>     |<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>| <span class="number">5.020585624949423</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+------------------+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'tv+10'</span>] = dp.TV.apply(<span class="keyword">lambda</span> x: x+<span class="number">10</span>)</span><br><span class="line">dp.head(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.withColumn(<span class="string">'tv+10'</span>, ds.TV+<span class="number">10</span>).show(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                                +-----+-----+---------+-----+-----+</span><br><span class="line">                                                |   TV|Radio|Newspaper|Sales|tv+<span class="number">10</span>|</span><br><span class="line">      TV  Radio  Newspaper  Sales  tv+<span class="number">10</span>        +-----+-----+---------+-----+-----+</span><br><span class="line"><span class="number">0</span>  <span class="number">230.1</span>   <span class="number">37.8</span>       <span class="number">69.2</span>   <span class="number">22.1</span>  <span class="number">240.1</span>        |<span class="number">230.1</span>| <span class="number">37.8</span>|     <span class="number">69.2</span>| <span class="number">22.1</span>|<span class="number">240.1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">44.5</span>   <span class="number">39.3</span>       <span class="number">45.1</span>   <span class="number">10.4</span>   <span class="number">54.5</span>        | <span class="number">44.5</span>| <span class="number">39.3</span>|     <span class="number">45.1</span>| <span class="number">10.4</span>| <span class="number">54.5</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">17.2</span>   <span class="number">45.9</span>       <span class="number">69.3</span>    <span class="number">9.3</span>   <span class="number">27.2</span>        | <span class="number">17.2</span>| <span class="number">45.9</span>|     <span class="number">69.3</span>|  <span class="number">9.3</span>| <span class="number">27.2</span>|</span><br><span class="line"><span class="number">3</span>  <span class="number">151.5</span>   <span class="number">41.3</span>       <span class="number">58.5</span>   <span class="number">18.5</span>  <span class="number">161.5</span>        |<span class="number">151.5</span>| <span class="number">41.3</span>|     <span class="number">58.5</span>| <span class="number">18.5</span>|<span class="number">161.5</span>|</span><br><span class="line">                                                +-----+-----+---------+-----+-----+</span><br><span class="line">                                                only showing top <span class="number">4</span> rows</span><br></pre></td></tr></table></figure><h3 id="5-3-12-连接"><a href="#5-3-12-连接" class="headerlink" title="5.3.12. 连接"></a>5.3.12. 连接</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">leftp = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                    <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>],</span><br><span class="line">                    <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                    index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">rightp = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A6'</span>, <span class="string">'A7'</span>],</span><br><span class="line">                       <span class="string">'F'</span>: [<span class="string">'B4'</span>, <span class="string">'B5'</span>, <span class="string">'B6'</span>, <span class="string">'B7'</span>],</span><br><span class="line">                       <span class="string">'G'</span>: [<span class="string">'C4'</span>, <span class="string">'C5'</span>, <span class="string">'C6'</span>, <span class="string">'C7'</span>],</span><br><span class="line">                       <span class="string">'H'</span>: [<span class="string">'D4'</span>, <span class="string">'D5'</span>, <span class="string">'D6'</span>, <span class="string">'D7'</span>]&#125;,</span><br><span class="line">                       index=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">lefts = spark.createDataFrame(leftp)</span><br><span class="line">rights = spark.createDataFrame(rightp)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D                   A   F   G   H</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0               <span class="number">4</span>  A0  B4  C4  D4</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1               <span class="number">5</span>  A1  B5  C5  D5</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2               <span class="number">6</span>  A6  B6  C6  D6</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3               <span class="number">7</span>  A7  B7  C7  D7</span><br></pre></td></tr></table></figure><p><strong>左连接</strong></p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftp.merge(rightp,on=<span class="string">'A'</span>,how=<span class="string">'left'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lefts.join(rights,on=<span class="string">'A'</span>,how=<span class="string">'left'</span>)</span><br><span class="line">     .orderBy(<span class="string">'A'</span>,ascending=<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        +---+---+---+---+----+----+----+</span><br><span class="line">                                        |  A|  B|  C|  D|   F|   G|   H|</span><br><span class="line">    A   B   C   D    F    G    H        +---+---+---+---+----+----+----+</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0   B4   C4   D4        | A0| B0| C0| D0|  B4|  C4|  D4|</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1   B5   C5   D5        | A1| B1| C1| D1|  B5|  C5|  D5|</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2  NaN  NaN  NaN        | A2| B2| C2| D2|null|null|null|</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3  NaN  NaN  NaN        | A3| B3| C3| D3|null|null|null|</span><br><span class="line">                                        +---+---+---+---+----+----+----+</span><br></pre></td></tr></table></figure><p><strong>右连接</strong></p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftp.merge(rightp,on=<span class="string">'A'</span>,how=<span class="string">'right'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lefts.join(rights,on=<span class="string">'A'</span>,how=<span class="string">'right'</span>)</span><br><span class="line">     .orderBy(<span class="string">'A'</span>,ascending=<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                        +---+----+----+----+---+---+---+</span><br><span class="line">                                        |  A|   B|   C|   D|  F|  G|  H|</span><br><span class="line">    A    B    C    D   F   G   H        +---+----+----+----+---+---+---+</span><br><span class="line"><span class="number">0</span>  A0   B0   C0   D0  B4  C4  D4        | A0|  B0|  C0|  D0| B4| C4| D4|</span><br><span class="line"><span class="number">1</span>  A1   B1   C1   D1  B5  C5  D5        | A1|  B1|  C1|  D1| B5| C5| D5|</span><br><span class="line"><span class="number">2</span>  A6  NaN  NaN  NaN  B6  C6  D6        | A6|null|null|null| B6| C6| D6|</span><br><span class="line"><span class="number">3</span>  A7  NaN  NaN  NaN  B7  C7  D7        | A7|null|null|null| B7| C7| D7|</span><br><span class="line">                                        +---+----+----+----+---+---+---+</span><br></pre></td></tr></table></figure><p><strong>内连接</strong></p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftp.merge(rightp,on=<span class="string">'A'</span>,how=<span class="string">'inner'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lefts.join(rights,on=<span class="string">'A'</span>,how=<span class="string">'inner'</span>)</span><br><span class="line">     .orderBy(<span class="string">'A'</span>,ascending=<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                                +---+---+---+---+---+---+---+</span><br><span class="line">                                |  A|  B|  C|  D|  F|  G|  H|</span><br><span class="line">    A   B   C   D   F   G   H   +---+---+---+---+---+---+---+</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0  B4  C4  D4   | A0| B0| C0| D0| B4| C4| D4|</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1  B5  C5  D5   | A1| B1| C1| D1| B5| C5| D5|</span><br><span class="line">                                +---+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure><p><strong>全连接</strong></p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftp.merge(rightp,on=<span class="string">'A'</span>,how=<span class="string">'full'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lefts.join(rights,on=<span class="string">'A'</span>,how=<span class="string">'full'</span>)</span><br><span class="line">     .orderBy(<span class="string">'A'</span>,ascending=<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                        +---+----+----+----+----+----+----+</span><br><span class="line">                                        |  A|   B|   C|   D|   F|   G|   H|</span><br><span class="line">    A    B    C    D    F    G    H     +---+----+----+----+----+----+----+</span><br><span class="line"><span class="number">0</span>  A0   B0   C0   D0   B4   C4   D4     | A0|  B0|  C0|  D0|  B4|  C4|  D4|</span><br><span class="line"><span class="number">1</span>  A1   B1   C1   D1   B5   C5   D5     | A1|  B1|  C1|  D1|  B5|  C5|  D5|</span><br><span class="line"><span class="number">2</span>  A2   B2   C2   D2  NaN  NaN  NaN     | A2|  B2|  C2|  D2|null|null|null|</span><br><span class="line"><span class="number">3</span>  A3   B3   C3   D3  NaN  NaN  NaN     | A3|  B3|  C3|  D3|null|null|null|</span><br><span class="line"><span class="number">4</span>  A6  NaN  NaN  NaN   B6   C6   D6     | A6|null|null|null|  B6|  C6|  D6|</span><br><span class="line"><span class="number">5</span>  A7  NaN  NaN  NaN   B7   C7   D7     | A7|null|null|null|  B7|  C7|  D7|</span><br><span class="line">                                        +---+----+----+----+----+----+----+</span><br></pre></td></tr></table></figure><h3 id="5-3-13-连接列"><a href="#5-3-13-连接列" class="headerlink" title="5.3.13. 连接列"></a>5.3.13. 连接列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [(<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">           (<span class="string">'b'</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">           (<span class="string">'c'</span>, <span class="number">8</span>, <span class="number">9</span>),</span><br><span class="line">           (<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">           (<span class="string">'b'</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">           (<span class="string">'c'</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">col_name = [<span class="string">'col1'</span>, <span class="string">'col2'</span>, <span class="string">'col3'</span>]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">dp = pd.DataFrame(my_list,columns=col_name)</span><br><span class="line">ds = spark.createDataFrame(my_list,schema=col_name)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  col1  col2  col3</span><br><span class="line"><span class="number">0</span>    a     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"><span class="number">1</span>    b     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"><span class="number">2</span>    c     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"><span class="number">3</span>    a     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    b     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>    c     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'concat'</span>] = dp.apply(<span class="keyword">lambda</span> x:<span class="string">'%s%s'</span>%(x[<span class="string">'col1'</span>],x[<span class="string">'col2'</span>]),axis=<span class="number">1</span>)</span><br><span class="line">dp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.withColumn(<span class="string">'concat'</span>,F.concat(<span class="string">'col1'</span>,<span class="string">'col2'</span>)).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                        +----+----+----+------+</span><br><span class="line">                                        |col1|col2|col3|concat|</span><br><span class="line">  col1  col2  col3 concat               +----+----+----+------+</span><br><span class="line"><span class="number">0</span>    a     <span class="number">2</span>     <span class="number">3</span>     a2               |   a|   <span class="number">2</span>|   <span class="number">3</span>|    a2|</span><br><span class="line"><span class="number">1</span>    b     <span class="number">5</span>     <span class="number">6</span>     b5               |   b|   <span class="number">5</span>|   <span class="number">6</span>|    b5|</span><br><span class="line"><span class="number">2</span>    c     <span class="number">8</span>     <span class="number">9</span>     c8               |   c|   <span class="number">8</span>|   <span class="number">9</span>|    c8|</span><br><span class="line"><span class="number">3</span>    a     <span class="number">2</span>     <span class="number">3</span>     a2               |   a|   <span class="number">2</span>|   <span class="number">3</span>|    a2|</span><br><span class="line"><span class="number">4</span>    b     <span class="number">5</span>     <span class="number">6</span>     b5               |   b|   <span class="number">5</span>|   <span class="number">6</span>|    b5|</span><br><span class="line"><span class="number">5</span>    c     <span class="number">8</span>     <span class="number">9</span>     c8               |   c|   <span class="number">8</span>|   <span class="number">9</span>|    c8|</span><br><span class="line">                                        +----+----+----+------+</span><br></pre></td></tr></table></figure><h3 id="5-3-14-分组"><a href="#5-3-14-分组" class="headerlink" title="5.3.14. 分组"></a>5.3.14. 分组</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp.groupby([<span class="string">'col1'</span>]).agg(&#123;<span class="string">'col2'</span>:<span class="string">'min'</span>,<span class="string">'col3'</span>:<span class="string">'mean'</span>&#125;)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.groupBy([<span class="string">'col1'</span>]).agg(&#123;<span class="string">'col2'</span>: <span class="string">'min'</span>, <span class="string">'col3'</span>: <span class="string">'avg'</span>&#125;).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                        +----+---------+---------+</span><br><span class="line">      col2  col3                        |col1|min(col2)|avg(col3)|</span><br><span class="line">col1                                    +----+---------+---------+</span><br><span class="line">a        <span class="number">2</span>     <span class="number">3</span>                        |   c|        <span class="number">8</span>|      <span class="number">9.0</span>|</span><br><span class="line">b        <span class="number">5</span>     <span class="number">6</span>                        |   b|        <span class="number">5</span>|      <span class="number">6.0</span>|</span><br><span class="line">c        <span class="number">8</span>     <span class="number">9</span>                        |   a|        <span class="number">2</span>|      <span class="number">3.0</span>|</span><br><span class="line">                                        +----+---------+---------+</span><br></pre></td></tr></table></figure><h3 id="5-3-15-透视"><a href="#5-3-15-透视" class="headerlink" title="5.3.15. 透视"></a>5.3.15. 透视</h3><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.pivot_table(dp, values=<span class="string">'col3'</span>, index=<span class="string">'col1'</span>, columns=<span class="string">'col2'</span>, aggfunc=np.sum)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ds.groupBy([<span class="string">'col1'</span>]).pivot(<span class="string">'col2'</span>).sum(<span class="string">'col3'</span>).show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                +----+----+----+----+</span><br><span class="line">col2    <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>           |col1|   <span class="number">2</span>|   <span class="number">5</span>|   <span class="number">8</span>|</span><br><span class="line">col1                            +----+----+----+----+</span><br><span class="line">a     <span class="number">6.0</span>   NaN   NaN           |   c|null|null|  <span class="number">18</span>|</span><br><span class="line">b     NaN  <span class="number">12.0</span>   NaN           |   b|null|  <span class="number">12</span>|null|</span><br><span class="line">c     NaN   NaN  <span class="number">18.0</span>           |   a|   <span class="number">6</span>|null|null|</span><br><span class="line">                                +----+----+----+----+</span><br></pre></td></tr></table></figure><h3 id="5-3-16-窗口"><a href="#5-3-16-窗口" class="headerlink" title="5.3.16. 窗口"></a>5.3.16. 窗口</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'A'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],<span class="string">'B'</span>:[<span class="string">'m'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'n'</span>],<span class="string">'C'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]&#125;</span><br><span class="line">dp = pd.DataFrame(d)</span><br><span class="line">ds = spark.createDataFrame(dp)</span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'rank'</span>] = dp.groupby(<span class="string">'B'</span>)[<span class="string">'C'</span>].rank(<span class="string">'dense'</span>,ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line">w = Window.partitionBy(<span class="string">'B'</span>).orderBy(ds.C.desc())</span><br><span class="line">ds = ds.withColumn(<span class="string">'rank'</span>,F.rank().over(w))</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                        +---+---+---+----+</span><br><span class="line">                        |  A|  B|  C|rank|</span><br><span class="line">   A  B  C  rank        +---+---+---+----+</span><br><span class="line"><span class="number">0</span>  a  m  <span class="number">1</span>   <span class="number">2.0</span>        |  b|  m|  <span class="number">2</span>|   <span class="number">1</span>|</span><br><span class="line"><span class="number">1</span>  b  m  <span class="number">2</span>   <span class="number">1.0</span>        |  a|  m|  <span class="number">1</span>|   <span class="number">2</span>|</span><br><span class="line"><span class="number">2</span>  c  n  <span class="number">3</span>   <span class="number">2.0</span>        |  d|  n|  <span class="number">6</span>|   <span class="number">1</span>|</span><br><span class="line"><span class="number">3</span>  d  n  <span class="number">6</span>   <span class="number">1.0</span>        |  c|  n|  <span class="number">3</span>|   <span class="number">2</span>|</span><br><span class="line">                        +---+---+---+----+</span><br></pre></td></tr></table></figure><h3 id="5-3-17-rank-VS-dense-rank"><a href="#5-3-17-rank-VS-dense-rank" class="headerlink" title="5.3.17. rank VS dense_rank"></a>5.3.17. <code>rank</code> VS <code>dense_rank</code></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d =&#123;<span class="string">'Id'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    <span class="string">'Score'</span>: [<span class="number">4.00</span>, <span class="number">4.00</span>, <span class="number">3.85</span>, <span class="number">3.65</span>, <span class="number">3.65</span>, <span class="number">3.50</span>]&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">data = pd.DataFrame(d)</span><br><span class="line">dp = data.copy()</span><br><span class="line">ds = spark.createDataFrame(data)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   Id  Score</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">4.00</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">4.00</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   <span class="number">3.85</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">3.65</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">3.65</span></span><br><span class="line"><span class="number">5</span>   <span class="number">6</span>   <span class="number">3.50</span></span><br></pre></td></tr></table></figure><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">'Rank_dense'</span>] = dp[<span class="string">'Score'</span>].rank(method=<span class="string">'dense'</span>,ascending =<span class="literal">False</span>)</span><br><span class="line">dp[<span class="string">'Rank'</span>] = dp[<span class="string">'Score'</span>].rank(method=<span class="string">'min'</span>,ascending =<span class="literal">False</span>)</span><br><span class="line">dp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line">w = Window.orderBy(ds.Score.desc())</span><br><span class="line">ds = ds.withColumn(<span class="string">'Rank_spark_dense'</span>,F.dense_rank().over(w))</span><br><span class="line">ds = ds.withColumn(<span class="string">'Rank_spark'</span>,F.rank().over(w))</span><br><span class="line">ds.show()</span><br></pre></td></tr></table></figure><p>比较：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                +---+-----+----------------+----------+</span><br><span class="line">                                | Id|Score|Rank_spark_dense|Rank_spark|</span><br><span class="line">   Id  Score  Rank_dense  Rank  +---+-----+----------------+----------+</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">4.00</span>         <span class="number">1.0</span>   <span class="number">1.0</span>  |  <span class="number">1</span>|  <span class="number">4.0</span>|               <span class="number">1</span>|         <span class="number">1</span>|</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">4.00</span>         <span class="number">1.0</span>   <span class="number">1.0</span>  |  <span class="number">2</span>|  <span class="number">4.0</span>|               <span class="number">1</span>|         <span class="number">1</span>|</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   <span class="number">3.85</span>         <span class="number">2.0</span>   <span class="number">3.0</span>  |  <span class="number">3</span>| <span class="number">3.85</span>|               <span class="number">2</span>|         <span class="number">3</span>|</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">3.65</span>         <span class="number">3.0</span>   <span class="number">4.0</span>  |  <span class="number">4</span>| <span class="number">3.65</span>|               <span class="number">3</span>|         <span class="number">4</span>|</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">3.65</span>         <span class="number">3.0</span>   <span class="number">4.0</span>  |  <span class="number">5</span>| <span class="number">3.65</span>|               <span class="number">3</span>|         <span class="number">4</span>|</span><br><span class="line"><span class="number">5</span>   <span class="number">6</span>   <span class="number">3.50</span>         <span class="number">4.0</span>   <span class="number">6.0</span>  |  <span class="number">6</span>|  <span class="number">3.5</span>|               <span class="number">4</span>|         <span class="number">6</span>|</span><br><span class="line">                                +---+-----+----------------+----------+</span><br></pre></td></tr></table></figure><h1 id="6-统计与线性代数预备"><a href="#6-统计与线性代数预备" class="headerlink" title="6. 统计与线性代数预备"></a>6. 统计与线性代数预备</h1><p><strong>知彼知己，百战不殆；不知彼而知己，一胜一负；不知彼，不知己，每战必殆。</strong> – 《孙子兵法》</p><h2 id="6-1-表示法"><a href="#6-1-表示法" class="headerlink" title="6.1. 表示法"></a>6.1. 表示法</h2><ul><li>m：样本数</li><li>n：特征数</li><li><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/8f58cf98a539286a53e41582f194fbed.jpg" alt="y_i">：第<code>i</code>个标签</li><li><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/585d98b9749f0661bc9077e01f28eb15.jpg" alt="\hat{y}_i">：第<code>i</code>个预测标签</li><li><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/791424a3e5f6e2f4372471d96e5b4676.jpg" alt="{\displaystyle {\bar {\y}}} = {\frac {1}{m}}\sum _{i=1}^{m}y_{i}">：<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/afa87c5126806e604709f243ab72848b.jpg" alt="\y"> 的均值</li><li><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/afa87c5126806e604709f243ab72848b.jpg" alt="\y">：标签向量</li><li><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/bab25b7785bf747bc1caa1442874df74.jpg" alt="\hat{\y}">：预测标签向量</li></ul><h2 id="6-2-线性代数预备"><a href="#6-2-线性代数预备" class="headerlink" title="6.2. 线性代数预备"></a>6.2. 线性代数预备</h2><p>由于我在我的数值分析考试笔记中记录了线性代数预备，有兴趣的读者可以参考 <a href="reference.html#feng2014">[Feng2014]</a>了解更多细节。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/linear_algebra.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/linear_algebra.png"></p><p>线性代数预备</p><h2 id="6-3-测量公式"><a href="#6-3-测量公式" class="headerlink" title="6.3. 测量公式"></a>6.3. 测量公式</h2><h3 id="6-3-1-平均绝对误差"><a href="#6-3-1-平均绝对误差" class="headerlink" title="6.3.1. 平均绝对误差"></a>6.3.1. 平均绝对误差</h3><p>在统计学中，<strong>MAE</strong>（<a href="https://en.wikipedia.org/wiki/Mean_absolute_error" target="_blank" rel="noopener">平均绝对误差</a>）衡量两个连续变量间的差异。 平均绝对误差由下式给出：</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/61bccf1d55cc6636fce9585573c9981a.jpg" alt="{\displaystyle \mathrm {MAE} ={\frac{1}{m} {\sum _{i=1}^{m}\left|\hat{y}_i-y_i\right|}}.}"></p><h3 id="6-3-2-均方误差"><a href="#6-3-2-均方误差" class="headerlink" title="6.3.2. 均方误差"></a>6.3.2. 均方误差</h3><p>在统计中，估计器（估计未观测量的过程）的 <strong>MSE</strong>（<a href="https://en.wikipedia.org/wiki/Mean_squared_error" target="_blank" rel="noopener">均方误差</a>）测量了误差或偏差的平方的平均值 - 即估计器与被估计值之间的差异。</p><p><img src="img/3152173a8fd696819c7a2c2b8c6ef005.jpg" alt="\text{MSE}=\frac{1}{m}\sum_{i=1}^m\left(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/3152173a8fd696819c7a2c2b8c6ef005.jpg)^2"></p><h3 id="6-3-3-均方根误差"><a href="#6-3-3-均方根误差" class="headerlink" title="6.3.3. 均方根误差"></a>6.3.3. 均方根误差</h3><p><img src="img/c8a2ccec457f128649ad30a2ba066a48.jpg" alt="\text{RMSE} = \sqrt{\text{MSE}}=\sqrt{\frac{1}{m}\sum_{i=1}^m\left(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/c8a2ccec457f128649ad30a2ba066a48.jpg)^2}"></p><h3 id="6-3-4-总体平方和"><a href="#6-3-4-总体平方和" class="headerlink" title="6.3.4. 总体平方和"></a>6.3.4. 总体平方和</h3><p>在统计数据分析中，<strong>TSS</strong>（<a href="https://en.wikipedia.org/wiki/Total_sum_of_squares" target="_blank" rel="noopener">总体平方和</a>）是一个数量，作为呈现此类分析结果的标准方式的一部分。 它被定义为在所有观察中，每个观测值与总体平均值的平方差的总和。</p><p><img src="img/16fd7a4c078cf22fee09b636dc10d55c.jpg" alt="\text{TSS} =  \sum_{i=1}^m\left(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/16fd7a4c078cf22fee09b636dc10d55c.jpg)^2"></p><h3 id="6-3-5-解释平方和"><a href="#6-3-5-解释平方和" class="headerlink" title="6.3.5. 解释平方和"></a>6.3.5. 解释平方和</h3><p>在统计学中，<strong>ESS</strong>（<a href="https://en.wikipedia.org/wiki/Explained_sum_of_squares" target="_blank" rel="noopener">解释平方和</a>），或者称为模型平方和或回归平方和。</p><p>ESS 是预测值和响应变量的均值的差的平方和，由下式给出：</p><p><img src="img/8dc8e70e19ec4318b12b16f1c5bdb879.jpg" alt="\text{ESS}= \sum_{i=1}^m\left(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/8dc8e70e19ec4318b12b16f1c5bdb879.jpg)^2"></p><h3 id="6-3-6-残差平方和"><a href="#6-3-6-残差平方和" class="headerlink" title="6.3.6. 残差平方和"></a>6.3.6. 残差平方和</h3><p>在统计中，<strong>RSS/SSR</strong>（<a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares" target="_blank" rel="noopener">残差平方和</a>），也称为预测误差平方和 预测（SSE），由下式给出：</p><p><img src="img/95594348fc6d49d2819be3d412a27e55.jpg" alt="\text{RSS}= \sum_{i=1}^m\left(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/95594348fc6d49d2819be3d412a27e55.jpg)^2"></p><h3 id="6-3-7-判定系数"><a href="#6-3-7-判定系数" class="headerlink" title="6.3.7. 判定系数 "></a>6.3.7. 判定系数 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1ac835166928f502b55a31636602602a.jpg" alt="R^2"></h3><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/fef76f108c095f250d8e9efb4cfcb710.jpg" alt="R^{2} := \frac{ESS}{TSS} = 1-{\text{RSS} \over \text{TSS}}.\,"></p><blockquote><p>注意</p><p>一般来说，(<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/b288f19072faa2f8f373d5a8910c080b.jpg" alt="\y^{T}{\bar {\y}}={\hat {\y}}^{T}{\bar {\y}}">)，总体平方和，等于解释平方和加上残差平方和，也就是：</p></blockquote><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/4a1a112aa8490f7c8410b710845e8c7a.jpg" alt="\text{TSS} = \text{ESS} + \text{RSS} \text{ if and only if } {\displaystyle \y^{T}{\bar {\y}}={\hat {\y}}^{T}{\bar {\y}}}."></p><p>更多细节可以在<a href="https://en.wikipedia.org/wiki/Explained_sum_of_squares" target="_blank" rel="noopener">普通最小二乘模型中的分区</a>中找到。</p><h2 id="6-4-混淆矩阵"><a href="#6-4-混淆矩阵" class="headerlink" title="6.4. 混淆矩阵"></a>6.4. 混淆矩阵</h2><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/confusion_matrix.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/confusion_matrix.png"></p><p>混淆矩阵</p><h3 id="6-4-1-召回率"><a href="#6-4-1-召回率" class="headerlink" title="6.4.1. 召回率"></a>6.4.1. 召回率</h3><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/3f26c9365c0603f014f3bba403ed27fb.jpg" alt="\text{Recall}=\frac{\text{TP}}{\text{TP+FN}}"></p><h3 id="6-4-2-精确率"><a href="#6-4-2-精确率" class="headerlink" title="6.4.2. 精确率"></a>6.4.2. 精确率</h3><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1a8a8647a66b744ccd5c9137adb66255.jpg" alt="\text{Precision}=\frac{\text{TP}}{\text{TP+FP}}"></p><h3 id="6-4-3-准确率"><a href="#6-4-3-准确率" class="headerlink" title="6.4.3. 准确率"></a>6.4.3. 准确率</h3><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/5a13655c0030372e1b06cd77ff1e53e0.jpg" alt="\text{Accuracy }=\frac{\text{TP+TN}}{\text{Total}}"></p><h3 id="6-4-4-F1-得分"><a href="#6-4-4-F1-得分" class="headerlink" title="6.4.4. F1 得分"></a>6.4.4. F1 得分</h3><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1cef776388e6c2cba3cf00cab2199e3d.jpg" alt="\text{F}_1=\frac{2*\text{Recall}*\text{Precision}}{\text{Recall}+ \text{Precision}}"></p><h2 id="6-5-统计检验"><a href="#6-5-统计检验" class="headerlink" title="6.5. 统计检验"></a>6.5. 统计检验</h2><h3 id="6-5-1-互相关检验"><a href="#6-5-1-互相关检验" class="headerlink" title="6.5.1. 互相关检验"></a>6.5.1. 互相关检验</h3><ul><li>Pearson 互相关: 检验两个连续变量之间的相关度。</li><li>Spearman 互相关: 检验两个序数变量之间的相关度（不依赖于正态分布数据的假设）。</li><li>卡方: 检验两个类别变量之间的相关度。</li></ul><h3 id="6-5-2-均值检验的比较"><a href="#6-5-2-均值检验的比较" class="headerlink" title="6.5.2. 均值检验的比较"></a>6.5.2. 均值检验的比较</h3><ul><li>配对 T 检验: 检验两个相关变量之间的差异</li><li>独立 T 检验: 检验两个独立变量之间的差异</li><li>ANOVA: 在考虑结果变量中的任何其他变化之后，检验组均值之间的差异。</li></ul><h3 id="6-5-3-非配对检验"><a href="#6-5-3-非配对检验" class="headerlink" title="6.5.3. 非配对检验"></a>6.5.3. 非配对检验</h3><ul><li>Wilcoxon 秩和检验: 检验两个独立变量之间的差异 - 考虑差异的大小和方向。</li><li>Wilcoxon 符号秩检验: 检验两个相关变量之间的差异 - 考虑差异的大小和方向。</li><li>符号检验: 检验两个相关变量是否不同 - 忽略变化大小，仅考虑方向。</li></ul><h1 id="7-数据探索"><a href="#7-数据探索" class="headerlink" title="7. 数据探索"></a>7. 数据探索</h1><p><strong>千里之行，始于足下。</strong> – 《老子》</p><p>我不是说，理解你的数据集是数据科学中最困难的事情，但它非常重要且耗时。 数据探索是通过统计和可视化技术来描述数据。 我们探索数据来了解特征并将其带到我们的模型。</p><h2 id="7-1-单变量分析"><a href="#7-1-单变量分析" class="headerlink" title="7.1. 单变量分析"></a>7.1. 单变量分析</h2><p>在数学中，单变量是指仅含一个变量的表达式，方程式，函数或多项式。 “Uni”表示“一个”，换句话说，您的数据只有一个变量。 因此，您无需在此步骤中处理原因或关系。单变量分析获取数据，逐个汇总变量（属性）并发现数据中的模式。</p><p>单变量数据中发现的模式可以通过多种方式描述，包括集中趋势（均值，众数和中值）和离散度：极差，方差，最大值，最小值，四分位数（包括四分位数极差），方差和标准差。 您还可以使用多个选项来视化和描述单变量数据。 如<code>频率分布表</code>，<code>条形图</code>，<code>直方图</code>，<code>频率多边形</code>，<code>扇形图</code>。</p><p>变量可以是分类变量或数值变量，我将演示不同的统计和可视化技术来研究变量的每种类型。</p><ul><li>Jupyter 笔记本可以从<a href="_static/Data_exploration.ipynb">数据探索</a>下载。</li><li>数据可以从 <a href="_static/german_credit.csv">German Credit</a> 下载。</li></ul><h3 id="7-1-1-数值变量"><a href="#7-1-1-数值变量" class="headerlink" title="7.1.1. 数值变量"></a>7.1.1. 数值变量</h3><p><strong>描述</strong></p><p><code>pandas</code>和<code>spark</code>中的<code>describe</code>函数将给出大部分统计结果，例如最小值，中值，最大值，四分位数和标准差。 借助用户定义的函数，您可以获得更多的统计结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为选择要展示的变量</span></span><br><span class="line">num_cols = [<span class="string">'Account Balance'</span>,<span class="string">'No of dependents'</span>]</span><br><span class="line">df.select(num_cols).describe().show()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------------+-------------------+</span><br><span class="line">|summary|   Account Balance|   No of dependents|</span><br><span class="line">+-------+------------------+-------------------+</span><br><span class="line">|  count|              <span class="number">1000</span>|               <span class="number">1000</span>|</span><br><span class="line">|   mean|             <span class="number">2.577</span>|              <span class="number">1.155</span>|</span><br><span class="line">| stddev|<span class="number">1.2576377271108936</span>|<span class="number">0.36208577175319395</span>|</span><br><span class="line">|    min|                 <span class="number">1</span>|                  <span class="number">1</span>|</span><br><span class="line">|    max|                 <span class="number">4</span>|                  <span class="number">2</span>|</span><br><span class="line">+-------+------------------+-------------------+</span><br></pre></td></tr></table></figure><p>您可能会发现 PySpark 中的默认函数不包含四分位数。 以下函数将帮助您在 Pandas 中获得相同的结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pd</span><span class="params">(df_in, columns, deciles=False)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Function to union the basic stats results and deciles</span></span><br><span class="line"><span class="string">    :param df_in: the input dataframe</span></span><br><span class="line"><span class="string">    :param columns: the cloumn name list of the numerical variable</span></span><br><span class="line"><span class="string">    :param deciles: the deciles output</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return : the numerical describe info. of the input dataframe</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :author: Ming Chen and Wenqiang Feng</span></span><br><span class="line"><span class="string">    :email:  von198@gmail.com</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> deciles:</span><br><span class="line">        percentiles = np.array(range(<span class="number">0</span>, <span class="number">110</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        percentiles = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>]</span><br><span class="line"></span><br><span class="line">    percs = np.transpose([np.percentile(df_in.select(x).collect(), percentiles) <span class="keyword">for</span> x <span class="keyword">in</span> columns])</span><br><span class="line">    percs = pd.DataFrame(percs, columns=columns)</span><br><span class="line">    percs[<span class="string">'summary'</span>] = [str(p) + <span class="string">'%'</span> <span class="keyword">for</span> p <span class="keyword">in</span> percentiles]</span><br><span class="line"></span><br><span class="line">    spark_describe = df_in.describe().toPandas()</span><br><span class="line">    new_df = pd.concat([spark_describe, percs],ignore_index=<span class="literal">True</span>)</span><br><span class="line">    new_df = new_df.round(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_df[[<span class="string">'summary'</span>] + columns]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe_pd(df,num_cols)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------------+-----------------+</span><br><span class="line">|summary|   Account Balance| No of dependents|</span><br><span class="line">+-------+------------------+-----------------+</span><br><span class="line">|  count|            <span class="number">1000.0</span>|           <span class="number">1000.0</span>|</span><br><span class="line">|   mean|             <span class="number">2.577</span>|            <span class="number">1.155</span>|</span><br><span class="line">| stddev|<span class="number">1.2576377271108936</span>|<span class="number">0.362085771753194</span>|</span><br><span class="line">|    min|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    max|               <span class="number">4.0</span>|              <span class="number">2.0</span>|</span><br><span class="line">|    <span class="number">25</span>%|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">50</span>%|               <span class="number">2.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">75</span>%|               <span class="number">4.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">+-------+------------------+-----------------+</span><br></pre></td></tr></table></figure><p>有时，由于机密数据问题，您无法提供真实数据，您的客户可能会请求更多统计结果，例如“十分位数”。 您可以应用以下函数来实现它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe_pd(df,num_cols,deciles=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------------+-----------------+</span><br><span class="line">|summary|   Account Balance| No of dependents|</span><br><span class="line">+-------+------------------+-----------------+</span><br><span class="line">|  count|            <span class="number">1000.0</span>|           <span class="number">1000.0</span>|</span><br><span class="line">|   mean|             <span class="number">2.577</span>|            <span class="number">1.155</span>|</span><br><span class="line">| stddev|<span class="number">1.2576377271108936</span>|<span class="number">0.362085771753194</span>|</span><br><span class="line">|    min|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    max|               <span class="number">4.0</span>|              <span class="number">2.0</span>|</span><br><span class="line">|     <span class="number">0</span>%|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">10</span>%|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">20</span>%|               <span class="number">1.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">30</span>%|               <span class="number">2.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">40</span>%|               <span class="number">2.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">50</span>%|               <span class="number">2.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">60</span>%|               <span class="number">3.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">70</span>%|               <span class="number">4.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">80</span>%|               <span class="number">4.0</span>|              <span class="number">1.0</span>|</span><br><span class="line">|    <span class="number">90</span>%|               <span class="number">4.0</span>|              <span class="number">2.0</span>|</span><br><span class="line">|   <span class="number">100</span>%|               <span class="number">4.0</span>|              <span class="number">2.0</span>|</span><br><span class="line">+-------+------------------+-----------------+</span><br></pre></td></tr></table></figure><ul><li><p>偏度和峰度</p><p>这个小节来自维基百科<a href="https://en.wikipedia.org/wiki/Skewness" target="_blank" rel="noopener">偏度</a>。</p><p>在概率论和统计学中，偏度是实值随机变量概率分布关于其均值的不对称性的度量。 偏度值可以是正数或负数，或者是未定义的。对于单峰分布，负偏度通常表示尾部位于分布的左侧，而正偏度表示尾部位于右侧。</p><p>考虑下图中的两个分布。 在每个图中，分布右侧的值与左侧的值不同。 这些逐渐变细的一端称为尾部，它们提供了一种可视方法来确定分布中的两种偏斜中的哪一种：</p><ol><li>负偏度：左尾较长；分布的质量集中在图的右侧。尽管曲线本身看起来是向右倾斜的，但这种分布成为左倾的。左是指尾部向左侧延伸，并且通常，平均值偏向数据的典型中心的左侧。 左倾分布通常表现为右倾曲线。</li><li>正偏度：右尾更长; 分布的质量集中在图的左侧。尽管曲线本身看起来是向左倾斜的，但这种分布成为右倾的。右边是指尾部向右侧延伸，通常，平均值偏向于典型数据中心的右侧。 右倾分布通常表现为左倾曲线。</li></ol><p>这一小节来自维基百科<a href="https://en.wikipedia.org/wiki/Kurtosis" target="_blank" rel="noopener">峰度</a>。</p><p>在概率论和统计学中，峰度（kyrtos 或 kurtos，意思是“弯曲的，拱形的”）是实值随机变量的概率分布的“尾部”的度量。 与偏度概念类似，峰度描述概率分布形状，正如偏度一样，有不同的方法来量化它的理论分布，和相应的方法来估计它来自一个样本总体。</p></li></ul><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/6eb508bad184c89094f5045a5bf2e31c.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/skewed.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> col, skewness, kurtosis</span><br><span class="line">df.select(skewness(var),kurtosis(var)).show()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------------------+</span><br><span class="line">|skewness(Age (years))|kurtosis(Age (years))|</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|   <span class="number">1.0231743160548064</span>|   <span class="number">0.6114371688367672</span>|</span><br><span class="line">+---------------------+---------------------+</span><br></pre></td></tr></table></figure><blockquote><p>警告</p></blockquote><p><strong>有时统计量可能产生误导！</strong></p><p>F. J. Anscombe 曾经说到执行计算和制作图表。 应研究两种结果；每个都有助于理解。 图<a href="#fig-misleading">相同统计量的不同图表</a>（Datasaurus，和 12 个其他东西）中的这 13 个数据集各自具有相同的汇总统计量（<code>x/y</code>均值，<code>x/y</code>标准差和 Pearson 相关性），虽然外观完全不同。 这项工作描述了我们开发的技术，用于创建此数据集，以及其他类似的数据集。 更多细节和有趣的结果可以在<a href="https://www.autodeskresearch.com/publications/samestats" target="_blank" rel="noopener">相同统计量和不同图表</a>中找到。</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/misleading.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/misleading.png"></p><p>相同统计量和不同图表</p><p><strong>直方图</strong></p><blockquote><p>警告</p><p><strong>直方图经常和条形图混淆！</strong></p></blockquote><p>直方图和条形图之间的根本区别，将帮助您轻松识别两者，条形图中的条形之间存在间隙，但在直方图中，条形彼此相邻。 感兴趣的读者可以参考<a href="https://keydifferences.com/difference-between-histogram-and-bar-graph.html" target="_blank" rel="noopener">直方图和条形图之间的差异</a>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="string">'Age (years)'</span></span><br><span class="line">x = data1[var]</span><br><span class="line">bins = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment"># 数据直方图</span></span><br><span class="line">plt.hist(x, bins, alpha=<span class="number">0.8</span>, histtype=<span class="string">'bar'</span>, color=<span class="string">'gold'</span>,</span><br><span class="line">         ec=<span class="string">'black'</span>,weights=np.zeros_like(x) + <span class="number">100</span>\. / x.size)</span><br><span class="line"></span><br><span class="line">plt.xlabel(var)</span><br><span class="line">plt.ylabel(<span class="string">'percentage'</span>)</span><br><span class="line">plt.xticks(bins)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">fig.savefig(var+<span class="string">".pdf"</span>, bbox_inches=<span class="string">'tight'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/his_s.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/his_s.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="string">'Age (years)'</span></span><br><span class="line">x = data1[var]</span><br><span class="line">bins = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line">hist, bin_edges = np.histogram(x,bins,</span><br><span class="line">                               weights=np.zeros_like(x) + <span class="number">100</span>\. / x.size)</span><br><span class="line"><span class="comment"># 生成直方图</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制高度与 x 轴上的整数的直方图</span></span><br><span class="line">ax.bar(range(len(hist)),hist,width=<span class="number">1</span>,alpha=<span class="number">0.8</span>,ec =<span class="string">'black'</span>, color=<span class="string">'gold'</span>)</span><br><span class="line"><span class="comment"># 将刻度设在条形中间</span></span><br><span class="line">ax.set_xticks([<span class="number">0.5</span>+i <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)])</span><br><span class="line"><span class="comment"># 将 xticklabels 设置为一个字符串，告诉我们桶的边缘是什么</span></span><br><span class="line">labels =[<span class="string">'&#123;&#125;'</span>.format(int(bins[i+<span class="number">1</span>])) <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)]</span><br><span class="line">labels.insert(<span class="number">0</span>,<span class="string">'0'</span>)</span><br><span class="line">ax.set_xticklabels(labels)</span><br><span class="line">plt.xlabel(var)</span><br><span class="line">plt.ylabel(<span class="string">'percentage'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line">hist, bin_edges = np.histogram(x,bins) <span class="comment"># 生成直方图</span></span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 绘制高度与 x 轴上的整数的直方图</span></span><br><span class="line">ax.bar(range(len(hist)),hist,width=<span class="number">1</span>,alpha=<span class="number">0.8</span>,ec =<span class="string">'black'</span>, color=<span class="string">'gold'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将刻度设在条形中间</span></span><br><span class="line">ax.set_xticks([<span class="number">0.5</span>+i <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 xticklabels 设置为一个字符串，告诉我们桶的边缘是什么</span></span><br><span class="line">labels =[<span class="string">'&#123;&#125;'</span>.format(int(bins[i+<span class="number">1</span>])) <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)]</span><br><span class="line">labels.insert(<span class="number">0</span>,<span class="string">'0'</span>)</span><br><span class="line">ax.set_xticklabels(labels)</span><br><span class="line">plt.xlabel(var)</span><br><span class="line">plt.ylabel(<span class="string">'count'</span>)</span><br><span class="line">plt.suptitle(<span class="string">'Histogram of &#123;&#125;: Left with percentage output;Right with count output'</span></span><br><span class="line">             .format(var), size=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">fig.savefig(var+<span class="string">".pdf"</span>, bbox_inches=<span class="string">'tight'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/his_d.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/his_d.png"></p><p>有时，有些人会要求您绘制不等宽度的条形（直方图的无效参数）。 你仍然可以通过以下方法实现它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="string">'Credit Amount'</span></span><br><span class="line">plot_data = df.select(var).toPandas()</span><br><span class="line">x= plot_data[var]</span><br><span class="line"></span><br><span class="line">bins =[<span class="number">0</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">1000</span>,<span class="number">2000</span>,<span class="number">3000</span>,<span class="number">4000</span>,<span class="number">5000</span>,<span class="number">6000</span>,<span class="number">10000</span>,<span class="number">25000</span>]</span><br><span class="line"></span><br><span class="line">hist, bin_edges = np.histogram(x,bins,weights=np.zeros_like(x) + <span class="number">100</span>\. / x.size) <span class="comment"># make the histogram</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绘制高度与 x 轴上的整数的直方图</span></span><br><span class="line">ax.bar(range(len(hist)),hist,width=<span class="number">1</span>,alpha=<span class="number">0.8</span>,ec =<span class="string">'black'</span>,color = <span class="string">'gold'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将刻度设在条形中间</span></span><br><span class="line">ax.set_xticks([<span class="number">0.5</span>+i <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 xticklabels 设置为一个字符串，告诉我们桶的边缘是什么</span></span><br><span class="line"><span class="comment">#labels =['&#123;&#125;k'.format(int(bins[i+1]/1000)) for i,j in enumerate(hist)]</span></span><br><span class="line">labels =[<span class="string">'&#123;&#125;'</span>.format(bins[i+<span class="number">1</span>]) <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(hist)]</span><br><span class="line">labels.insert(<span class="number">0</span>,<span class="string">'0'</span>)</span><br><span class="line">ax.set_xticklabels(labels)</span><br><span class="line"><span class="comment">#plt.text(-0.6, -1.4,'0')</span></span><br><span class="line">plt.xlabel(var)</span><br><span class="line">plt.ylabel(<span class="string">'percentage'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/unequal.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/unequal.png"></p><p><strong>箱形图和提琴图</strong></p><p>请注意，虽然提琴图与 Tukey（1977）的箱形图密切相关，但提琴图可以显示比箱形图更多的信息。 当我们进行探索性分析时，没有样本的知识。 因此，样本分布不能假设为正态分布，并且通常当您获得大数据时，正态分布将在箱形图中显示一些溢出。</p><p>然而，对于较小的样本大小，提琴图可能会产生误导，其中即使在为标准正常数据生成时，密度图也可能显示出有趣的特征（以及其中的分组差异）。 一些作者建议样本量应大于 250（例如，<code>n&gt; 250</code>或理想情况甚至更大）。其中核密度图提供了分布的合理准确表示，可能表现诸如双峰性或其他形式的细微差别，它在箱形图中是不可见的或不太清楚。 更多细节可以在[箱形图和小提琴图的简单比较]中找到(<a href="https://figshare.com/articles/A_simple_comparison_of_box_plots_and_violin_plots/1544525)。" target="_blank" rel="noopener">https://figshare.com/articles/A_simple_comparison_of_box_plots_and_violin_plots/1544525)。</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = df.select(var).toPandas()</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax = sns.boxplot(data=x)</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax = sns.violinplot(data=x)</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/box_vio.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/box_vio.png"></p><h3 id="7-1-2-类别变量"><a href="#7-1-2-类别变量" class="headerlink" title="7.1.2. 类别变量"></a>7.1.2. 类别变量</h3><p>与数值变量相比，分类变量更容易进行探索。</p><p><strong>频率表</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> rank,sum,col</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Window</span><br><span class="line"></span><br><span class="line">window = Window.rowsBetween(Window.unboundedPreceding,Window.unboundedFollowing)</span><br><span class="line"><span class="comment"># withColumn('Percent %',F.format_string("%5.0f%%\n",col('Credit_num')*100/col('total'))).\</span></span><br><span class="line">tab = df.select([<span class="string">'age_class'</span>,<span class="string">'Credit Amount'</span>]).\</span><br><span class="line">   groupBy(<span class="string">'age_class'</span>).\</span><br><span class="line">   agg(F.count(<span class="string">'Credit Amount'</span>).alias(<span class="string">'Credit_num'</span>),</span><br><span class="line">       F.mean(<span class="string">'Credit Amount'</span>).alias(<span class="string">'Credit_avg'</span>),</span><br><span class="line">       F.min(<span class="string">'Credit Amount'</span>).alias(<span class="string">'Credit_min'</span>),</span><br><span class="line">       F.max(<span class="string">'Credit Amount'</span>).alias(<span class="string">'Credit_max'</span>)).\</span><br><span class="line">   withColumn(<span class="string">'total'</span>,sum(col(<span class="string">'Credit_num'</span>)).over(window)).\</span><br><span class="line">   withColumn(<span class="string">'Percent'</span>,col(<span class="string">'Credit_num'</span>)*<span class="number">100</span>/col(<span class="string">'total'</span>)).\</span><br><span class="line">   drop(col(<span class="string">'total'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------+----------+------------------+----------+----------+-------+</span><br><span class="line">|age_class|Credit_num|        Credit_avg|Credit_min|Credit_max|Percent|</span><br><span class="line">+---------+----------+------------------+----------+----------+-------+</span><br><span class="line">|    <span class="number">45</span><span class="number">-54</span>|       <span class="number">120</span>|<span class="number">3183.0666666666666</span>|       <span class="number">338</span>|     <span class="number">12612</span>|   <span class="number">12.0</span>|</span><br><span class="line">|      &lt;<span class="number">25</span>|       <span class="number">150</span>| <span class="number">2970.733333333333</span>|       <span class="number">276</span>|     <span class="number">15672</span>|   <span class="number">15.0</span>|</span><br><span class="line">|    <span class="number">55</span><span class="number">-64</span>|        <span class="number">56</span>| <span class="number">3493.660714285714</span>|       <span class="number">385</span>|     <span class="number">15945</span>|    <span class="number">5.6</span>|</span><br><span class="line">|    <span class="number">35</span><span class="number">-44</span>|       <span class="number">254</span>| <span class="number">3403.771653543307</span>|       <span class="number">250</span>|     <span class="number">15857</span>|   <span class="number">25.4</span>|</span><br><span class="line">|    <span class="number">25</span><span class="number">-34</span>|       <span class="number">397</span>| <span class="number">3298.823677581864</span>|       <span class="number">343</span>|     <span class="number">18424</span>|   <span class="number">39.7</span>|</span><br><span class="line">|      <span class="number">65</span>+|        <span class="number">23</span>|<span class="number">3210.1739130434785</span>|       <span class="number">571</span>|     <span class="number">14896</span>|    <span class="number">2.3</span>|</span><br><span class="line">+---------+----------+------------------+----------+----------+-------+</span><br></pre></td></tr></table></figure><p><strong>扇形图</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要绘制的数据</span></span><br><span class="line">labels = plot_data.age_class</span><br><span class="line">sizes =  plot_data.Percent</span><br><span class="line">colors = [<span class="string">'gold'</span>, <span class="string">'yellowgreen'</span>, <span class="string">'lightcoral'</span>,<span class="string">'blue'</span>, <span class="string">'lightskyblue'</span>,<span class="string">'green'</span>,<span class="string">'red'</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)  <span class="comment"># explode 1st slice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">plt.pie(sizes, explode=explode, labels=labels, colors=colors,</span><br><span class="line">        autopct=<span class="string">'%1.1f%%'</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">140</span>)</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/pie.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/pie.png"></p><p><strong>条形图</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">labels = plot_data.age_class</span><br><span class="line">missing = plot_data.Percent</span><br><span class="line">ind = [x <span class="keyword">for</span> x, _ <span class="keyword">in</span> enumerate(labels)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">plt.bar(ind, missing, width=<span class="number">0.8</span>, label=<span class="string">'missing'</span>, color=<span class="string">'gold'</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(ind, labels)</span><br><span class="line">plt.ylabel(<span class="string">"percentage"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/bar.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/bar.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">labels = [<span class="string">'missing'</span>, <span class="string">'&lt;25'</span>, <span class="string">'25-34'</span>, <span class="string">'35-44'</span>, <span class="string">'45-54'</span>,<span class="string">'55-64'</span>,<span class="string">'65+'</span>]</span><br><span class="line">missing = np.array([<span class="number">0.000095</span>, <span class="number">0.024830</span>, <span class="number">0.028665</span>, <span class="number">0.029477</span>, <span class="number">0.031918</span>,<span class="number">0.037073</span>,<span class="number">0.026699</span>])</span><br><span class="line">man = np.array([<span class="number">0.000147</span>, <span class="number">0.036311</span>, <span class="number">0.038684</span>, <span class="number">0.044761</span>, <span class="number">0.051269</span>, <span class="number">0.059542</span>, <span class="number">0.054259</span>])</span><br><span class="line">women = np.array([<span class="number">0.004035</span>, <span class="number">0.032935</span>, <span class="number">0.035351</span>, <span class="number">0.041778</span>, <span class="number">0.048437</span>, <span class="number">0.056236</span>,<span class="number">0.048091</span>])</span><br><span class="line">ind = [x <span class="keyword">for</span> x, _ <span class="keyword">in</span> enumerate(labels)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">plt.bar(ind, women, width=<span class="number">0.8</span>, label=<span class="string">'women'</span>, color=<span class="string">'gold'</span>, bottom=man+missing)</span><br><span class="line">plt.bar(ind, man, width=<span class="number">0.8</span>, label=<span class="string">'man'</span>, color=<span class="string">'silver'</span>, bottom=missing)</span><br><span class="line">plt.bar(ind, missing, width=<span class="number">0.8</span>, label=<span class="string">'missing'</span>, color=<span class="string">'#CD853F'</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(ind, labels)</span><br><span class="line">plt.ylabel(<span class="string">"percentage"</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">plt.title(<span class="string">"demo"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/stacked.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/stacked.png"></p><h2 id="7-2-多变量分析"><a href="#7-2-多变量分析" class="headerlink" title="7.2. 多变量分析"></a>7.2. 多变量分析</h2><p>在本节中，我将仅演示双变量分析。 由于多变量分析由双变量派生。</p><h3 id="7-2-1-数值-VS-数值"><a href="#7-2-1-数值-VS-数值" class="headerlink" title="7.2.1. 数值 VS 数值"></a>7.2.1. 数值 VS 数值</h3><p><strong>相关矩阵</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.mllib.stat <span class="keyword">import</span> Statistics</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">corr_data = df.select(num_cols)</span><br><span class="line"></span><br><span class="line">col_names = corr_data.columns</span><br><span class="line">features = corr_data.rdd.map(<span class="keyword">lambda</span> row: row[<span class="number">0</span>:])</span><br><span class="line">corr_mat=Statistics.corr(features, method=<span class="string">"pearson"</span>)</span><br><span class="line">corr_df = pd.DataFrame(corr_mat)</span><br><span class="line">corr_df.index, corr_df.columns = col_names, col_names</span><br><span class="line"></span><br><span class="line">print(corr_df.to_string())</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+--------------------+</span><br><span class="line">|     Account Balance|    No of dependents|</span><br><span class="line">+--------------------+--------------------+</span><br><span class="line">|                 <span class="number">1.0</span>|<span class="number">-0.01414542650320914</span>|</span><br><span class="line">|<span class="number">-0.01414542650320914</span>|                 <span class="number">1.0</span>|</span><br><span class="line">+--------------------+--------------------+</span><br></pre></td></tr></table></figure><p><strong>散点图</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set(style=<span class="string">"ticks"</span>)</span><br><span class="line"></span><br><span class="line">df = sns.load_dataset(<span class="string">"iris"</span>)</span><br><span class="line">sns.pairplot(df, hue=<span class="string">"species"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/pairplot.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/pairplot.png"></p><h3 id="7-2-2-类别-VS-类别"><a href="#7-2-2-类别-VS-类别" class="headerlink" title="7.2.2. 类别 VS 类别"></a>7.2.2. 类别 VS 类别</h3><p><strong>卡方检验</strong></p><blockquote><p>警告</p><p><code>pyspark.ml.stat</code> 只在 Spark 2.4.0 中可用。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.linalg <span class="keyword">import</span> Vectors</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.stat <span class="keyword">import</span> ChiSquareTest</span><br><span class="line"></span><br><span class="line">data = [(<span class="number">0.0</span>, Vectors.dense(<span class="number">0.5</span>, <span class="number">10.0</span>)),</span><br><span class="line">        (<span class="number">0.0</span>, Vectors.dense(<span class="number">1.5</span>, <span class="number">20.0</span>)),</span><br><span class="line">        (<span class="number">1.0</span>, Vectors.dense(<span class="number">1.5</span>, <span class="number">30.0</span>)),</span><br><span class="line">        (<span class="number">0.0</span>, Vectors.dense(<span class="number">3.5</span>, <span class="number">30.0</span>)),</span><br><span class="line">        (<span class="number">0.0</span>, Vectors.dense(<span class="number">3.5</span>, <span class="number">40.0</span>)),</span><br><span class="line">        (<span class="number">1.0</span>, Vectors.dense(<span class="number">3.5</span>, <span class="number">40.0</span>))]</span><br><span class="line">df = spark.createDataFrame(data, [<span class="string">"label"</span>, <span class="string">"features"</span>])</span><br><span class="line"></span><br><span class="line">r = ChiSquareTest.test(df, <span class="string">"features"</span>, <span class="string">"label"</span>).head()</span><br><span class="line">print(<span class="string">"pValues: "</span> + str(r.pValues))</span><br><span class="line">print(<span class="string">"degreesOfFreedom: "</span> + str(r.degreesOfFreedom))</span><br><span class="line">print(<span class="string">"statistics: "</span> + str(r.statistics))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pValues: [<span class="number">0.687289278791</span>,<span class="number">0.682270330336</span>]</span><br><span class="line">degreesOfFreedom: [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">statistics: [<span class="number">0.75</span>,<span class="number">1.5</span>]</span><br></pre></td></tr></table></figure><p><strong>交叉表</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.stat.crosstab(<span class="string">"age_class"</span>, <span class="string">"Occupation"</span>).show()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+---+---+---+---+</span><br><span class="line">|age_class_Occupation|  <span class="number">1</span>|  <span class="number">2</span>|  <span class="number">3</span>|  <span class="number">4</span>|</span><br><span class="line">+--------------------+---+---+---+---+</span><br><span class="line">|                 &lt;<span class="number">25</span>|  <span class="number">4</span>| <span class="number">34</span>|<span class="number">108</span>|  <span class="number">4</span>|</span><br><span class="line">|               <span class="number">55</span><span class="number">-64</span>|  <span class="number">1</span>| <span class="number">15</span>| <span class="number">31</span>|  <span class="number">9</span>|</span><br><span class="line">|               <span class="number">25</span><span class="number">-34</span>|  <span class="number">7</span>| <span class="number">61</span>|<span class="number">269</span>| <span class="number">60</span>|</span><br><span class="line">|               <span class="number">35</span><span class="number">-44</span>|  <span class="number">4</span>| <span class="number">58</span>|<span class="number">143</span>| <span class="number">49</span>|</span><br><span class="line">|                 <span class="number">65</span>+|  <span class="number">5</span>|  <span class="number">3</span>|  <span class="number">6</span>|  <span class="number">9</span>|</span><br><span class="line">|               <span class="number">45</span><span class="number">-54</span>|  <span class="number">1</span>| <span class="number">29</span>| <span class="number">73</span>| <span class="number">17</span>|</span><br><span class="line">+--------------------+---+---+---+---+</span><br></pre></td></tr></table></figure><p><strong>堆栈图</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">labels = [<span class="string">'missing'</span>, <span class="string">'&lt;25'</span>, <span class="string">'25-34'</span>, <span class="string">'35-44'</span>, <span class="string">'45-54'</span>,<span class="string">'55-64'</span>,<span class="string">'65+'</span>]</span><br><span class="line">missing = np.array([<span class="number">0.000095</span>, <span class="number">0.024830</span>, <span class="number">0.028665</span>, <span class="number">0.029477</span>, <span class="number">0.031918</span>,<span class="number">0.037073</span>,<span class="number">0.026699</span>])</span><br><span class="line">man = np.array([<span class="number">0.000147</span>, <span class="number">0.036311</span>, <span class="number">0.038684</span>, <span class="number">0.044761</span>, <span class="number">0.051269</span>, <span class="number">0.059542</span>, <span class="number">0.054259</span>])</span><br><span class="line">women = np.array([<span class="number">0.004035</span>, <span class="number">0.032935</span>, <span class="number">0.035351</span>, <span class="number">0.041778</span>, <span class="number">0.048437</span>, <span class="number">0.056236</span>,<span class="number">0.048091</span>])</span><br><span class="line">ind = [x <span class="keyword">for</span> x, _ <span class="keyword">in</span> enumerate(labels)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">plt.bar(ind, women, width=<span class="number">0.8</span>, label=<span class="string">'women'</span>, color=<span class="string">'gold'</span>, bottom=man+missing)</span><br><span class="line">plt.bar(ind, man, width=<span class="number">0.8</span>, label=<span class="string">'man'</span>, color=<span class="string">'silver'</span>, bottom=missing)</span><br><span class="line">plt.bar(ind, missing, width=<span class="number">0.8</span>, label=<span class="string">'missing'</span>, color=<span class="string">'#CD853F'</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(ind, labels)</span><br><span class="line">plt.ylabel(<span class="string">"percentage"</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">plt.title(<span class="string">"demo"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/stacked.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/stacked.png"></p><h1 id="8-回归"><a href="#8-回归" class="headerlink" title="8. 回归"></a>8. 回归</h1><blockquote><p><strong>千里之行，始于足下。</strong> – 《老子》</p></blockquote><p>在统计建模中，回归分析侧重于研究因变量与一个或多个自变量之间的关系。<a href="https://en.wikipedia.org/wiki/Regression_analysis" target="_blank" rel="noopener">维基百科的回归分析</a>。</p><p>在数据挖掘中，回归是一种模型，用于表示标签（或目标，它是数值变量）的值与一个或多个特征（或预测变量，它们可以是数值和分类变量）之间的关系。</p><h2 id="8-1-线性回归"><a href="#8-1-线性回归" class="headerlink" title="8.1. 线性回归"></a>8.1. 线性回归</h2><h3 id="8-1-1-简介"><a href="#8-1-1-简介" class="headerlink" title="8.1.1. 简介"></a>8.1.1. 简介</h3><p>给定数据集 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/4b454255e179a3626e205ce324184acf.jpg" alt="{\displaystyle \{\,x_{i1},\ldots ,x_{in},y_{i}\}_{i=1}^{m}}">，它包含<code>n</code>个特征（变量）和<code>m</code>个样本（数据点），在简单线性回归模型中，使用<code>j</code>个自变量建模<code>m</code>个数据点 ：<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/91d663abfef497e13ec41f9300a5c354.jpg" alt="{\displaystyle x_{ij}}">，公式由下式给出：</p><blockquote><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/59ebd939c24bf4d59d82b0daf4874daf.jpg" alt="y_i = \beta_0 + \beta_j x_{ij}, \text{where}, i= 1, \cdots m, j= 1, \cdots n."></p></blockquote><p>在矩阵表示法中，数据集写为 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/80a25ad6329d3836f4e625a1c93e7898.jpg" alt="\X = [\x_1,\cdots, \x_n]">，其中 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/c4660874124a448ac14209f4a59e367a.jpg" alt="\x_j = {\displaystyle \{x_{ij}\}_{i=1}^{m}}">，<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/82a22af158d760e46ae93ba1663a6487.jpg" alt="\y = {\displaystyle \{y_{i}\}_{i=1}^{m}}">，并且 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/fad9e18cebad821450ed0f34abdb3988.jpg" alt="\Bbeta^\top = {\displaystyle \{\beta_{j}\}_{j=1}^{n}}">。之后矩阵形式的方程写为：</p><blockquote><p>(1)<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/2d776487e1a2ee4683c3c6f51fca7e48.jpg" alt="\y = \X \Bbeta."></p></blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/fm.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/fm.png"></p><p>特征矩阵和标签</p><h3 id="8-1-2-如何求解"><a href="#8-1-2-如何求解" class="headerlink" title="8.1.2. 如何求解"></a>8.1.2. 如何求解</h3><ol><li><p>直接法 （更多信息请参考我的<a href="http://web.utk.edu/~wfeng1/doc/PrelimNum.pdf" target="_blank" rel="noopener">数值分析预备笔记</a>）。</p><ul><li><p>对于方阵或长方阵</p><ul><li>奇异值分解</li><li>格兰施密特正交化</li><li>QR 分解</li></ul></li><li><p>对于方阵</p><ul><li>LU 分解</li><li>Cholesky 分解</li><li>正则分割</li></ul></li></ul></li><li><p>迭代方法</p><ul><li><p>静态案例迭代法</p><ul><li>Jacobi 方法</li><li>Gauss-Seidel 方法</li><li>Richardson 方法</li><li>连续过度放松 (SOR) 方法</li></ul></li><li><p>动态案例迭代法</p><ul><li>Chebyshev 迭代法</li><li>最小残差法</li><li>最小修正迭代法</li><li>最速下降法</li><li>共轭梯度法</li></ul></li></ul></li></ol><h3 id="8-1-3-普通最小二乘"><a href="#8-1-3-普通最小二乘" class="headerlink" title="8.1.3. 普通最小二乘"></a>8.1.3. 普通最小二乘</h3><p>在数学中，<a href="#equation-eq-ax">（1）</a>是一个超定系统。 普通最小二乘法可用于找到超定系统的近似解。 对于系统超定系统<a href="#equation-eq-ax">（1）</a>，从问题中获得最小二乘公式</p><p>(2)<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/b8bf446d4a625497f28f2347b7ca0c92.jpg" alt="{\displaystyle \min _{\Bbeta}  ||\X \Bbeta-\y||} ,"></p><p>其解决方案可以用正规方程式编写：</p><p>(3)<img src="img/d2f9799d371fde446e6dc8292ba07393.jpg" alt="\Bbeta  = (G:/PYthonLearning/learning-pyspark-zh-master/docs/img/d2f9799d371fde446e6dc8292ba07393.jpg)^{-1}\X^T\y"></p><p>其中 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/d09c46ec94d638e4ddcecfbba1c11ea8.jpg" alt="{\displaystyle {\mathrm {T} }}"> 表示矩阵转置，假设 <img src="img/d003fed20e7f2d040ccc24412cb854d1.jpg" alt="{\displaystyle (G:/PYthonLearning/learning-pyspark-zh-master/docs/img/d003fed20e7f2d040ccc24412cb854d1.jpg)^{-1}}"> 存在（也就是假设 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/501025688da0cf9e2b3937cd7da9580d.jpg" alt="\X"> 是列满秩的）。</p><blockquote><p>注意</p><p>实际上，<a href="#equation-eq-solax">(3)</a> 可以用下面的方式导出：将 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/d142da9aae51c6d3c3c736fc82252862.jpg" alt="\X^T"> 和 <a href="#equation-eq-ax">(1)</a> 相乘，之后在之前结果的两边乘上 <img src="img/16dd8d60ea9b042c3ce0652c9f0571e8.jpg" alt="(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/16dd8d60ea9b042c3ce0652c9f0571e8.jpg)^{-1}">。你也可以对 <a href="#equation-eq-minax">(2)</a> 应用极值定理，并寻找 <a href="#equation-eq-solax">(3)</a> 的解。</p></blockquote><h3 id="8-1-4-梯度下降"><a href="#8-1-4-梯度下降" class="headerlink" title="8.1.4. 梯度下降"></a>8.1.4. 梯度下降</h3><p>让我们使用下列假设：</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/a5fda7453d5707d5e8985434c789ba48.jpg" alt="h_\Bbeta = \beta_0 + \beta_j \x_{j}, \text{where}, j= 1, \cdots n."></p><p>之后求解 <a href="#equation-eq-minax">(2)</a> 等价于最小化下面的损失函数：</p><h3 id="8-1-5-损失函数"><a href="#8-1-5-损失函数" class="headerlink" title="8.1.5. 损失函数"></a>8.1.5. 损失函数</h3><p>(4)<img src="img/77c47cf9cfec8ec740c5a18dc4386670.jpg" alt="J(G:/PYthonLearning/learning-pyspark-zh-master/docs/img/77c47cf9cfec8ec740c5a18dc4386670.jpg) = \frac{1}{2m}\sum_{i=1}^m \left( h_\Bbeta(x^{(i)})-y^{(i)}) \right)^2"></p><blockquote><p>注意</p><p>我们倾向求解 <a href="#equation-eq-lreg-cost">(4)</a> 而不是 <a href="#equation-eq-minax">(2)</a> 的原因是，<a href="#equation-eq-lreg-cost">(4)</a> 是凸的，并且属性良好，例如它是个唯一可解，对于足够小的学习率是能量稳定的。如果读者对非凸损失函数（能量）案例感兴趣，可以参考 <a href="reference.html#feng2016psd">[Feng2016PSD]</a>。</p></blockquote><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/gradient1d.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/gradient1d.png"></p><p>一维中的梯度下降</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/gradient2d.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/gradient2d.png"></p><p>二维中的梯度下降</p><h3 id="8-1-6-批量梯度下降"><a href="#8-1-6-批量梯度下降" class="headerlink" title="8.1.6. 批量梯度下降"></a>8.1.6. 批量梯度下降</h3><p>梯度下降是用于找到函数最小值的一阶迭代优化算法。 它沿着最陡峭的方向搜索，该方向由“梯度的相反数”（参见图<a href="#fig-gd1d"> 1D 中的梯度下降</a>和<a href="#fig-gd2d"> 2D 中的梯度下降</a>）和学习率（搜索步长）<img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/aef64ee73dc1b1a03a152855f685113e.jpg" alt="\ alpha"> 定义。</p><h3 id="8-1-7-随机梯度下降"><a href="#8-1-7-随机梯度下降" class="headerlink" title="8.1.7. 随机梯度下降"></a>8.1.7. 随机梯度下降</h3><h3 id="8-1-8-小批量梯度下降"><a href="#8-1-8-小批量梯度下降" class="headerlink" title="8.1.8. 小批量梯度下降"></a>8.1.8. 小批量梯度下降</h3><h3 id="8-1-9-示例"><a href="#8-1-9-示例" class="headerlink" title="8.1.9. 示例"></a>8.1.9. 示例</h3><ul><li>Jupyter 笔记本可以从<a href="_static/LinearRegression.ipynb">线性回归</a> 下载，它不使用流水线实现。</li><li>upyter 笔记本可以从<a href="_static/LinearRegressionWpipeline.ipynb">带流水线的线性回归</a>，它使用流水线实现。</li><li>我下面仅仅展示流水线风格的代码。</li><li>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.LinearRegression.html" target="_blank" rel="noopener">线性回归 API</a>。</li></ul><p>建立 spark 上下文和 SparkSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark regression example&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                       options(header=&apos;true&apos;, \</span><br><span class="line">                       inferschema=&apos;true&apos;).\</span><br><span class="line">            load(&quot;../data/Advertising.csv&quot;,header=True);</span><br></pre></td></tr></table></figure><p>检查数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><p>之后我们会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><p>您还可以从数据帧中获取统计结果（不幸的是，它仅适用于数字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe().show()</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|summary|               TV|             Radio|         Newspaper|             Sales|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|  count|              200|               200|               200|               200|</span><br><span class="line">|   mean|         147.0425|23.264000000000024|30.553999999999995|14.022500000000003|</span><br><span class="line">| stddev|85.85423631490805|14.846809176168728| 21.77862083852283| 5.217456565710477|</span><br><span class="line">|    min|              0.7|               0.0|               0.3|               1.6|</span><br><span class="line">|    max|            296.4|              49.6|             114.0|              27.0|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/ad.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/ad.png"></p><p>销售分布</p><p>将数据转换为密集向量（<strong>特征</strong>和<strong>标签</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line"># I provide two ways to build the features and labels</span><br><span class="line"></span><br><span class="line"># method 1 (good for small feature):</span><br><span class="line">#def transData(row):</span><br><span class="line">#    return Row(label=row[&quot;Sales&quot;],</span><br><span class="line">#               features=Vectors.dense([row[&quot;TV&quot;],</span><br><span class="line">#                                       row[&quot;Radio&quot;],</span><br><span class="line">#                                       row[&quot;Newspaper&quot;]]))</span><br><span class="line"></span><br><span class="line"># Method 2 (good for large features):</span><br><span class="line">def transData(data):</span><br><span class="line">return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>强烈建议您尝试使用我的<code>get_dummy</code>函数来处理数据集中的分类数据。</p></blockquote><p>监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><p>无监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">    :param df: the dataframe</span><br><span class="line">    :param categoricalCols: the name list of the categorical data</span><br><span class="line">    :param continuousCols:  the name list of the numerical data</span><br><span class="line">    :return k: feature matrix</span><br><span class="line"></span><br><span class="line">    :author: Wenqiang Feng</span><br><span class="line">    :email:  von198@gmail.com</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;)</span><br></pre></td></tr></table></figure><p>将数据集转换为数据帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed= transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+</span><br><span class="line">|         features|label|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>您会发现 Spark 中所有监督机器学习算法都基于<strong>特征</strong>和<strong>标签</strong>（Spark 中的无监督机器学习算法基于<strong>特征</strong>）。 也就是说，当您在管道架构中准备好<strong>特征</strong>和<strong>标签</strong>时，您可以使用 Spark 中的所有机器学习算法。</p></blockquote><p>处理类别变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.regression import LinearRegression</span><br><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"></span><br><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># We specify maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line"></span><br><span class="line">featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                               outputCol=&quot;indexedFeatures&quot;,\</span><br><span class="line">                               maxCategories=4).fit(transformed)</span><br><span class="line"></span><br><span class="line">data = featureIndexer.transform(transformed)</span><br></pre></td></tr></table></figure><p>现在你可以这样检查数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.show(5,True)</span><br></pre></td></tr></table></figure><p>你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|         features|label|  indexedFeatures|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|[230.1,37.8,69.2]|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4| [44.5,39.3,45.1]|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3| [17.2,45.9,69.3]|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|[151.5,41.3,58.5]|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|[180.8,10.8,58.4]|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>将数据分割为训练和测试集（留出 40% 用于测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = transformed.randomSplit([0.6, 0.4])</span><br></pre></td></tr></table></figure><p>您可以按照以下方式检查您的训练和测试数据（在我看来，在原型阶段始终跟踪您的数据总是很好）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-----+---------------+</span><br><span class="line">|       features|label|indexedFeatures|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| [4.1,11.6,5.7]|</span><br><span class="line">| [5.4,29.9,9.4]|  5.3| [5.4,29.9,9.4]|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|[7.3,28.1,41.4]|</span><br><span class="line">|[7.8,38.9,50.6]|  6.6|[7.8,38.9,50.6]|</span><br><span class="line">|  [8.6,2.1,1.0]|  4.8|  [8.6,2.1,1.0]|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|        features|label| indexedFeatures|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|  [0.7,39.6,8.7]|  1.6|  [0.7,39.6,8.7]|</span><br><span class="line">|  [8.4,27.2,2.1]|  5.7|  [8.4,27.2,2.1]|</span><br><span class="line">|[11.7,36.9,45.2]|  7.3|[11.7,36.9,45.2]|</span><br><span class="line">|[13.2,15.9,49.6]|  5.6|[13.2,15.9,49.6]|</span><br><span class="line">|[16.9,43.7,89.4]|  8.7|[16.9,43.7,89.4]|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>拟合普通最小二乘回归模型</p><p>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.LinearRegression.html" target="_blank" rel="noopener">线性回归 API</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Import LinearRegression class</span><br><span class="line">from pyspark.ml.regression import LinearRegression</span><br><span class="line"></span><br><span class="line"># Define LinearRegression algorithm</span><br><span class="line">lr = LinearRegression()</span><br></pre></td></tr></table></figure><p>流水线架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexer and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[featureIndexer, lr])</span><br><span class="line"></span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><p>模型总结</p><p>Spark 不擅长数据和模型的汇总。 我为 PySpark 中线性回归写了一个汇总函数，其格式与 <strong>R</strong> 的输出类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def modelsummary(model):</span><br><span class="line">    import numpy as np</span><br><span class="line">    print (&quot;Note: the last rows are the information for Intercept&quot;)</span><br><span class="line">    print (&quot;##&quot;,&quot;-------------------------------------------------&quot;)</span><br><span class="line">    print (&quot;##&quot;,&quot;  Estimate   |   Std.Error | t Values  |  P-value&quot;)</span><br><span class="line">    coef = np.append(list(model.coefficients),model.intercept)</span><br><span class="line">    Summary=model.summary</span><br><span class="line"></span><br><span class="line">    for i in range(len(Summary.pValues)):</span><br><span class="line">        print (&quot;##&quot;,&apos;&#123;:10.6f&#125;&apos;.format(coef[i]),\</span><br><span class="line">        &apos;&#123;:10.6f&#125;&apos;.format(Summary.coefficientStandardErrors[i]),\</span><br><span class="line">        &apos;&#123;:8.3f&#125;&apos;.format(Summary.tValues[i]),\</span><br><span class="line">        &apos;&#123;:10.6f&#125;&apos;.format(Summary.pValues[i]))</span><br><span class="line"></span><br><span class="line">    print (&quot;##&quot;,&apos;---&apos;)</span><br><span class="line">    print (&quot;##&quot;,&quot;Mean squared error: % .6f&quot; \</span><br><span class="line">           % Summary.meanSquaredError, &quot;, RMSE: % .6f&quot; \</span><br><span class="line">           % Summary.rootMeanSquaredError )</span><br><span class="line">    print (&quot;##&quot;,&quot;Multiple R-squared: %f&quot; % Summary.r2, &quot;, \</span><br><span class="line">            Total iterations: %i&quot;% Summary.totalIterations)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelsummary(model.stages[-1])</span><br></pre></td></tr></table></figure><p>你会得到以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Note: the last rows are the information for Intercept</span><br><span class="line">(&apos;##&apos;, &apos;-------------------------------------------------&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  Estimate   |   Std.Error | t Values  |  P-value&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  0.044186&apos;, &apos;  0.001663&apos;, &apos;  26.573&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  0.206311&apos;, &apos;  0.010846&apos;, &apos;  19.022&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  0.001963&apos;, &apos;  0.007467&apos;, &apos;   0.263&apos;, &apos;  0.793113&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  2.596154&apos;, &apos;  0.379550&apos;, &apos;   6.840&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;---&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;Mean squared error:  2.588230&apos;, &apos;, RMSE:  1.608798&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;Multiple R-squared: 0.911869&apos;, &apos;,             Total iterations: 1&apos;)</span><br></pre></td></tr></table></figure><p>做出预测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-----+------------------+</span><br><span class="line">|        features|label|        prediction|</span><br><span class="line">+----------------+-----+------------------+</span><br><span class="line">|  [0.7,39.6,8.7]|  1.6| 10.81405928637388|</span><br><span class="line">|  [8.4,27.2,2.1]|  5.7| 8.583086404079918|</span><br><span class="line">|[11.7,36.9,45.2]|  7.3|10.814712818232422|</span><br><span class="line">|[13.2,15.9,49.6]|  5.6| 6.557106943899219|</span><br><span class="line">|[16.9,43.7,89.4]|  8.7|12.534151375058645|</span><br><span class="line">+----------------+-----+------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>评估</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = RegressionEvaluator(labelCol=&quot;label&quot;,</span><br><span class="line">                                predictionCol=&quot;prediction&quot;,</span><br><span class="line">                                metricName=&quot;rmse&quot;)</span><br><span class="line"></span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse)</span><br></pre></td></tr></table></figure><p>最终的均方根误差（RMSE）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root Mean Squared Error (RMSE) on test data = 1.63114</span><br></pre></td></tr></table></figure><p>您还可以检查测试数据的 ![R^2](img/1ac835166928f502b55a31636602602a.jpg） 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_true = predictions.select(&quot;label&quot;).toPandas()</span><br><span class="line">y_pred = predictions.select(&quot;prediction&quot;).toPandas()</span><br><span class="line"></span><br><span class="line">import sklearn.metrics</span><br><span class="line">r2_score = sklearn.metrics.r2_score(y_true, y_pred)</span><br><span class="line">print(&apos;r2_score: &#123;0&#125;&apos;.format(r2_score))</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2_score: 0.854486655585</span><br></pre></td></tr></table></figure><blockquote><p>警告</p><p>你应该知道，模型不包含截距时，大多数软件使用不同的公式来计算 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1ac835166928f502b55a31636602602a.jpg" alt="R^2"> 值。你可以从<a href="https://stats.stackexchange.com/questions/26176/removal-of-statistically-significant-intercept-term-increases-r2-in-linear-mo" target="_blank" rel="noopener"> StackExchange 上的讨论</a>获得更多信息。</p></blockquote><h2 id="8-2-广义线性回归"><a href="#8-2-广义线性回归" class="headerlink" title="8.2. 广义线性回归"></a>8.2. 广义线性回归</h2><h3 id="8-2-1-介绍"><a href="#8-2-1-介绍" class="headerlink" title="8.2.1. 介绍"></a>8.2.1. 介绍</h3><h3 id="8-2-2-如何求解"><a href="#8-2-2-如何求解" class="headerlink" title="8.2.2. 如何求解"></a>8.2.2. 如何求解</h3><h3 id="8-2-3-示例"><a href="#8-2-3-示例" class="headerlink" title="8.2.3. 示例"></a>8.2.3. 示例</h3><ul><li>Jupyter 笔记本可以从<a href="_static/GLM.ipynb">广义线性回归</a>下载。</li><li>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.GeneralizedLinearRegression.html" target="_blank" rel="noopener">广义线性回归 API</a>。</li></ul><p>建立 spark 上下文和 SparkSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark regression example&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                       options(header=&apos;true&apos;, \</span><br><span class="line">                       inferschema=&apos;true&apos;).\</span><br><span class="line">            load(&quot;../data/Advertising.csv&quot;,header=True);</span><br></pre></td></tr></table></figure><p>查看数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><p>您还可以从数据帧中获取统计结果（不幸的是，它仅适用于数字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe().show()</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|summary|               TV|             Radio|         Newspaper|             Sales|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|  count|              200|               200|               200|               200|</span><br><span class="line">|   mean|         147.0425|23.264000000000024|30.553999999999995|14.022500000000003|</span><br><span class="line">| stddev|85.85423631490805|14.846809176168728| 21.77862083852283| 5.217456565710477|</span><br><span class="line">|    min|              0.7|               0.0|               0.3|               1.6|</span><br><span class="line">|    max|            296.4|              49.6|             114.0|              27.0|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量（<strong>特征</strong>和<strong>标签</strong>）</p><blockquote><p>注意</p></blockquote><p>强烈建议您尝试使用我的<code>get_dummy</code>函数来处理数据集中的分类数据。</p><p>监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><p>无监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">    :param df: the dataframe</span><br><span class="line">    :param categoricalCols: the name list of the categorical data</span><br><span class="line">    :param continuousCols:  the name list of the numerical data</span><br><span class="line">    :return k: feature matrix</span><br><span class="line"></span><br><span class="line">    :author: Wenqiang Feng</span><br><span class="line">    :email:  von198@gmail.com</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line"># I provide two ways to build the features and labels</span><br><span class="line"></span><br><span class="line"># method 1 (good for small feature):</span><br><span class="line">#def transData(row):</span><br><span class="line">#    return Row(label=row[&quot;Sales&quot;],</span><br><span class="line">#               features=Vectors.dense([row[&quot;TV&quot;],</span><br><span class="line">#                                       row[&quot;Radio&quot;],</span><br><span class="line">#                                       row[&quot;Newspaper&quot;]]))</span><br><span class="line"></span><br><span class="line"># Method 2 (good for large features):</span><br><span class="line">def transData(data):</span><br><span class="line">return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed= transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+</span><br><span class="line">|         features|label|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>您会发现 Spark 中所有监督机器学习算法都基于<strong>特征</strong>和<strong>标签</strong>（Spark 中的无监督机器学习算法基于<strong>特征</strong>）。 也就是说，当您在管道架构中准备好<strong>特征</strong>和<strong>标签</strong>时，您可以使用 Spark 中的所有机器学习算法。</p></blockquote><p>将数据转换为密集向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># convert the data to dense vector</span><br><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [r[-1], Vectors.dense(r[:-1])]).\</span><br><span class="line">           toDF([&apos;label&apos;,&apos;features&apos;])</span><br><span class="line"></span><br><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line">data= transData(df)</span><br><span class="line">data.show()</span><br></pre></td></tr></table></figure><p>处理类别变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.regression import LinearRegression</span><br><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"></span><br><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># We specify maxCategories so features with &gt; 4</span><br><span class="line"># distinct values are treated as continuous.</span><br><span class="line"></span><br><span class="line">featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                               outputCol=&quot;indexedFeatures&quot;,\</span><br><span class="line">                               maxCategories=4).fit(transformed)</span><br><span class="line"></span><br><span class="line">data = featureIndexer.transform(transformed)</span><br></pre></td></tr></table></figure><p>When you check you data at this point, you will get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|         features|label|  indexedFeatures|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|[230.1,37.8,69.2]|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4| [44.5,39.3,45.1]|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3| [17.2,45.9,69.3]|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|[151.5,41.3,58.5]|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|[180.8,10.8,58.4]|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>将数据分割为训练和测试集（留出 40% 用于测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = transformed.randomSplit([0.6, 0.4])</span><br></pre></td></tr></table></figure><p>您可以按照以下方式检查您的训练和测试数据（在我看来，在原型阶段始终跟踪您的数据总是很好）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-----+----------------+</span><br><span class="line">|        features|label| indexedFeatures|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|  [5.4,29.9,9.4]|  5.3|  [5.4,29.9,9.4]|</span><br><span class="line">| [7.8,38.9,50.6]|  6.6| [7.8,38.9,50.6]|</span><br><span class="line">|  [8.4,27.2,2.1]|  5.7|  [8.4,27.2,2.1]|</span><br><span class="line">| [8.7,48.9,75.0]|  7.2| [8.7,48.9,75.0]|</span><br><span class="line">|[11.7,36.9,45.2]|  7.3|[11.7,36.9,45.2]|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">|       features|label|indexedFeatures|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">| [0.7,39.6,8.7]|  1.6| [0.7,39.6,8.7]|</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| [4.1,11.6,5.7]|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|[7.3,28.1,41.4]|</span><br><span class="line">|  [8.6,2.1,1.0]|  4.8|  [8.6,2.1,1.0]|</span><br><span class="line">|[17.2,4.1,31.6]|  5.9|[17.2,4.1,31.6]|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>拟合广义线性回归模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Import LinearRegression class</span><br><span class="line">from pyspark.ml.regression import GeneralizedLinearRegression</span><br><span class="line"></span><br><span class="line"># Define LinearRegression algorithm</span><br><span class="line">glr = GeneralizedLinearRegression(family=&quot;gaussian&quot;, link=&quot;identity&quot;,\</span><br><span class="line">                                  maxIter=10, regParam=0.3)</span><br></pre></td></tr></table></figure><p>流水线架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexer and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[featureIndexer, glr])</span><br><span class="line"></span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><p>模型总结</p><p>Spark 不擅长数据和模型的汇总。 我为 PySpark 中线性回归写了一个汇总函数，其格式与 <strong>R</strong> 输出类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def modelsummary(model):</span><br><span class="line">    import numpy as np</span><br><span class="line">    print (&quot;Note: the last rows are the information for Intercept&quot;)</span><br><span class="line">    print (&quot;##&quot;,&quot;-------------------------------------------------&quot;)</span><br><span class="line">    print (&quot;##&quot;,&quot;  Estimate   |   Std.Error | t Values  |  P-value&quot;)</span><br><span class="line">    coef = np.append(list(model.coefficients),model.intercept)</span><br><span class="line">    Summary=model.summary</span><br><span class="line"></span><br><span class="line">    for i in range(len(Summary.pValues)):</span><br><span class="line">        print (&quot;##&quot;,&apos;&#123;:10.6f&#125;&apos;.format(coef[i]),\</span><br><span class="line">        &apos;&#123;:10.6f&#125;&apos;.format(Summary.coefficientStandardErrors[i]),\</span><br><span class="line">        &apos;&#123;:8.3f&#125;&apos;.format(Summary.tValues[i]),\</span><br><span class="line">        &apos;&#123;:10.6f&#125;&apos;.format(Summary.pValues[i]))</span><br><span class="line"></span><br><span class="line">    print (&quot;##&quot;,&apos;---&apos;)</span><br><span class="line">#     print (&quot;##&quot;,&quot;Mean squared error: % .6f&quot; \</span><br><span class="line">#            % Summary.meanSquaredError, &quot;, RMSE: % .6f&quot; \</span><br><span class="line">#            % Summary.rootMeanSquaredError )</span><br><span class="line">#     print (&quot;##&quot;,&quot;Multiple R-squared: %f&quot; % Summary.r2, &quot;, \</span><br><span class="line">#             Total iterations: %i&quot;% Summary.totalIterations)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelsummary(model.stages[-1])</span><br></pre></td></tr></table></figure><p>你会得到以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Note: the last rows are the information for Intercept</span><br><span class="line">(&apos;##&apos;, &apos;-------------------------------------------------&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  Estimate   |   Std.Error | t Values  |  P-value&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  0.042857&apos;, &apos;  0.001668&apos;, &apos;  25.692&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  0.199922&apos;, &apos;  0.009881&apos;, &apos;  20.232&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos; -0.001957&apos;, &apos;  0.006917&apos;, &apos;  -0.283&apos;, &apos;  0.777757&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;  3.007515&apos;, &apos;  0.406389&apos;, &apos;   7.401&apos;, &apos;  0.000000&apos;)</span><br><span class="line">(&apos;##&apos;, &apos;---&apos;)</span><br></pre></td></tr></table></figure><p>做出预测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-----+------------------+</span><br><span class="line">|       features|label|        prediction|</span><br><span class="line">+---------------+-----+------------------+</span><br><span class="line">| [0.7,39.6,8.7]|  1.6|10.937383732327625|</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| 5.491166258750164|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|   8.8571603947873|</span><br><span class="line">|  [8.6,2.1,1.0]|  4.8| 3.793966281660073|</span><br><span class="line">|[17.2,4.1,31.6]|  5.9| 4.502507124763654|</span><br><span class="line">+---------------+-----+------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>评估</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = RegressionEvaluator(labelCol=&quot;label&quot;,</span><br><span class="line">                                predictionCol=&quot;prediction&quot;,</span><br><span class="line">                                metricName=&quot;rmse&quot;)</span><br><span class="line"></span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse)</span><br></pre></td></tr></table></figure><p>最终的均方根误差（RMSE）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root Mean Squared Error (RMSE) on test data = 1.89857</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_true = predictions.select(&quot;label&quot;).toPandas()</span><br><span class="line">y_pred = predictions.select(&quot;prediction&quot;).toPandas()</span><br><span class="line"></span><br><span class="line">import sklearn.metrics</span><br><span class="line">r2_score = sklearn.metrics.r2_score(y_true, y_pred)</span><br><span class="line">print(&apos;r2_score: &#123;0&#125;&apos;.format(r2_score))</span><br></pre></td></tr></table></figure><p>之后你会得到 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1ac835166928f502b55a31636602602a.jpg" alt="R^2"> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2_score: 0.87707391843</span><br></pre></td></tr></table></figure><h2 id="8-3-决策树回归"><a href="#8-3-决策树回归" class="headerlink" title="8.3. 决策树回归"></a>8.3. 决策树回归</h2><h3 id="8-3-1-介绍"><a href="#8-3-1-介绍" class="headerlink" title="8.3.1. 介绍"></a>8.3.1. 介绍</h3><h3 id="8-3-2-如何求解"><a href="#8-3-2-如何求解" class="headerlink" title="8.3.2. 如何求解"></a>8.3.2. 如何求解</h3><h3 id="8-3-3-示例"><a href="#8-3-3-示例" class="headerlink" title="8.3.3. 示例"></a>8.3.3. 示例</h3><ul><li>Jupyter 笔记本可以从<a href="_static/DecisionTreeR.ipynb">决策树回归</a>下载。</li><li>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.DecisionTreeRegressor.html" target="_blank" rel="noopener">决策树回归 API</a>。</li></ul><p>建立 spark 上下文和 SparkSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark regression example&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                       options(header=&apos;true&apos;, \</span><br><span class="line">                       inferschema=&apos;true&apos;).\</span><br><span class="line">            load(&quot;../data/Advertising.csv&quot;,header=True);</span><br></pre></td></tr></table></figure><p>检查数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><p>您还可以从数据帧中获取统计结果（不幸的是，它仅适用于数字）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe().show()</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|summary|               TV|             Radio|         Newspaper|             Sales|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|  count|              200|               200|               200|               200|</span><br><span class="line">|   mean|         147.0425|23.264000000000024|30.553999999999995|14.022500000000003|</span><br><span class="line">| stddev|85.85423631490805|14.846809176168728| 21.77862083852283| 5.217456565710477|</span><br><span class="line">|    min|              0.7|               0.0|               0.3|               1.6|</span><br><span class="line">|    max|            296.4|              49.6|             114.0|              27.0|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量（<strong>特征</strong>和<strong>标签</strong>）</p><blockquote><p>注意</p><p>强烈建议您尝试使用我的<code>get_dummy</code>函数来处理数据集中的分类数据。</p></blockquote><p>监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><p>无监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">    :param df: the dataframe</span><br><span class="line">    :param categoricalCols: the name list of the categorical data</span><br><span class="line">    :param continuousCols:  the name list of the numerical data</span><br><span class="line">    :return k: feature matrix</span><br><span class="line"></span><br><span class="line">    :author: Wenqiang Feng</span><br><span class="line">    :email:  von198@gmail.com</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line"># I provide two ways to build the features and labels</span><br><span class="line"></span><br><span class="line"># method 1 (good for small feature):</span><br><span class="line">#def transData(row):</span><br><span class="line">#    return Row(label=row[&quot;Sales&quot;],</span><br><span class="line">#               features=Vectors.dense([row[&quot;TV&quot;],</span><br><span class="line">#                                       row[&quot;Radio&quot;],</span><br><span class="line">#                                       row[&quot;Newspaper&quot;]]))</span><br><span class="line"></span><br><span class="line"># Method 2 (good for large features):</span><br><span class="line">def transData(data):</span><br><span class="line">return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed= transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+</span><br><span class="line">|         features|label|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>您会发现 Spark 中所有监督机器学习算法都基于<strong>特征</strong>和<strong>标签</strong>（Spark 中的无监督机器学习算法基于<strong>特征</strong>）。 也就是说，当您在管道架构中准备好<strong>特征</strong>和<strong>标签</strong>时，您可以使用 Spark 中的所有机器学习算法。</p></blockquote><p>将数据转换为密集向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># convert the data to dense vector</span><br><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [r[-1], Vectors.dense(r[:-1])]).\</span><br><span class="line">           toDF([&apos;label&apos;,&apos;features&apos;])</span><br><span class="line"></span><br><span class="line">transformed = transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><p>处理类别变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.regression import LinearRegression</span><br><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"></span><br><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># We specify maxCategories so features with &gt; 4</span><br><span class="line"># distinct values are treated as continuous.</span><br><span class="line"></span><br><span class="line">featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                               outputCol=&quot;indexedFeatures&quot;,\</span><br><span class="line">                               maxCategories=4).fit(transformed)</span><br><span class="line"></span><br><span class="line">data = featureIndexer.transform(transformed)</span><br></pre></td></tr></table></figure><p>When you check you data at this point, you will get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|         features|label|  indexedFeatures|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|[230.1,37.8,69.2]|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4| [44.5,39.3,45.1]|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3| [17.2,45.9,69.3]|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|[151.5,41.3,58.5]|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|[180.8,10.8,58.4]|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>将数据分割为训练和测试集（留出 40% 用于测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = transformed.randomSplit([0.6, 0.4])</span><br></pre></td></tr></table></figure><p>您可以按照以下方式检查您的训练和测试数据（在我看来，在原型阶段始终跟踪您的数据总是很好）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><p>之后你会得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-----+---------------+</span><br><span class="line">|       features|label|indexedFeatures|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| [4.1,11.6,5.7]|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|[7.3,28.1,41.4]|</span><br><span class="line">| [8.4,27.2,2.1]|  5.7| [8.4,27.2,2.1]|</span><br><span class="line">|  [8.6,2.1,1.0]|  4.8|  [8.6,2.1,1.0]|</span><br><span class="line">|[8.7,48.9,75.0]|  7.2|[8.7,48.9,75.0]|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|        features|label| indexedFeatures|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|  [0.7,39.6,8.7]|  1.6|  [0.7,39.6,8.7]|</span><br><span class="line">|  [5.4,29.9,9.4]|  5.3|  [5.4,29.9,9.4]|</span><br><span class="line">| [7.8,38.9,50.6]|  6.6| [7.8,38.9,50.6]|</span><br><span class="line">|[17.2,45.9,69.3]|  9.3|[17.2,45.9,69.3]|</span><br><span class="line">|[18.7,12.1,23.4]|  6.7|[18.7,12.1,23.4]|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>拟合决策树回归模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.regression import DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line"># Train a DecisionTree model.</span><br><span class="line">dt = DecisionTreeRegressor(featuresCol=&quot;indexedFeatures&quot;)</span><br></pre></td></tr></table></figure><p>流水线架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexer and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[featureIndexer, dt])</span><br><span class="line"></span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><p>做出预测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+-----+----------------+</span><br><span class="line">|prediction|label|        features|</span><br><span class="line">+----------+-----+----------------+</span><br><span class="line">|       7.2|  1.6|  [0.7,39.6,8.7]|</span><br><span class="line">|       7.3|  5.3|  [5.4,29.9,9.4]|</span><br><span class="line">|       7.2|  6.6| [7.8,38.9,50.6]|</span><br><span class="line">|      8.64|  9.3|[17.2,45.9,69.3]|</span><br><span class="line">|      6.45|  6.7|[18.7,12.1,23.4]|</span><br><span class="line">+----------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>评估</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = RegressionEvaluator(labelCol=&quot;label&quot;,</span><br><span class="line">                                predictionCol=&quot;prediction&quot;,</span><br><span class="line">                                metricName=&quot;rmse&quot;)</span><br><span class="line"></span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse)</span><br></pre></td></tr></table></figure><p>最终的均方根误差（RMSE）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root Mean Squared Error (RMSE) on test data = 1.50999</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y_true = predictions.select(&quot;label&quot;).toPandas()</span><br><span class="line">y_pred = predictions.select(&quot;prediction&quot;).toPandas()</span><br><span class="line"></span><br><span class="line">import sklearn.metrics</span><br><span class="line">r2_score = sklearn.metrics.r2_score(y_true, y_pred)</span><br><span class="line">print(&apos;r2_score: &#123;0&#125;&apos;.format(r2_score))</span><br></pre></td></tr></table></figure><p>之后你会得到 <img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1ac835166928f502b55a31636602602a.jpg" alt="R^2"> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2_score: 0.911024318967</span><br></pre></td></tr></table></figure><p>你可以检查特征上的重要性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.stages[1].featureImportances</span><br></pre></td></tr></table></figure><p>您将获得每个特征的权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseVector(3, &#123;0: 0.6811, 1: 0.3187, 2: 0.0002&#125;)</span><br></pre></td></tr></table></figure><h2 id="8-4-随机森林回归"><a href="#8-4-随机森林回归" class="headerlink" title="8.4. 随机森林回归"></a>8.4. 随机森林回归</h2><h3 id="8-4-1-简介"><a href="#8-4-1-简介" class="headerlink" title="8.4.1. 简介"></a>8.4.1. 简介</h3><h3 id="8-4-2-如何求解"><a href="#8-4-2-如何求解" class="headerlink" title="8.4.2. 如何求解"></a>8.4.2. 如何求解</h3><h3 id="8-4-3-示例"><a href="#8-4-3-示例" class="headerlink" title="8.4.3. 示例"></a>8.4.3. 示例</h3><ul><li>Jupyter 笔记本可以从<a href="_static/RandomForestR.ipynb">随机森林回归</a>下载。</li><li>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.RandomForestRegressor.html" target="_blank" rel="noopener">随机森林回归 API</a>。</li></ul><p>建立 spark 上下文和 SparkSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark RandomForest Regression example&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                               options(header=&apos;true&apos;, \</span><br><span class="line">                               inferschema=&apos;true&apos;).\</span><br><span class="line">                               load(&quot;../data/Advertising.csv&quot;,header=True);</span><br><span class="line"></span><br><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.describe().show()</span><br><span class="line"></span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|summary|               TV|             Radio|         Newspaper|             Sales|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|  count|              200|               200|               200|               200|</span><br><span class="line">|   mean|         147.0425|23.264000000000024|30.553999999999995|14.022500000000003|</span><br><span class="line">| stddev|85.85423631490805|14.846809176168728| 21.77862083852283| 5.217456565710477|</span><br><span class="line">|    min|              0.7|               0.0|               0.3|               1.6|</span><br><span class="line">|    max|            296.4|              49.6|             114.0|              27.0|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量（<strong>特征</strong>和<strong>标签</strong>）</p><blockquote><p>注意</p><p>强烈建议您尝试使用我的<code>get_dummy</code>函数来处理数据集中的分类数据。</p></blockquote><p>监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><p>无监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">    :param df: the dataframe</span><br><span class="line">    :param categoricalCols: the name list of the categorical data</span><br><span class="line">    :param continuousCols:  the name list of the numerical data</span><br><span class="line">    :return k: feature matrix</span><br><span class="line"></span><br><span class="line">    :author: Wenqiang Feng</span><br><span class="line">    :email:  von198@gmail.com</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line"># convert the data to dense vector</span><br><span class="line">#def transData(row):</span><br><span class="line">#    return Row(label=row[&quot;Sales&quot;],</span><br><span class="line">#               features=Vectors.dense([row[&quot;TV&quot;],</span><br><span class="line">#                                       row[&quot;Radio&quot;],</span><br><span class="line">#                                       row[&quot;Newspaper&quot;]]))</span><br><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed= transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+</span><br><span class="line">|         features|label|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>处理类别变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.regression import LinearRegression</span><br><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"></span><br><span class="line">featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                               outputCol=&quot;indexedFeatures&quot;,\</span><br><span class="line">                               maxCategories=4).fit(transformed)</span><br><span class="line"></span><br><span class="line">data = featureIndexer.transform(transformed)</span><br><span class="line">data.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|         features|label|  indexedFeatures|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|[230.1,37.8,69.2]|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4| [44.5,39.3,45.1]|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3| [17.2,45.9,69.3]|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|[151.5,41.3,58.5]|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|[180.8,10.8,58.4]|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>将数据分割为训练和测试集（留出 40% 用于测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = data.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-----+----------------+</span><br><span class="line">|        features|label| indexedFeatures|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|  [0.7,39.6,8.7]|  1.6|  [0.7,39.6,8.7]|</span><br><span class="line">|   [8.6,2.1,1.0]|  4.8|   [8.6,2.1,1.0]|</span><br><span class="line">| [8.7,48.9,75.0]|  7.2| [8.7,48.9,75.0]|</span><br><span class="line">|[11.7,36.9,45.2]|  7.3|[11.7,36.9,45.2]|</span><br><span class="line">|[13.2,15.9,49.6]|  5.6|[13.2,15.9,49.6]|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">|       features|label|indexedFeatures|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| [4.1,11.6,5.7]|</span><br><span class="line">| [5.4,29.9,9.4]|  5.3| [5.4,29.9,9.4]|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|[7.3,28.1,41.4]|</span><br><span class="line">|[7.8,38.9,50.6]|  6.6|[7.8,38.9,50.6]|</span><br><span class="line">| [8.4,27.2,2.1]|  5.7| [8.4,27.2,2.1]|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>拟合随机森林回归模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Import LinearRegression class</span><br><span class="line">from pyspark.ml.regression import RandomForestRegressor</span><br><span class="line"></span><br><span class="line"># Define LinearRegression algorithm</span><br><span class="line">rf = RandomForestRegressor() # featuresCol=&quot;indexedFeatures&quot;,numTrees=2, maxDepth=2, seed=42</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>如果你决定使用<code>indexedFeatures</code>特征，你需要添加参数<code>featuresCol=&quot;indexedFeatures&quot;</code>。</p></blockquote><p>流水线架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexer and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[featureIndexer, rf])</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><p>做出预测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.transform(testData)</span><br><span class="line"></span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;, &quot;prediction&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-----+------------------+</span><br><span class="line">|       features|label|        prediction|</span><br><span class="line">+---------------+-----+------------------+</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| 8.155439814814816|</span><br><span class="line">| [5.4,29.9,9.4]|  5.3|10.412769901394899|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5| 12.13735648148148|</span><br><span class="line">|[7.8,38.9,50.6]|  6.6|11.321796703296704|</span><br><span class="line">| [8.4,27.2,2.1]|  5.7|12.071421957671957|</span><br><span class="line">+---------------+-----+------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>评估</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = RegressionEvaluator(</span><br><span class="line">    labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;rmse&quot;)</span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root Mean Squared Error (RMSE) on test data = 2.35912</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sklearn.metrics</span><br><span class="line">r2_score = sklearn.metrics.r2_score(y_true, y_pred)</span><br><span class="line">print(&apos;r2_score: &#123;:4.3f&#125;&apos;.format(r2_score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2_score: 0.831</span><br></pre></td></tr></table></figure><p>特征重要性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.stages[-1].featureImportances</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseVector(3, &#123;0: 0.4994, 1: 0.3196, 2: 0.181&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.stages[-1].trees</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[DecisionTreeRegressionModel (uid=dtr_c75f1c75442c) of depth 5 with 43 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_70fc2d441581) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_bc8464f545a7) of depth 5 with 31 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_a8a7e5367154) of depth 5 with 59 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_3ea01314fcbc) of depth 5 with 47 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_be9a04ac22a6) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_38610d47328a) of depth 5 with 51 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_bf14aea0ad3b) of depth 5 with 49 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_cde24ebd6bb6) of depth 5 with 39 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_a1fc9bd4fbeb) of depth 5 with 57 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_37798d6db1ba) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_c078b73ada63) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_fd00e3a070ad) of depth 5 with 55 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_9d01d5fb8604) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_8bd8bdddf642) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_e53b7bae30f8) of depth 5 with 49 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_808a869db21c) of depth 5 with 47 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_64d0916bceb0) of depth 5 with 33 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_0891055fff94) of depth 5 with 55 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_19c8bbad26c2) of depth 5 with 51 nodes]</span><br></pre></td></tr></table></figure><h2 id="8-5-梯度提升树回归"><a href="#8-5-梯度提升树回归" class="headerlink" title="8.5. 梯度提升树回归"></a>8.5. 梯度提升树回归</h2><h3 id="8-5-1-简介"><a href="#8-5-1-简介" class="headerlink" title="8.5.1. 简介"></a>8.5.1. 简介</h3><h3 id="8-5-2-如何求解"><a href="#8-5-2-如何求解" class="headerlink" title="8.5.2. 如何求解"></a>8.5.2. 如何求解</h3><h3 id="8-5-3-示例"><a href="#8-5-3-示例" class="headerlink" title="8.5.3. 示例"></a>8.5.3. 示例</h3><ul><li>Jupyter 笔记本可以从<a href="_static/GLM.ipynb">梯度提升树回归</a>。</li><li>参数的更多信息请见<a href="http://takwatanabe.me/pyspark/generated/generated/ml.regression.GBTRegressor.html" target="_blank" rel="noopener">梯度提升树回归 API</a>。</li></ul><p>建立 spark 上下文和 SparkSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark GBTRegressor example&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                               options(header=&apos;true&apos;, \</span><br><span class="line">                               inferschema=&apos;true&apos;).\</span><br><span class="line">                               load(&quot;../data/Advertising.csv&quot;,header=True);</span><br><span class="line"></span><br><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|   TV|Radio|Newspaper|Sales|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">|230.1| 37.8|     69.2| 22.1|</span><br><span class="line">| 44.5| 39.3|     45.1| 10.4|</span><br><span class="line">| 17.2| 45.9|     69.3|  9.3|</span><br><span class="line">|151.5| 41.3|     58.5| 18.5|</span><br><span class="line">|180.8| 10.8|     58.4| 12.9|</span><br><span class="line">+-----+-----+---------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">root</span><br><span class="line"> |-- TV: double (nullable = true)</span><br><span class="line"> |-- Radio: double (nullable = true)</span><br><span class="line"> |-- Newspaper: double (nullable = true)</span><br><span class="line"> |-- Sales: double (nullable = true)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.describe().show()</span><br><span class="line"></span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|summary|               TV|             Radio|         Newspaper|             Sales|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br><span class="line">|  count|              200|               200|               200|               200|</span><br><span class="line">|   mean|         147.0425|23.264000000000024|30.553999999999995|14.022500000000003|</span><br><span class="line">| stddev|85.85423631490805|14.846809176168728| 21.77862083852283| 5.217456565710477|</span><br><span class="line">|    min|              0.7|               0.0|               0.3|               1.6|</span><br><span class="line">|    max|            296.4|              49.6|             114.0|              27.0|</span><br><span class="line">+-------+-----------------+------------------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量（<strong>特征</strong>和<strong>标签</strong>）</p><blockquote><p>注意</p><p>强烈建议您尝试使用我的<code>get_dummy</code>函数来处理数据集中的分类数据。</p></blockquote><p>监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><p>无监督学习版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">    :param df: the dataframe</span><br><span class="line">    :param categoricalCols: the name list of the categorical data</span><br><span class="line">    :param continuousCols:  the name list of the numerical data</span><br><span class="line">    :return k: feature matrix</span><br><span class="line"></span><br><span class="line">    :author: Wenqiang Feng</span><br><span class="line">    :email:  von198@gmail.com</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    return data.select(indexCol,&apos;features&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line"></span><br><span class="line"># convert the data to dense vector</span><br><span class="line">#def transData(row):</span><br><span class="line">#    return Row(label=row[&quot;Sales&quot;],</span><br><span class="line">#               features=Vectors.dense([row[&quot;TV&quot;],</span><br><span class="line">#                                       row[&quot;Radio&quot;],</span><br><span class="line">#                                       row[&quot;Newspaper&quot;]]))</span><br><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><p>将数据转换为密集向量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed= transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+</span><br><span class="line">|         features|label|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|</span><br><span class="line">+-----------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>处理类别变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.regression import GBTRegressor</span><br><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line">from pyspark.ml.evaluation import RegressionEvaluator</span><br><span class="line"></span><br><span class="line">featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                               outputCol=&quot;indexedFeatures&quot;,\</span><br><span class="line">                               maxCategories=4).fit(transformed)</span><br><span class="line"></span><br><span class="line">data = featureIndexer.transform(transformed)</span><br><span class="line">data.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|         features|label|  indexedFeatures|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">|[230.1,37.8,69.2]| 22.1|[230.1,37.8,69.2]|</span><br><span class="line">| [44.5,39.3,45.1]| 10.4| [44.5,39.3,45.1]|</span><br><span class="line">| [17.2,45.9,69.3]|  9.3| [17.2,45.9,69.3]|</span><br><span class="line">|[151.5,41.3,58.5]| 18.5|[151.5,41.3,58.5]|</span><br><span class="line">|[180.8,10.8,58.4]| 12.9|[180.8,10.8,58.4]|</span><br><span class="line">+-----------------+-----+-----------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>将数据分割为训练和测试集（留出 40% 用于测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = data.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-----+----------------+</span><br><span class="line">|        features|label| indexedFeatures|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">|  [0.7,39.6,8.7]|  1.6|  [0.7,39.6,8.7]|</span><br><span class="line">|   [8.6,2.1,1.0]|  4.8|   [8.6,2.1,1.0]|</span><br><span class="line">| [8.7,48.9,75.0]|  7.2| [8.7,48.9,75.0]|</span><br><span class="line">|[11.7,36.9,45.2]|  7.3|[11.7,36.9,45.2]|</span><br><span class="line">|[13.2,15.9,49.6]|  5.6|[13.2,15.9,49.6]|</span><br><span class="line">+----------------+-----+----------------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">|       features|label|indexedFeatures|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">| [4.1,11.6,5.7]|  3.2| [4.1,11.6,5.7]|</span><br><span class="line">| [5.4,29.9,9.4]|  5.3| [5.4,29.9,9.4]|</span><br><span class="line">|[7.3,28.1,41.4]|  5.5|[7.3,28.1,41.4]|</span><br><span class="line">|[7.8,38.9,50.6]|  6.6|[7.8,38.9,50.6]|</span><br><span class="line">| [8.4,27.2,2.1]|  5.7| [8.4,27.2,2.1]|</span><br><span class="line">+---------------+-----+---------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>拟合梯度提升树模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Import LinearRegression class</span><br><span class="line">from pyspark.ml.regression import GBTRegressor</span><br><span class="line"></span><br><span class="line"># Define LinearRegression algorithm</span><br><span class="line">rf = GBTRegressor() #numTrees=2, maxDepth=2, seed=42</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>如果你决定使用<code>indexedFeatures</code>特征，你需要添加参数<code>featuresCol=&quot;indexedFeatures&quot;</code>。</p></blockquote><p>流水线架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexer and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[featureIndexer, rf])</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><p>做出预测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.transform(testData)</span><br><span class="line"></span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;, &quot;prediction&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-----+------------------+</span><br><span class="line">|        features|label|        prediction|</span><br><span class="line">+----------------+-----+------------------+</span><br><span class="line">| [7.8,38.9,50.6]|  6.6| 6.836040343319862|</span><br><span class="line">|   [8.6,2.1,1.0]|  4.8| 5.652202764688849|</span><br><span class="line">| [8.7,48.9,75.0]|  7.2| 6.908750296855572|</span><br><span class="line">| [13.1,0.4,25.6]|  5.3| 5.784020210692574|</span><br><span class="line">|[19.6,20.1,17.0]|  7.6|6.8678921062629295|</span><br><span class="line">+----------------+-----+------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><p>评估</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = RegressionEvaluator(</span><br><span class="line">    labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;rmse&quot;)</span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root Mean Squared Error (RMSE) on test data = 1.36939</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sklearn.metrics</span><br><span class="line">r2_score = sklearn.metrics.r2_score(y_true, y_pred)</span><br><span class="line">print(&apos;r2_score: &#123;:4.3f&#125;&apos;.format(r2_score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2_score: 0.932</span><br></pre></td></tr></table></figure><p>特征重要性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.stages[-1].featureImportances</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseVector(3, &#123;0: 0.3716, 1: 0.3525, 2: 0.2759&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.stages[-1].trees</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[DecisionTreeRegressionModel (uid=dtr_7f5cd2ef7cb6) of depth 5 with 61 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_ef3ab6baeac9) of depth 5 with 39 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_07c6e3cf3819) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_ce724af79a2b) of depth 5 with 47 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_d149ecc71658) of depth 5 with 55 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_d3a79bdea516) of depth 5 with 43 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_7abc1a337844) of depth 5 with 51 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_480834b46d8f) of depth 5 with 33 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_0cbd1eaa3874) of depth 5 with 39 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_8088ac71a204) of depth 5 with 57 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_2ceb9e8deb45) of depth 5 with 47 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_cc334e84e9a2) of depth 5 with 57 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_a665c562929e) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_2999b1ffd2dc) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_29965cbe8cfc) of depth 5 with 55 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_731df51bf0ad) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_354cf33424da) of depth 5 with 51 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_4230f200b1c0) of depth 5 with 41 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_3279cdc1ce1d) of depth 5 with 45 nodes,</span><br><span class="line"> DecisionTreeRegressionModel (uid=dtr_f474a99ff06e) of depth 5 with 55 nodes]</span><br></pre></td></tr></table></figure><h1 id="10-Classification"><a href="#10-Classification" class="headerlink" title="10. Classification"></a>10. Classification</h1><p>Chinese proverb</p><p><strong>Birds of a feather folock together.</strong> – old Chinese proverb</p><h2 id="10-1-Binomial-logistic-regression"><a href="#10-1-Binomial-logistic-regression" class="headerlink" title="10.1. Binomial logistic regression"></a>10.1. Binomial logistic regression</h2><h3 id="10-1-1-Introduction"><a href="#10-1-1-Introduction" class="headerlink" title="10.1.1. Introduction"></a>10.1.1. Introduction</h3><h3 id="10-1-2-Demo"><a href="#10-1-2-Demo" class="headerlink" title="10.1.2. Demo"></a>10.1.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/logisticRegression.ipynb">Logistic Regression</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.BinaryLogisticRegressionSummary.html" target="_blank" rel="noopener">Logistic Regression API</a> .</li></ul><p>Note</p><p>In this demo, I introduced a new function <code>get_dummy</code> to deal with the categorical data. I highly recommend you to use my <code>get_dummy</code> function in the other cases. This function will save a lot of time for you.</p><ol><li>Set up spark context and SparkSession</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">        spark = SparkSession \</span><br><span class="line">            .builder \</span><br><span class="line">            .appName(&quot;Python Spark Logistic Regression example&quot;) \</span><br><span class="line">            .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">            .getOrCreate()</span><br></pre></td></tr></table></figure><ol><li>Load dataset</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;) \</span><br><span class="line">            .options(header=&apos;true&apos;, inferschema=&apos;true&apos;) \</span><br><span class="line">            .load(&quot;./data/bank.csv&quot;,header=True);</span><br><span class="line">df.drop(&apos;day&apos;,&apos;month&apos;,&apos;poutcome&apos;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+------------+-------+---------+-------+-------+-------+----+-------+--------+--------+-----+--------+---+</span><br><span class="line">|age|         job|marital|education|default|balance|housing|loan|contact|duration|campaign|pdays|previous|  y|</span><br><span class="line">+---+------------+-------+---------+-------+-------+-------+----+-------+--------+--------+-----+--------+---+</span><br><span class="line">| 58|  management|married| tertiary|     no|   2143|    yes|  no|unknown|     261|       1|   -1|       0| no|</span><br><span class="line">| 44|  technician| single|secondary|     no|     29|    yes|  no|unknown|     151|       1|   -1|       0| no|</span><br><span class="line">| 33|entrepreneur|married|secondary|     no|      2|    yes| yes|unknown|      76|       1|   -1|       0| no|</span><br><span class="line">| 47| blue-collar|married|  unknown|     no|   1506|    yes|  no|unknown|      92|       1|   -1|       0| no|</span><br><span class="line">| 33|     unknown| single|  unknown|     no|      1|     no|  no|unknown|     198|       1|   -1|       0| no|</span><br><span class="line">+---+------------+-------+---------+-------+-------+-------+----+-------+--------+--------+-----+--------+---+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- age: integer (nullable = true)</span><br><span class="line"> |-- job: string (nullable = true)</span><br><span class="line"> |-- marital: string (nullable = true)</span><br><span class="line"> |-- education: string (nullable = true)</span><br><span class="line"> |-- default: string (nullable = true)</span><br><span class="line"> |-- balance: integer (nullable = true)</span><br><span class="line"> |-- housing: string (nullable = true)</span><br><span class="line"> |-- loan: string (nullable = true)</span><br><span class="line"> |-- contact: string (nullable = true)</span><br><span class="line"> |-- day: integer (nullable = true)</span><br><span class="line"> |-- month: string (nullable = true)</span><br><span class="line"> |-- duration: integer (nullable = true)</span><br><span class="line"> |-- campaign: integer (nullable = true)</span><br><span class="line"> |-- pdays: integer (nullable = true)</span><br><span class="line"> |-- previous: integer (nullable = true)</span><br><span class="line"> |-- poutcome: string (nullable = true)</span><br><span class="line"> |-- y: string (nullable = true)</span><br></pre></td></tr></table></figure><p>Note</p><p>You are strongly encouraged to try my <code>get_dummy</code> function for dealing with the categorical data in complex dataset.</p><p>Supervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line">&gt; </span><br><span class="line">&gt;  from pyspark.ml import Pipeline</span><br><span class="line">&gt;  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">&gt;  from pyspark.sql.functions import col</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Unsupervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt;  Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">&gt;  :param df: the dataframe</span><br><span class="line">&gt;  :param categoricalCols: the name list of the categorical data</span><br><span class="line">&gt;  :param continuousCols:  the name list of the numerical data</span><br><span class="line">&gt;  :return k: feature matrix</span><br><span class="line">&gt; </span><br><span class="line">&gt;  :author: Wenqiang Feng</span><br><span class="line">&gt;  :email:  von198@gmail.com</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><ol><li>Deal with categorical data and Convert the data to dense vector</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catcols = [&apos;job&apos;,&apos;marital&apos;,&apos;education&apos;,&apos;default&apos;,</span><br><span class="line">           &apos;housing&apos;,&apos;loan&apos;,&apos;contact&apos;,&apos;poutcome&apos;]</span><br><span class="line"></span><br><span class="line">num_cols = [&apos;balance&apos;, &apos;duration&apos;,&apos;campaign&apos;,&apos;pdays&apos;,&apos;previous&apos;,]</span><br><span class="line">labelCol = &apos;y&apos;</span><br><span class="line"></span><br><span class="line">data = get_dummy(df,catcols,num_cols,labelCol)</span><br><span class="line">data.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+</span><br><span class="line">|            features|label|</span><br><span class="line">+--------------------+-----+</span><br><span class="line">|(29,[1,11,14,16,1...|   no|</span><br><span class="line">|(29,[2,12,13,16,1...|   no|</span><br><span class="line">|(29,[7,11,13,16,1...|   no|</span><br><span class="line">|(29,[0,11,16,17,1...|   no|</span><br><span class="line">|(29,[12,16,18,20,...|   no|</span><br><span class="line">+--------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Deal with Categorical Label and Variables</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.feature import StringIndexer</span><br><span class="line"># Index labels, adding metadata to the label column</span><br><span class="line">labelIndexer = StringIndexer(inputCol=&apos;label&apos;,</span><br><span class="line">                             outputCol=&apos;indexedLabel&apos;).fit(data)</span><br><span class="line">labelIndexer.transform(data).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+------------+</span><br><span class="line">|            features|label|indexedLabel|</span><br><span class="line">+--------------------+-----+------------+</span><br><span class="line">|(29,[1,11,14,16,1...|   no|         0.0|</span><br><span class="line">|(29,[2,12,13,16,1...|   no|         0.0|</span><br><span class="line">|(29,[7,11,13,16,1...|   no|         0.0|</span><br><span class="line">|(29,[0,11,16,17,1...|   no|         0.0|</span><br><span class="line">|(29,[12,16,18,20,...|   no|         0.0|</span><br><span class="line">+--------------------+-----+------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.feature import VectorIndexer</span><br><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># Set maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line">featureIndexer =VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                                  outputCol=&quot;indexedFeatures&quot;, \</span><br><span class="line">                                  maxCategories=4).fit(data)</span><br><span class="line">featureIndexer.transform(data).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">|            features|label|     indexedFeatures|</span><br><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">|(29,[1,11,14,16,1...|   no|(29,[1,11,14,16,1...|</span><br><span class="line">|(29,[2,12,13,16,1...|   no|(29,[2,12,13,16,1...|</span><br><span class="line">|(29,[7,11,13,16,1...|   no|(29,[7,11,13,16,1...|</span><br><span class="line">|(29,[0,11,16,17,1...|   no|(29,[0,11,16,17,1...|</span><br><span class="line">|(29,[12,16,18,20,...|   no|(29,[12,16,18,20,...|</span><br><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Split the data to training and test data sets</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = data.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5,False)</span><br><span class="line">testData.show(5,False)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">|features                                                                                         |label|</span><br><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-731.0,401.0,4.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-723.0,112.0,2.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-626.0,205.0,1.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-498.0,357.0,1.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-477.0,473.0,2.0,-1.0])|no   |</span><br><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">|features                                                                                         |label|</span><br><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-648.0,280.0,2.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-596.0,147.0,1.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-529.0,416.0,4.0,-1.0])|no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-518.0,46.0,5.0,-1.0]) |no   |</span><br><span class="line">|(29,[0,11,13,16,17,18,19,21,24,25,26,27],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-470.0,275.0,2.0,-1.0])|no   |</span><br><span class="line">+-------------------------------------------------------------------------------------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Fit Logistic Regression Model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.classification import LogisticRegression</span><br><span class="line">logr = LogisticRegression(featuresCol=&apos;indexedFeatures&apos;, labelCol=&apos;indexedLabel&apos;)</span><br></pre></td></tr></table></figure><ol><li>Pipeline Architecture</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Convert indexed labels back to original labels.</span><br><span class="line">labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;,</span><br><span class="line">                               labels=labelIndexer.labels)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexers and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[labelIndexer, featureIndexer, logr,labelConverter])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Train model.  This also runs the indexers.</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><ol><li>Make predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+--------------+</span><br><span class="line">|            features|label|predictedLabel|</span><br><span class="line">+--------------------+-----+--------------+</span><br><span class="line">|(29,[0,11,13,16,1...|   no|            no|</span><br><span class="line">|(29,[0,11,13,16,1...|   no|            no|</span><br><span class="line">|(29,[0,11,13,16,1...|   no|            no|</span><br><span class="line">|(29,[0,11,13,16,1...|   no|            no|</span><br><span class="line">|(29,[0,11,13,16,1...|   no|            no|</span><br><span class="line">+--------------------+-----+--------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Evaluation</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = MulticlassClassificationEvaluator(</span><br><span class="line">    labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;)</span><br><span class="line">accuracy = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Test Error = %g&quot; % (1.0 - accuracy))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test Error = 0.0987688</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lrModel = model.stages[2]</span><br><span class="line">trainingSummary = lrModel.summary</span><br><span class="line"></span><br><span class="line"># Obtain the objective per iteration</span><br><span class="line"># objectiveHistory = trainingSummary.objectiveHistory</span><br><span class="line"># print(&quot;objectiveHistory:&quot;)</span><br><span class="line"># for objective in objectiveHistory:</span><br><span class="line">#     print(objective)</span><br><span class="line"></span><br><span class="line"># Obtain the receiver-operating characteristic as a dataframe and areaUnderROC.</span><br><span class="line">trainingSummary.roc.show(5)</span><br><span class="line">print(&quot;areaUnderROC: &quot; + str(trainingSummary.areaUnderROC))</span><br><span class="line"></span><br><span class="line"># Set the model threshold to maximize F-Measure</span><br><span class="line">fMeasure = trainingSummary.fMeasureByThreshold</span><br><span class="line">maxFMeasure = fMeasure.groupBy().max(&apos;F-Measure&apos;).select(&apos;max(F-Measure)&apos;).head(5)</span><br><span class="line"># bestThreshold = fMeasure.where(fMeasure[&apos;F-Measure&apos;] == maxFMeasure[&apos;max(F-Measure)&apos;]) \</span><br><span class="line">#     .select(&apos;threshold&apos;).head()[&apos;threshold&apos;]</span><br><span class="line"># lr.setThreshold(bestThreshold)</span><br></pre></td></tr></table></figure><p>You can use <code>z.show()</code> to get the data and plot the ROC curves:</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc_z.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc_z.png"></p><p>You can also register a TempTable <code>data.registerTempTable(&#39;roc_data&#39;)</code> and then use <code>sql</code> to plot the ROC curve:</p><p><img src="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc.png" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc.png"></p><ol><li>visualization</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def plot_confusion_matrix(cm, classes,</span><br><span class="line">                          normalize=False,</span><br><span class="line">                          title=&apos;Confusion matrix&apos;,</span><br><span class="line">                          cmap=plt.cm.Blues):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function prints and plots the confusion matrix.</span><br><span class="line">    Normalization can be applied by setting `normalize=True`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if normalize:</span><br><span class="line">        cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]</span><br><span class="line">        print(&quot;Normalized confusion matrix&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line"></span><br><span class="line">    print(cm)</span><br><span class="line"></span><br><span class="line">    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=45)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = &apos;.2f&apos; if normalize else &apos;d&apos;</span><br><span class="line">    thresh = cm.max() / 2.</span><br><span class="line">    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=&quot;center&quot;,</span><br><span class="line">                 color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(&apos;True label&apos;)</span><br><span class="line">    plt.xlabel(&apos;Predicted label&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_temp = predictions.select(&quot;label&quot;).groupBy(&quot;label&quot;)\</span><br><span class="line">                        .count().sort(&apos;count&apos;, ascending=False).toPandas()</span><br><span class="line">class_temp = class_temp[&quot;label&quot;].values.tolist()</span><br><span class="line">class_names = map(str, class_temp)</span><br><span class="line"># # # print(class_name)</span><br><span class="line">class_names</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;no&apos;, &apos;yes&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">y_true = predictions.select(&quot;label&quot;)</span><br><span class="line">y_true = y_true.toPandas()</span><br><span class="line"></span><br><span class="line">y_pred = predictions.select(&quot;predictedLabel&quot;)</span><br><span class="line">y_pred = y_pred.toPandas()</span><br><span class="line"></span><br><span class="line">cnf_matrix = confusion_matrix(y_true, y_pred,labels=class_names)</span><br><span class="line">cnf_matrix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[15657,   379],</span><br><span class="line">       [ 1410,   667]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Plot non-normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names,</span><br><span class="line">                      title=&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Confusion matrix, without normalization</span><br><span class="line">[[15657   379]</span><br><span class="line"> [ 1410   667]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/7bb886fc0ea7d5d1144002edd99e0c7f.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/logr_b1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Plot normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,</span><br><span class="line">                      title=&apos;Normalized confusion matrix&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Normalized confusion matrix</span><br><span class="line">[[ 0.97636568  0.02363432]</span><br><span class="line"> [ 0.67886375  0.32113625]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/86176a13e0a00622dbc982348d7ca623.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/logr_b2.png"></p><h2 id="10-2-Multinomial-logistic-regression"><a href="#10-2-Multinomial-logistic-regression" class="headerlink" title="10.2. Multinomial logistic regression"></a>10.2. Multinomial logistic regression</h2><h3 id="10-2-1-Introduction"><a href="#10-2-1-Introduction" class="headerlink" title="10.2.1. Introduction"></a>10.2.1. Introduction</h3><h3 id="10-2-2-Demo"><a href="#10-2-2-Demo" class="headerlink" title="10.2.2. Demo"></a>10.2.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/logisticRegression.ipynb">Logistic Regression</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.BinaryLogisticRegressionSummary.html" target="_blank" rel="noopener">Logistic Regression API</a> .</li></ul><p>Note</p><p>In this demo, I introduced a new function <code>get_dummy</code> to deal with the categorical data. I highly recommend you to use my <code>get_dummy</code> function in the other cases. This function will save a lot of time for you.</p><ol><li>Set up spark context and SparkSession</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark MultinomialLogisticRegression classification&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><ol><li>Load dataset</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;) \</span><br><span class="line">            .options(header=&apos;true&apos;, inferschema=&apos;true&apos;) \</span><br><span class="line">            .load(&quot;./data/WineData2.csv&quot;,header=True);</span><br><span class="line">df.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8|      5|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8|      5|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8|      6|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Convert to float format</span><br><span class="line">def string_to_float(x):</span><br><span class="line">    return float(x)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def condition(r):</span><br><span class="line">    if (0&lt;= r &lt;= 4):</span><br><span class="line">        label = &quot;low&quot;</span><br><span class="line">    elif(4&lt; r &lt;= 6):</span><br><span class="line">        label = &quot;medium&quot;</span><br><span class="line">    else:</span><br><span class="line">        label = &quot;high&quot;</span><br><span class="line">    return label</span><br><span class="line"></span><br><span class="line">from pyspark.sql.functions import udf</span><br><span class="line">from pyspark.sql.types import StringType, DoubleType</span><br><span class="line">string_to_float_udf = udf(string_to_float, DoubleType())</span><br><span class="line">quality_udf = udf(lambda x: condition(x), StringType())</span><br><span class="line"></span><br><span class="line">df = df.withColumn(&quot;quality&quot;, quality_udf(&quot;quality&quot;))</span><br><span class="line"></span><br><span class="line">df.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8| medium|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8| medium|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8| medium|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><ol><li>Deal with categorical data and Convert the data to dense vector</li></ol><p>Note</p><p>You are strongly encouraged to try my <code>get_dummy</code> function for dealing with the categorical data in complex dataset.</p><p>Supervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line">&gt; </span><br><span class="line">&gt;  from pyspark.ml import Pipeline</span><br><span class="line">&gt;  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">&gt;  from pyspark.sql.functions import col</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Unsupervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt;  Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">&gt;  :param df: the dataframe</span><br><span class="line">&gt;  :param categoricalCols: the name list of the categorical data</span><br><span class="line">&gt;  :param continuousCols:  the name list of the numerical data</span><br><span class="line">&gt;  :return k: feature matrix</span><br><span class="line">&gt; </span><br><span class="line">&gt;  :author: Wenqiang Feng</span><br><span class="line">&gt;  :email:  von198@gmail.com</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><ol><li>Transform the dataset to DataFrame</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.linalg import Vectors # !!!!caution: not from pyspark.mllib.linalg import Vectors</span><br><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.feature import IndexToString,StringIndexer, VectorIndexer</span><br><span class="line">from pyspark.ml.tuning import CrossValidator, ParamGridBuilder</span><br><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line">def transData(data):</span><br><span class="line">return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed = transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Deal with Categorical Label and Variables</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Index labels, adding metadata to the label column</span><br><span class="line">labelIndexer = StringIndexer(inputCol=&apos;label&apos;,</span><br><span class="line">                             outputCol=&apos;indexedLabel&apos;).fit(transformed)</span><br><span class="line">labelIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+------------+</span><br><span class="line">|            features| label|indexedLabel|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|         0.0|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|         0.0|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|         0.0|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># Set maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line">featureIndexer =VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                              outputCol=&quot;indexedFeatures&quot;, \</span><br><span class="line">                              maxCategories=4).fit(transformed)</span><br><span class="line">featureIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|            features| label|     indexedFeatures|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|[7.8,0.88,0.0,2.6...|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|[7.8,0.76,0.04,2....|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|[11.2,0.28,0.56,1...|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Split the data to training and test data sets</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = data.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5,False)</span><br><span class="line">testData.show(5,False)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">|features                                                 |label |</span><br><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">|[4.7,0.6,0.17,2.3,0.058,17.0,106.0,0.9932,3.85,0.6,12.9] |medium|</span><br><span class="line">|[5.0,0.38,0.01,1.6,0.048,26.0,60.0,0.99084,3.7,0.75,14.0]|medium|</span><br><span class="line">|[5.0,0.4,0.5,4.3,0.046,29.0,80.0,0.9902,3.49,0.66,13.6]  |medium|</span><br><span class="line">|[5.0,0.74,0.0,1.2,0.041,16.0,46.0,0.99258,4.01,0.59,12.5]|medium|</span><br><span class="line">|[5.1,0.42,0.0,1.8,0.044,18.0,88.0,0.99157,3.68,0.73,13.6]|high  |</span><br><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">|features                                                 |label |</span><br><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">|[4.6,0.52,0.15,2.1,0.054,8.0,65.0,0.9934,3.9,0.56,13.1]  |low   |</span><br><span class="line">|[4.9,0.42,0.0,2.1,0.048,16.0,42.0,0.99154,3.71,0.74,14.0]|high  |</span><br><span class="line">|[5.0,0.42,0.24,2.0,0.06,19.0,50.0,0.9917,3.72,0.74,14.0] |high  |</span><br><span class="line">|[5.0,1.02,0.04,1.4,0.045,41.0,85.0,0.9938,3.75,0.48,10.5]|low   |</span><br><span class="line">|[5.0,1.04,0.24,1.6,0.05,32.0,96.0,0.9934,3.74,0.62,11.5] |medium|</span><br><span class="line">+---------------------------------------------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Fit Multinomial logisticRegression Classification Model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.classification import LogisticRegression</span><br><span class="line">logr = LogisticRegression(featuresCol=&apos;indexedFeatures&apos;, labelCol=&apos;indexedLabel&apos;)</span><br></pre></td></tr></table></figure><ol><li>Pipeline Architecture</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Convert indexed labels back to original labels.</span><br><span class="line">labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;,</span><br><span class="line">                               labels=labelIndexer.labels)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexers and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[labelIndexer, featureIndexer, logr,labelConverter])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Train model.  This also runs the indexers.</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><ol><li>Make predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------+</span><br><span class="line">|            features| label|predictedLabel|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">|[4.6,0.52,0.15,2....|   low|        medium|</span><br><span class="line">|[4.9,0.42,0.0,2.1...|  high|          high|</span><br><span class="line">|[5.0,0.42,0.24,2....|  high|          high|</span><br><span class="line">|[5.0,1.02,0.04,1....|   low|        medium|</span><br><span class="line">|[5.0,1.04,0.24,1....|medium|        medium|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Evaluation</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = MulticlassClassificationEvaluator(</span><br><span class="line">    labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;)</span><br><span class="line">accuracy = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Test Error = %g&quot; % (1.0 - accuracy))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test Error = 0.181287</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lrModel = model.stages[2]</span><br><span class="line">trainingSummary = lrModel.summary</span><br><span class="line"></span><br><span class="line"># Obtain the objective per iteration</span><br><span class="line"># objectiveHistory = trainingSummary.objectiveHistory</span><br><span class="line"># print(&quot;objectiveHistory:&quot;)</span><br><span class="line"># for objective in objectiveHistory:</span><br><span class="line">#     print(objective)</span><br><span class="line"></span><br><span class="line"># Obtain the receiver-operating characteristic as a dataframe and areaUnderROC.</span><br><span class="line">trainingSummary.roc.show(5)</span><br><span class="line">print(&quot;areaUnderROC: &quot; + str(trainingSummary.areaUnderROC))</span><br><span class="line"></span><br><span class="line"># Set the model threshold to maximize F-Measure</span><br><span class="line">fMeasure = trainingSummary.fMeasureByThreshold</span><br><span class="line">maxFMeasure = fMeasure.groupBy().max(&apos;F-Measure&apos;).select(&apos;max(F-Measure)&apos;).head(5)</span><br><span class="line"># bestThreshold = fMeasure.where(fMeasure[&apos;F-Measure&apos;] == maxFMeasure[&apos;max(F-Measure)&apos;]) \</span><br><span class="line">#     .select(&apos;threshold&apos;).head()[&apos;threshold&apos;]</span><br><span class="line"># lr.setThreshold(bestThreshold)</span><br></pre></td></tr></table></figure><p>You can use <code>z.show()</code> to get the data and plot the ROC curves:</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/4ae661a05a9586c4ce7b5eabf4bab417.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc_z.png"></p><p>You can also register a TempTable <code>data.registerTempTable(&#39;roc_data&#39;)</code> and then use <code>sql</code> to plot the ROC curve:</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/b7d7ca35788d7bfb804b5b230a76af8c.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc.png"></p><ol><li>visualization</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def plot_confusion_matrix(cm, classes,</span><br><span class="line">                          normalize=False,</span><br><span class="line">                          title=&apos;Confusion matrix&apos;,</span><br><span class="line">                          cmap=plt.cm.Blues):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function prints and plots the confusion matrix.</span><br><span class="line">    Normalization can be applied by setting `normalize=True`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if normalize:</span><br><span class="line">        cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]</span><br><span class="line">        print(&quot;Normalized confusion matrix&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line"></span><br><span class="line">    print(cm)</span><br><span class="line"></span><br><span class="line">    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=45)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = &apos;.2f&apos; if normalize else &apos;d&apos;</span><br><span class="line">    thresh = cm.max() / 2.</span><br><span class="line">    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=&quot;center&quot;,</span><br><span class="line">                 color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(&apos;True label&apos;)</span><br><span class="line">    plt.xlabel(&apos;Predicted label&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_temp = predictions.select(&quot;label&quot;).groupBy(&quot;label&quot;)\</span><br><span class="line">                        .count().sort(&apos;count&apos;, ascending=False).toPandas()</span><br><span class="line">class_temp = class_temp[&quot;label&quot;].values.tolist()</span><br><span class="line">class_names = map(str, class_temp)</span><br><span class="line"># # # print(class_name)</span><br><span class="line">class_names</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;medium&apos;, &apos;high&apos;, &apos;low&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">y_true = predictions.select(&quot;label&quot;)</span><br><span class="line">y_true = y_true.toPandas()</span><br><span class="line"></span><br><span class="line">y_pred = predictions.select(&quot;predictedLabel&quot;)</span><br><span class="line">y_pred = y_pred.toPandas()</span><br><span class="line"></span><br><span class="line">cnf_matrix = confusion_matrix(y_true, y_pred,labels=class_names)</span><br><span class="line">cnf_matrix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[526,  11,   2],</span><br><span class="line">       [ 73,  33,   0],</span><br><span class="line">       [ 38,   0,   1]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Plot non-normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names,</span><br><span class="line">                      title=&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Confusion matrix, without normalization</span><br><span class="line">[[526  11   2]</span><br><span class="line"> [ 73  33   0]</span><br><span class="line"> [ 38   0   1]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/189ce8661099fd6f1118f978d53cf85b.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/mlrconfu1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Plot normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,</span><br><span class="line">                      title=&apos;Normalized confusion matrix&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Normalized confusion matrix</span><br><span class="line">[[0.97588126 0.02040816 0.00371058]</span><br><span class="line"> [0.68867925 0.31132075 0\.        ]</span><br><span class="line"> [0.97435897 0\.         0.02564103]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/1c57212c22a6a7777decfa1971418148.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/mlrconfu2.png"></p><h2 id="10-3-Decision-tree-Classification"><a href="#10-3-Decision-tree-Classification" class="headerlink" title="10.3. Decision tree Classification"></a>10.3. Decision tree Classification</h2><h3 id="10-3-1-Introduction"><a href="#10-3-1-Introduction" class="headerlink" title="10.3.1. Introduction"></a>10.3.1. Introduction</h3><h3 id="10-3-2-Demo"><a href="#10-3-2-Demo" class="headerlink" title="10.3.2. Demo"></a>10.3.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/DecisionTreeC.ipynb">Decision Tree Classification</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.DecisionTreeClassifier.html" target="_blank" rel="noopener">DecisionTreeClassifier API</a> .</li></ul><ol><li>Set up spark context and SparkSession</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">        spark = SparkSession \</span><br><span class="line">            .builder \</span><br><span class="line">            .appName(&quot;Python Spark Decision Tree classification&quot;) \</span><br><span class="line">            .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">            .getOrCreate()</span><br></pre></td></tr></table></figure><ol><li>Load dataset</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                               options(header=&apos;true&apos;, \</span><br><span class="line">                               inferschema=&apos;true&apos;) \</span><br><span class="line">                .load(&quot;../data/WineData2.csv&quot;,header=True);</span><br><span class="line">df.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8|      5|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8|      5|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8|      6|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Convert to float format</span><br><span class="line">def string_to_float(x):</span><br><span class="line">    return float(x)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def condition(r):</span><br><span class="line">    if (0&lt;= r &lt;= 4):</span><br><span class="line">        label = &quot;low&quot;</span><br><span class="line">    elif(4&lt; r &lt;= 6):</span><br><span class="line">        label = &quot;medium&quot;</span><br><span class="line">    else:</span><br><span class="line">        label = &quot;high&quot;</span><br><span class="line">    return label</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql.functions import udf</span><br><span class="line">from pyspark.sql.types import StringType, DoubleType</span><br><span class="line">string_to_float_udf = udf(string_to_float, DoubleType())</span><br><span class="line">quality_udf = udf(lambda x: condition(x), StringType())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = df.withColumn(&quot;quality&quot;, quality_udf(&quot;quality&quot;))</span><br><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8| medium|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8| medium|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8| medium|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><ol><li>Convert the data to dense vector</li></ol><p>Note</p><p>You are strongly encouraged to try my <code>get_dummy</code> function for dealing with the categorical data in complex dataset.</p><p>Supervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line">&gt; </span><br><span class="line">&gt;  from pyspark.ml import Pipeline</span><br><span class="line">&gt;  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">&gt;  from pyspark.sql.functions import col</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Unsupervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt;  Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">&gt;  :param df: the dataframe</span><br><span class="line">&gt;  :param categoricalCols: the name list of the categorical data</span><br><span class="line">&gt;  :param continuousCols:  the name list of the numerical data</span><br><span class="line">&gt;  :return k: feature matrix</span><br><span class="line">&gt; </span><br><span class="line">&gt;  :author: Wenqiang Feng</span><br><span class="line">&gt;  :email:  von198@gmail.com</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># !!!!caution: not from pyspark.mllib.linalg import Vectors</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.feature import IndexToString,StringIndexer, VectorIndexer</span><br><span class="line">from pyspark.ml.tuning import CrossValidator, ParamGridBuilder</span><br><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><ol><li>Transform the dataset to DataFrame</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed = transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Deal with Categorical Label and Variables</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Index labels, adding metadata to the label column</span><br><span class="line">labelIndexer = StringIndexer(inputCol=&apos;label&apos;,</span><br><span class="line">                             outputCol=&apos;indexedLabel&apos;).fit(transformed)</span><br><span class="line">labelIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+------------+</span><br><span class="line">|            features| label|indexedLabel|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|         0.0|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|         0.0|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|         0.0|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    # Automatically identify categorical features, and index them.</span><br><span class="line">    # Set maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line">    featureIndexer =VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                                  outputCol=&quot;indexedFeatures&quot;, \</span><br><span class="line">                                  maxCategories=4).fit(transformed)</span><br><span class="line">featureIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|            features| label|     indexedFeatures|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|[7.8,0.88,0.0,2.6...|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|[7.8,0.76,0.04,2....|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|[11.2,0.28,0.56,1...|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Split the data to training and test data sets</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = transformed.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[4.6,0.52,0.15,2....|   low|</span><br><span class="line">|[4.7,0.6,0.17,2.3...|medium|</span><br><span class="line">|[5.0,1.02,0.04,1....|   low|</span><br><span class="line">|[5.0,1.04,0.24,1....|medium|</span><br><span class="line">|[5.1,0.585,0.0,1....|  high|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[4.9,0.42,0.0,2.1...|  high|</span><br><span class="line">|[5.0,0.38,0.01,1....|medium|</span><br><span class="line">|[5.0,0.4,0.5,4.3,...|medium|</span><br><span class="line">|[5.0,0.42,0.24,2....|  high|</span><br><span class="line">|[5.0,0.74,0.0,1.2...|medium|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Fit Decision Tree Classification Model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.classification import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"># Train a DecisionTree model</span><br><span class="line">dTree = DecisionTreeClassifier(labelCol=&apos;indexedLabel&apos;, featuresCol=&apos;indexedFeatures&apos;)</span><br></pre></td></tr></table></figure><ol><li>Pipeline Architecture</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Convert indexed labels back to original labels.</span><br><span class="line">labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;,</span><br><span class="line">                               labels=labelIndexer.labels)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexers and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[labelIndexer, featureIndexer, dTree,labelConverter])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Train model.  This also runs the indexers.</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><ol><li>Make predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------+</span><br><span class="line">|            features| label|predictedLabel|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">|[4.9,0.42,0.0,2.1...|  high|          high|</span><br><span class="line">|[5.0,0.38,0.01,1....|medium|        medium|</span><br><span class="line">|[5.0,0.4,0.5,4.3,...|medium|        medium|</span><br><span class="line">|[5.0,0.42,0.24,2....|  high|        medium|</span><br><span class="line">|[5.0,0.74,0.0,1.2...|medium|        medium|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Evaluation</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = MulticlassClassificationEvaluator(</span><br><span class="line">    labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;)</span><br><span class="line">accuracy = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Test Error = %g&quot; % (1.0 - accuracy))</span><br><span class="line"></span><br><span class="line">rfModel = model.stages[-2]</span><br><span class="line">print(rfModel)  # summary only</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test Error = 0.45509</span><br><span class="line">DecisionTreeClassificationModel (uid=DecisionTreeClassifier_4545ac8dca9c8438ef2a)</span><br><span class="line">of depth 5 with 59 nodes</span><br></pre></td></tr></table></figure><ol><li>visualization</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def plot_confusion_matrix(cm, classes,</span><br><span class="line">                          normalize=False,</span><br><span class="line">                          title=&apos;Confusion matrix&apos;,</span><br><span class="line">                          cmap=plt.cm.Blues):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function prints and plots the confusion matrix.</span><br><span class="line">    Normalization can be applied by setting `normalize=True`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if normalize:</span><br><span class="line">        cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]</span><br><span class="line">        print(&quot;Normalized confusion matrix&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line"></span><br><span class="line">    print(cm)</span><br><span class="line"></span><br><span class="line">    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=45)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = &apos;.2f&apos; if normalize else &apos;d&apos;</span><br><span class="line">    thresh = cm.max() / 2.</span><br><span class="line">    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=&quot;center&quot;,</span><br><span class="line">                 color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(&apos;True label&apos;)</span><br><span class="line">    plt.xlabel(&apos;Predicted label&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_temp = predictions.select(&quot;label&quot;).groupBy(&quot;label&quot;)\</span><br><span class="line">                        .count().sort(&apos;count&apos;, ascending=False).toPandas()</span><br><span class="line">class_temp = class_temp[&quot;label&quot;].values.tolist()</span><br><span class="line">class_names = map(str, class_temp)</span><br><span class="line"># # # print(class_name)</span><br><span class="line">class_names</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;medium&apos;, &apos;high&apos;, &apos;low&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">y_true = predictions.select(&quot;label&quot;)</span><br><span class="line">y_true = y_true.toPandas()</span><br><span class="line"></span><br><span class="line">y_pred = predictions.select(&quot;predictedLabel&quot;)</span><br><span class="line">y_pred = y_pred.toPandas()</span><br><span class="line"></span><br><span class="line">cnf_matrix = confusion_matrix(y_true, y_pred,labels=class_names)</span><br><span class="line">cnf_matrix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[497,  29,   7],</span><br><span class="line">       [ 40,  42,   0],</span><br><span class="line">       [ 22,   0,   2]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Plot non-normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names,</span><br><span class="line">                      title=&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Confusion matrix, without normalization</span><br><span class="line">[[497  29   7]</span><br><span class="line"> [ 40  42   0]</span><br><span class="line"> [ 22   0   2]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/94b77459ef6ab620703ddb014430c700.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/dt_cm_c3.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Plot normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,</span><br><span class="line">                      title=&apos;Normalized confusion matrix&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Normalized confusion matrix</span><br><span class="line">[[ 0.93245779  0.05440901  0.01313321]</span><br><span class="line"> [ 0.48780488  0.51219512  0\.        ]</span><br><span class="line"> [ 0.91666667  0\.          0.08333333]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/94b77459ef6ab620703ddb014430c700.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/dt_cm_c3.png"></p><h2 id="10-4-Random-forest-Classification"><a href="#10-4-Random-forest-Classification" class="headerlink" title="10.4. Random forest Classification"></a>10.4. Random forest Classification</h2><h3 id="10-4-1-Introduction"><a href="#10-4-1-Introduction" class="headerlink" title="10.4.1. Introduction"></a>10.4.1. Introduction</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/2Mg8QD0F1dQ" frameborder="0" allowfullscreen></iframe><h3 id="10-4-2-Demo"><a href="#10-4-2-Demo" class="headerlink" title="10.4.2. Demo"></a>10.4.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/RandomForestC3.ipynb">Random forest Classification</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.RandomForestClassifier.html" target="_blank" rel="noopener">RandomForestClassifier API</a> .</li></ul><ol><li>Set up spark context and SparkSession</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">        spark = SparkSession \</span><br><span class="line">            .builder \</span><br><span class="line">            .appName(&quot;Python Spark Decision Tree classification&quot;) \</span><br><span class="line">            .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">            .getOrCreate()</span><br></pre></td></tr></table></figure><ol><li>Load dataset</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;).\</span><br><span class="line">                               options(header=&apos;true&apos;, \</span><br><span class="line">                               inferschema=&apos;true&apos;) \</span><br><span class="line">                .load(&quot;../data/WineData2.csv&quot;,header=True);</span><br><span class="line">df.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8|      5|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8|      5|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8|      6|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Convert to float format</span><br><span class="line">def string_to_float(x):</span><br><span class="line">    return float(x)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def condition(r):</span><br><span class="line">    if (0&lt;= r &lt;= 4):</span><br><span class="line">        label = &quot;low&quot;</span><br><span class="line">    elif(4&lt; r &lt;= 6):</span><br><span class="line">        label = &quot;medium&quot;</span><br><span class="line">    else:</span><br><span class="line">        label = &quot;high&quot;</span><br><span class="line">    return label</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql.functions import udf</span><br><span class="line">from pyspark.sql.types import StringType, DoubleType</span><br><span class="line">string_to_float_udf = udf(string_to_float, DoubleType())</span><br><span class="line">quality_udf = udf(lambda x: condition(x), StringType())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = df.withColumn(&quot;quality&quot;, quality_udf(&quot;quality&quot;))</span><br><span class="line">df.show(5,True)</span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8| medium|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8| medium|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8| medium|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><ol><li>Convert the data to dense vector</li></ol><p>Note</p><p>You are strongly encouraged to try my <code>get_dummy</code> function for dealing with the categorical data in complex dataset.</p><p>Supervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line">&gt; </span><br><span class="line">&gt;  from pyspark.ml import Pipeline</span><br><span class="line">&gt;  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">&gt;  from pyspark.sql.functions import col</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Unsupervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt;  Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">&gt;  :param df: the dataframe</span><br><span class="line">&gt;  :param categoricalCols: the name list of the categorical data</span><br><span class="line">&gt;  :param continuousCols:  the name list of the numerical data</span><br><span class="line">&gt;  :return k: feature matrix</span><br><span class="line">&gt; </span><br><span class="line">&gt;  :author: Wenqiang Feng</span><br><span class="line">&gt;  :email:  von198@gmail.com</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># !!!!caution: not from pyspark.mllib.linalg import Vectors</span><br><span class="line">from pyspark.ml.linalg import Vectors</span><br><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.feature import IndexToString,StringIndexer, VectorIndexer</span><br><span class="line">from pyspark.ml.tuning import CrossValidator, ParamGridBuilder</span><br><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def transData(data):</span><br><span class="line">    return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><ol><li>Transform the dataset to DataFrame</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed = transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Deal with Categorical Label and Variables</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Index labels, adding metadata to the label column</span><br><span class="line">labelIndexer = StringIndexer(inputCol=&apos;label&apos;,</span><br><span class="line">                             outputCol=&apos;indexedLabel&apos;).fit(transformed)</span><br><span class="line">labelIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+------------+</span><br><span class="line">|            features| label|indexedLabel|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|         0.0|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|         0.0|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|         0.0|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|         0.0|</span><br><span class="line">+--------------------+------+------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    # Automatically identify categorical features, and index them.</span><br><span class="line">    # Set maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line">    featureIndexer =VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                                  outputCol=&quot;indexedFeatures&quot;, \</span><br><span class="line">                                  maxCategories=4).fit(transformed)</span><br><span class="line">featureIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|            features| label|     indexedFeatures|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|medium|[7.8,0.88,0.0,2.6...|</span><br><span class="line">|[7.8,0.76,0.04,2....|medium|[7.8,0.76,0.04,2....|</span><br><span class="line">|[11.2,0.28,0.56,1...|medium|[11.2,0.28,0.56,1...|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|medium|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">+--------------------+------+--------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Split the data to training and test data sets</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = transformed.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5)</span><br><span class="line">testData.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[4.6,0.52,0.15,2....|   low|</span><br><span class="line">|[4.7,0.6,0.17,2.3...|medium|</span><br><span class="line">|[5.0,1.02,0.04,1....|   low|</span><br><span class="line">|[5.0,1.04,0.24,1....|medium|</span><br><span class="line">|[5.1,0.585,0.0,1....|  high|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+--------------------+------+</span><br><span class="line">|            features| label|</span><br><span class="line">+--------------------+------+</span><br><span class="line">|[4.9,0.42,0.0,2.1...|  high|</span><br><span class="line">|[5.0,0.38,0.01,1....|medium|</span><br><span class="line">|[5.0,0.4,0.5,4.3,...|medium|</span><br><span class="line">|[5.0,0.42,0.24,2....|  high|</span><br><span class="line">|[5.0,0.74,0.0,1.2...|medium|</span><br><span class="line">+--------------------+------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Fit Random Forest Classification Model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.classification import RandomForestClassifier</span><br><span class="line"></span><br><span class="line"># Train a RandomForest model.</span><br><span class="line">rf = RandomForestClassifier(labelCol=&quot;indexedLabel&quot;, featuresCol=&quot;indexedFeatures&quot;, numTrees=10)</span><br></pre></td></tr></table></figure><ol><li>Pipeline Architecture</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Convert indexed labels back to original labels.</span><br><span class="line">labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;,</span><br><span class="line">                               labels=labelIndexer.labels)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexers and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[labelIndexer, featureIndexer, rf,labelConverter])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Train model.  This also runs the indexers.</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><ol><li>Make predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+------+--------------+</span><br><span class="line">|            features| label|predictedLabel|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">|[4.9,0.42,0.0,2.1...|  high|          high|</span><br><span class="line">|[5.0,0.38,0.01,1....|medium|        medium|</span><br><span class="line">|[5.0,0.4,0.5,4.3,...|medium|        medium|</span><br><span class="line">|[5.0,0.42,0.24,2....|  high|        medium|</span><br><span class="line">|[5.0,0.74,0.0,1.2...|medium|        medium|</span><br><span class="line">+--------------------+------+--------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Evaluation</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = MulticlassClassificationEvaluator(</span><br><span class="line">    labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;)</span><br><span class="line">accuracy = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Test Error = %g&quot; % (1.0 - accuracy))</span><br><span class="line"></span><br><span class="line">rfModel = model.stages[-2]</span><br><span class="line">print(rfModel)  # summary only</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test Error = 0.173502</span><br><span class="line">RandomForestClassificationModel (uid=rfc_a3395531f1d2) with 10 trees</span><br></pre></td></tr></table></figure><ol><li>visualization</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def plot_confusion_matrix(cm, classes,</span><br><span class="line">                          normalize=False,</span><br><span class="line">                          title=&apos;Confusion matrix&apos;,</span><br><span class="line">                          cmap=plt.cm.Blues):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function prints and plots the confusion matrix.</span><br><span class="line">    Normalization can be applied by setting `normalize=True`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if normalize:</span><br><span class="line">        cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]</span><br><span class="line">        print(&quot;Normalized confusion matrix&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line"></span><br><span class="line">    print(cm)</span><br><span class="line"></span><br><span class="line">    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=45)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = &apos;.2f&apos; if normalize else &apos;d&apos;</span><br><span class="line">    thresh = cm.max() / 2.</span><br><span class="line">    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=&quot;center&quot;,</span><br><span class="line">                 color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(&apos;True label&apos;)</span><br><span class="line">    plt.xlabel(&apos;Predicted label&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_temp = predictions.select(&quot;label&quot;).groupBy(&quot;label&quot;)\</span><br><span class="line">                        .count().sort(&apos;count&apos;, ascending=False).toPandas()</span><br><span class="line">class_temp = class_temp[&quot;label&quot;].values.tolist()</span><br><span class="line">class_names = map(str, class_temp)</span><br><span class="line"># # # print(class_name)</span><br><span class="line">class_names</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;medium&apos;, &apos;high&apos;, &apos;low&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">y_true = predictions.select(&quot;label&quot;)</span><br><span class="line">y_true = y_true.toPandas()</span><br><span class="line"></span><br><span class="line">y_pred = predictions.select(&quot;predictedLabel&quot;)</span><br><span class="line">y_pred = y_pred.toPandas()</span><br><span class="line"></span><br><span class="line">cnf_matrix = confusion_matrix(y_true, y_pred,labels=class_names)</span><br><span class="line">cnf_matrix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[502,   9,   0],</span><br><span class="line">       [ 73,  22,   0],</span><br><span class="line">       [ 28,   0,   0]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Plot non-normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names,</span><br><span class="line">                      title=&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Confusion matrix, without normalization</span><br><span class="line">[[502   9   0]</span><br><span class="line"> [ 73  22   0]</span><br><span class="line"> [ 28   0   0]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/3c62f7e72a479ae0b82768c51bdc2830.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/rf_cm_c3.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Plot normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,</span><br><span class="line">                      title=&apos;Normalized confusion matrix&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Normalized confusion matrix</span><br><span class="line">[[ 0.98238748  0.01761252  0\.        ]</span><br><span class="line"> [ 0.76842105  0.23157895  0\.        ]</span><br><span class="line"> [ 1\.          0\.          0\.        ]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/3c62f7e72a479ae0b82768c51bdc2830.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/rf_cm_c3.png"></p><h2 id="10-5-Gradient-boosted-tree-Classification"><a href="#10-5-Gradient-boosted-tree-Classification" class="headerlink" title="10.5. Gradient-boosted tree Classification"></a>10.5. Gradient-boosted tree Classification</h2><h3 id="10-5-1-Introduction"><a href="#10-5-1-Introduction" class="headerlink" title="10.5.1. Introduction"></a>10.5.1. Introduction</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/GM3CDQfQ4sw" frameborder="0" allowfullscreen></iframe><h3 id="10-5-2-Demo"><a href="#10-5-2-Demo" class="headerlink" title="10.5.2. Demo"></a>10.5.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/gbtC3.ipynb">Gradient boosted tree Classification</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.GBTClassifier.html" target="_blank" rel="noopener">GBTClassifier API</a> .</li></ul><p>Warning</p><p>Unfortunately, the GBTClassifier currently only supports binary labels.</p><h2 id="10-6-XGBoost-Gradient-boosted-tree-Classification"><a href="#10-6-XGBoost-Gradient-boosted-tree-Classification" class="headerlink" title="10.6. XGBoost: Gradient-boosted tree Classification"></a>10.6. XGBoost: Gradient-boosted tree Classification</h2><h3 id="10-6-1-Introduction"><a href="#10-6-1-Introduction" class="headerlink" title="10.6.1. Introduction"></a>10.6.1. Introduction</h3><h3 id="10-6-2-Demo"><a href="#10-6-2-Demo" class="headerlink" title="10.6.2. Demo"></a>10.6.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/gbtC3.ipynb">Gradient boosted tree Classification</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.GBTClassifier.html" target="_blank" rel="noopener">GBTClassifier API</a> .</li></ul><p>Warning</p><p>Unfortunately, I didn’t find a good way to setup the XGBoost directly in Spark. But I do get the XGBoost work with <code>pysparkling</code> on my machine.</p><ol><li>Start H2O cluster inside the Spark environment</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pysparkling import *</span><br><span class="line">hc = H2OContext.getOrCreate(spark)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Connecting to H2O server at http://192.168.0.102:54323... successful.</span><br><span class="line">H2O cluster uptime:     07 secs</span><br><span class="line">H2O cluster timezone:   America/Chicago</span><br><span class="line">H2O data parsing timezone:      UTC</span><br><span class="line">H2O cluster version:    3.22.1.3</span><br><span class="line">H2O cluster version age:        20 days</span><br><span class="line">H2O cluster name:       sparkling-water-dt216661_local-1550259209801</span><br><span class="line">H2O cluster total nodes:        1</span><br><span class="line">H2O cluster free memory:        848 Mb</span><br><span class="line">H2O cluster total cores:        8</span><br><span class="line">H2O cluster allowed cores:      8</span><br><span class="line">H2O cluster status:     accepting new members, healthy</span><br><span class="line">H2O connection url:     http://192.168.0.102:54323</span><br><span class="line">H2O connection proxy:   None</span><br><span class="line">H2O internal security:  False</span><br><span class="line">H2O API Extensions:     XGBoost, Algos, AutoML, Core V3, Core V4</span><br><span class="line">Python version: 3.7.1 final</span><br><span class="line"></span><br><span class="line">Sparkling Water Context:</span><br><span class="line"> * H2O name: sparkling-water-dt216661_local-1550259209801</span><br><span class="line"> * cluster size: 1</span><br><span class="line"> * list of used nodes:</span><br><span class="line">  (executorId, host, port)</span><br><span class="line">  ------------------------</span><br><span class="line">  (driver,192.168.0.102,54323)</span><br><span class="line">  ------------------------</span><br><span class="line"></span><br><span class="line">  Open H2O Flow in browser: http://192.168.0.102:54323 (CMD + click in Mac OSX)</span><br></pre></td></tr></table></figure><ol><li>Parse the data using H2O and convert them to Spark Frame</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import h2o</span><br><span class="line">frame = h2o.import_file(&quot;https://raw.githubusercontent.com/h2oai/sparkling-water/master/examples/smalldata/prostate/prostate.csv&quot;)</span><br><span class="line">spark_frame = hc.as_spark_frame(frame)</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/aed7e56b0a3e63a84e53c79df4f79b0e.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/sparling_process.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark_frame.show(4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---+-------+---+----+-----+-----+----+----+-------+</span><br><span class="line">| ID|CAPSULE|AGE|RACE|DPROS|DCAPS| PSA| VOL|GLEASON|</span><br><span class="line">+---+-------+---+----+-----+-----+----+----+-------+</span><br><span class="line">|  1|      0| 65|   1|    2|    1| 1.4| 0.0|      6|</span><br><span class="line">|  2|      0| 72|   1|    3|    2| 6.7| 0.0|      7|</span><br><span class="line">|  3|      0| 70|   1|    1|    2| 4.9| 0.0|      6|</span><br><span class="line">|  4|      0| 76|   2|    2|    1|51.2|20.0|      7|</span><br><span class="line">+---+-------+---+----+-----+-----+----+----+-------+</span><br><span class="line">only showing top 4 rows</span><br></pre></td></tr></table></figure><ol><li>Train the model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pysparkling.ml import H2OXGBoost</span><br><span class="line">estimator = H2OXGBoost(predictionCol=&quot;AGE&quot;)</span><br><span class="line">model = estimator.fit(spark_frame)</span><br></pre></td></tr></table></figure><ol><li>Run Predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.transform(spark_frame)</span><br><span class="line">predictions.show(4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---+-------+---+----+-----+-----+----+----+-------+-------------------+</span><br><span class="line">| ID|CAPSULE|AGE|RACE|DPROS|DCAPS| PSA| VOL|GLEASON|  prediction_output|</span><br><span class="line">+---+-------+---+----+-----+-----+----+----+-------+-------------------+</span><br><span class="line">|  1|      0| 65|   1|    2|    1| 1.4| 0.0|      6|[64.85852813720703]|</span><br><span class="line">|  2|      0| 72|   1|    3|    2| 6.7| 0.0|      7| [72.0611801147461]|</span><br><span class="line">|  3|      0| 70|   1|    1|    2| 4.9| 0.0|      6|[70.26496887207031]|</span><br><span class="line">|  4|      0| 76|   2|    2|    1|51.2|20.0|      7|[75.26521301269531]|</span><br><span class="line">+---+-------+---+----+-----+-----+----+----+-------+-------------------+</span><br><span class="line">only showing top 4 rows</span><br></pre></td></tr></table></figure><h2 id="10-7-Naive-Bayes-Classification"><a href="#10-7-Naive-Bayes-Classification" class="headerlink" title="10.7. Naive Bayes Classification"></a>10.7. Naive Bayes Classification</h2><h3 id="10-7-1-Introduction"><a href="#10-7-1-Introduction" class="headerlink" title="10.7.1. Introduction"></a>10.7.1. Introduction</h3><h3 id="10-7-2-Demo"><a href="#10-7-2-Demo" class="headerlink" title="10.7.2. Demo"></a>10.7.2. Demo</h3><ul><li>The Jupyter notebook can be download from <a href="_static/NaiveBayes.ipynb">Naive Bayes Classification</a>.</li><li>For more details, please visit <a href="http://takwatanabe.me/pyspark/generated/generated/ml.classification.NaiveBayes.html" target="_blank" rel="noopener">NaiveBayes API</a> .</li></ul><ol><li>Set up spark context and SparkSession</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(&quot;Python Spark  Naive Bayes classification&quot;) \</span><br><span class="line">    .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure><ol><li>Load dataset</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.format(&apos;com.databricks.spark.csv&apos;) \</span><br><span class="line">            .options(header=&apos;true&apos;, inferschema=&apos;true&apos;) \</span><br><span class="line">            .load(&quot;./data/WineData2.csv&quot;,header=True);</span><br><span class="line">df.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8|      5|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8|      5|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8|      6|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4|      5|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Convert to float format</span><br><span class="line">def string_to_float(x):</span><br><span class="line">    return float(x)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def condition(r):</span><br><span class="line">    if (0&lt;= r &lt;= 6):</span><br><span class="line">        label = &quot;low&quot;</span><br><span class="line">    else:</span><br><span class="line">        label = &quot;high&quot;</span><br><span class="line">    return label</span><br><span class="line"></span><br><span class="line">from pyspark.sql.functions import udf</span><br><span class="line">from pyspark.sql.types import StringType, DoubleType</span><br><span class="line">string_to_float_udf = udf(string_to_float, DoubleType())</span><br><span class="line">quality_udf = udf(lambda x: condition(x), StringType())</span><br><span class="line"></span><br><span class="line">df = df.withColumn(&quot;quality&quot;, quality_udf(&quot;quality&quot;))</span><br><span class="line"></span><br><span class="line">df.show(5,True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|fixed|volatile|citric|sugar|chlorides|free|total|density|  pH|sulphates|alcohol|quality|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">|  7.8|    0.88|   0.0|  2.6|    0.098|25.0| 67.0| 0.9968| 3.2|     0.68|    9.8| medium|</span><br><span class="line">|  7.8|    0.76|  0.04|  2.3|    0.092|15.0| 54.0|  0.997|3.26|     0.65|    9.8| medium|</span><br><span class="line">| 11.2|    0.28|  0.56|  1.9|    0.075|17.0| 60.0|  0.998|3.16|     0.58|    9.8| medium|</span><br><span class="line">|  7.4|     0.7|   0.0|  1.9|    0.076|11.0| 34.0| 0.9978|3.51|     0.56|    9.4| medium|</span><br><span class="line">+-----+--------+------+-----+---------+----+-----+-------+----+---------+-------+-------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- fixed: double (nullable = true)</span><br><span class="line"> |-- volatile: double (nullable = true)</span><br><span class="line"> |-- citric: double (nullable = true)</span><br><span class="line"> |-- sugar: double (nullable = true)</span><br><span class="line"> |-- chlorides: double (nullable = true)</span><br><span class="line"> |-- free: double (nullable = true)</span><br><span class="line"> |-- total: double (nullable = true)</span><br><span class="line"> |-- density: double (nullable = true)</span><br><span class="line"> |-- pH: double (nullable = true)</span><br><span class="line"> |-- sulphates: double (nullable = true)</span><br><span class="line"> |-- alcohol: double (nullable = true)</span><br><span class="line"> |-- quality: string (nullable = true)</span><br></pre></td></tr></table></figure><ol><li>Deal with categorical data and Convert the data to dense vector</li></ol><p>Note</p><p>You are strongly encouraged to try my <code>get_dummy</code> function for dealing with the categorical data in complex dataset.</p><p>Supervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols,labelCol):</span><br><span class="line">&gt; </span><br><span class="line">&gt;  from pyspark.ml import Pipeline</span><br><span class="line">&gt;  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">&gt;  from pyspark.sql.functions import col</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;,&apos;label&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Unsupervised learning version:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def get_dummy(df,indexCol,categoricalCols,continuousCols):</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt;  Get dummy variables and concat with continuous variables for unsupervised learning.</span><br><span class="line">&gt;  :param df: the dataframe</span><br><span class="line">&gt;  :param categoricalCols: the name list of the categorical data</span><br><span class="line">&gt;  :param continuousCols:  the name list of the numerical data</span><br><span class="line">&gt;  :return k: feature matrix</span><br><span class="line">&gt; </span><br><span class="line">&gt;  :author: Wenqiang Feng</span><br><span class="line">&gt;  :email:  von198@gmail.com</span><br><span class="line">&gt;  &apos;&apos;&apos;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">&gt;               for c in categoricalCols ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  # default setting: dropLast=True</span><br><span class="line">&gt;  encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">&gt;               outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">&gt;               for indexer in indexers ]</span><br><span class="line">&gt; </span><br><span class="line">&gt;  assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">&gt;                                 + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line">&gt; </span><br><span class="line">&gt;     model=pipeline.fit(df)</span><br><span class="line">&gt;     data = model.transform(df)</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return data.select(indexCol,&apos;features&apos;)</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_dummy(df,categoricalCols,continuousCols,labelCol):</span><br><span class="line"></span><br><span class="line">    from pyspark.ml import Pipeline</span><br><span class="line">    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler</span><br><span class="line">    from pyspark.sql.functions import col</span><br><span class="line"></span><br><span class="line">    indexers = [ StringIndexer(inputCol=c, outputCol=&quot;&#123;0&#125;_indexed&quot;.format(c))</span><br><span class="line">                 for c in categoricalCols ]</span><br><span class="line"></span><br><span class="line">    # default setting: dropLast=True</span><br><span class="line">    encoders = [ OneHotEncoder(inputCol=indexer.getOutputCol(),</span><br><span class="line">                 outputCol=&quot;&#123;0&#125;_encoded&quot;.format(indexer.getOutputCol()))</span><br><span class="line">                 for indexer in indexers ]</span><br><span class="line"></span><br><span class="line">    assembler = VectorAssembler(inputCols=[encoder.getOutputCol() for encoder in encoders]</span><br><span class="line">                                + continuousCols, outputCol=&quot;features&quot;)</span><br><span class="line"></span><br><span class="line">    pipeline = Pipeline(stages=indexers + encoders + [assembler])</span><br><span class="line"></span><br><span class="line">    model=pipeline.fit(df)</span><br><span class="line">    data = model.transform(df)</span><br><span class="line"></span><br><span class="line">    data = data.withColumn(&apos;label&apos;,col(labelCol))</span><br><span class="line"></span><br><span class="line">    return data.select(&apos;features&apos;,&apos;label&apos;)</span><br></pre></td></tr></table></figure><ol><li>Transform the dataset to DataFrame</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.linalg import Vectors # !!!!caution: not from pyspark.mllib.linalg import Vectors</span><br><span class="line">from pyspark.ml import Pipeline</span><br><span class="line">from pyspark.ml.feature import IndexToString,StringIndexer, VectorIndexer</span><br><span class="line">from pyspark.ml.tuning import CrossValidator, ParamGridBuilder</span><br><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line">def transData(data):</span><br><span class="line">return data.rdd.map(lambda r: [Vectors.dense(r[:-1]),r[-1]]).toDF([&apos;features&apos;,&apos;label&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformed = transData(df)</span><br><span class="line">transformed.show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+</span><br><span class="line">|            features|label|</span><br><span class="line">+--------------------+-----+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|  low|</span><br><span class="line">|[7.8,0.76,0.04,2....|  low|</span><br><span class="line">|[11.2,0.28,0.56,1...|  low|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|</span><br><span class="line">+--------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Deal with Categorical Label and Variables</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Index labels, adding metadata to the label column</span><br><span class="line">labelIndexer = StringIndexer(inputCol=&apos;label&apos;,</span><br><span class="line">                             outputCol=&apos;indexedLabel&apos;).fit(transformed)</span><br><span class="line">labelIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+------------+</span><br><span class="line">|            features|label|indexedLabel|</span><br><span class="line">+--------------------+-----+------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|         0.0|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|  low|         0.0|</span><br><span class="line">|[7.8,0.76,0.04,2....|  low|         0.0|</span><br><span class="line">|[11.2,0.28,0.56,1...|  low|         0.0|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|         0.0|</span><br><span class="line">+--------------------+-----+------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Automatically identify categorical features, and index them.</span><br><span class="line"># Set maxCategories so features with &gt; 4 distinct values are treated as continuous.</span><br><span class="line">featureIndexer =VectorIndexer(inputCol=&quot;features&quot;, \</span><br><span class="line">                              outputCol=&quot;indexedFeatures&quot;, \</span><br><span class="line">                              maxCategories=4).fit(transformed)</span><br><span class="line">featureIndexer.transform(transformed).show(5, True)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">|            features|label|     indexedFeatures|</span><br><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">|[7.8,0.88,0.0,2.6...|  low|[7.8,0.88,0.0,2.6...|</span><br><span class="line">|[7.8,0.76,0.04,2....|  low|[7.8,0.76,0.04,2....|</span><br><span class="line">|[11.2,0.28,0.56,1...|  low|[11.2,0.28,0.56,1...|</span><br><span class="line">|[7.4,0.7,0.0,1.9,...|  low|[7.4,0.7,0.0,1.9,...|</span><br><span class="line">+--------------------+-----+--------------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Split the data to training and test data sets</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Split the data into training and test sets (40% held out for testing)</span><br><span class="line">(trainingData, testData) = data.randomSplit([0.6, 0.4])</span><br><span class="line"></span><br><span class="line">trainingData.show(5,False)</span><br><span class="line">testData.show(5,False)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">|features                                                 |label|</span><br><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">|[5.0,0.38,0.01,1.6,0.048,26.0,60.0,0.99084,3.7,0.75,14.0]|low  |</span><br><span class="line">|[5.0,0.42,0.24,2.0,0.06,19.0,50.0,0.9917,3.72,0.74,14.0] |high |</span><br><span class="line">|[5.0,0.74,0.0,1.2,0.041,16.0,46.0,0.99258,4.01,0.59,12.5]|low  |</span><br><span class="line">|[5.0,1.02,0.04,1.4,0.045,41.0,85.0,0.9938,3.75,0.48,10.5]|low  |</span><br><span class="line">|[5.0,1.04,0.24,1.6,0.05,32.0,96.0,0.9934,3.74,0.62,11.5] |low  |</span><br><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">|features                                                 |label|</span><br><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">|[4.6,0.52,0.15,2.1,0.054,8.0,65.0,0.9934,3.9,0.56,13.1]  |low  |</span><br><span class="line">|[4.7,0.6,0.17,2.3,0.058,17.0,106.0,0.9932,3.85,0.6,12.9] |low  |</span><br><span class="line">|[4.9,0.42,0.0,2.1,0.048,16.0,42.0,0.99154,3.71,0.74,14.0]|high |</span><br><span class="line">|[5.0,0.4,0.5,4.3,0.046,29.0,80.0,0.9902,3.49,0.66,13.6]  |low  |</span><br><span class="line">|[5.2,0.49,0.26,2.3,0.09,23.0,74.0,0.9953,3.71,0.62,12.2] |low  |</span><br><span class="line">+---------------------------------------------------------+-----+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Fit Naive Bayes Classification Model</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.classification import NaiveBayes</span><br><span class="line">nb = NaiveBayes(featuresCol=&apos;indexedFeatures&apos;, labelCol=&apos;indexedLabel&apos;)</span><br></pre></td></tr></table></figure><ol><li>Pipeline Architecture</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Convert indexed labels back to original labels.</span><br><span class="line">labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;,</span><br><span class="line">                               labels=labelIndexer.labels)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Chain indexers and tree in a Pipeline</span><br><span class="line">pipeline = Pipeline(stages=[labelIndexer, featureIndexer, nb,labelConverter])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Train model.  This also runs the indexers.</span><br><span class="line">model = pipeline.fit(trainingData)</span><br></pre></td></tr></table></figure><ol><li>Make predictions</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Make predictions.</span><br><span class="line">predictions = model.transform(testData)</span><br><span class="line"># Select example rows to display.</span><br><span class="line">predictions.select(&quot;features&quot;,&quot;label&quot;,&quot;predictedLabel&quot;).show(5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+--------------+</span><br><span class="line">|            features|label|predictedLabel|</span><br><span class="line">+--------------------+-----+--------------+</span><br><span class="line">|[4.6,0.52,0.15,2....|  low|           low|</span><br><span class="line">|[4.7,0.6,0.17,2.3...|  low|           low|</span><br><span class="line">|[4.9,0.42,0.0,2.1...| high|           low|</span><br><span class="line">|[5.0,0.4,0.5,4.3,...|  low|           low|</span><br><span class="line">|[5.2,0.49,0.26,2....|  low|           low|</span><br><span class="line">+--------------------+-----+--------------+</span><br><span class="line">only showing top 5 rows</span><br></pre></td></tr></table></figure><ol><li>Evaluation</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><br><span class="line"></span><br><span class="line"># Select (prediction, true label) and compute test error</span><br><span class="line">evaluator = MulticlassClassificationEvaluator(</span><br><span class="line">    labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;)</span><br><span class="line">accuracy = evaluator.evaluate(predictions)</span><br><span class="line">print(&quot;Test Error = %g&quot; % (1.0 - accuracy))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test Error = 0.307339</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lrModel = model.stages[2]</span><br><span class="line">trainingSummary = lrModel.summary</span><br><span class="line"></span><br><span class="line"># Obtain the objective per iteration</span><br><span class="line"># objectiveHistory = trainingSummary.objectiveHistory</span><br><span class="line"># print(&quot;objectiveHistory:&quot;)</span><br><span class="line"># for objective in objectiveHistory:</span><br><span class="line">#     print(objective)</span><br><span class="line"></span><br><span class="line"># Obtain the receiver-operating characteristic as a dataframe and areaUnderROC.</span><br><span class="line">trainingSummary.roc.show(5)</span><br><span class="line">print(&quot;areaUnderROC: &quot; + str(trainingSummary.areaUnderROC))</span><br><span class="line"></span><br><span class="line"># Set the model threshold to maximize F-Measure</span><br><span class="line">fMeasure = trainingSummary.fMeasureByThreshold</span><br><span class="line">maxFMeasure = fMeasure.groupBy().max(&apos;F-Measure&apos;).select(&apos;max(F-Measure)&apos;).head(5)</span><br><span class="line"># bestThreshold = fMeasure.where(fMeasure[&apos;F-Measure&apos;] == maxFMeasure[&apos;max(F-Measure)&apos;]) \</span><br><span class="line">#     .select(&apos;threshold&apos;).head()[&apos;threshold&apos;]</span><br><span class="line"># lr.setThreshold(bestThreshold)</span><br></pre></td></tr></table></figure><p>You can use <code>z.show()</code> to get the data and plot the ROC curves:</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/4ae661a05a9586c4ce7b5eabf4bab417.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc_z.png"></p><p>You can also register a TempTable <code>data.registerTempTable(&#39;roc_data&#39;)</code> and then use <code>sql</code> to plot the ROC curve:</p><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/b7d7ca35788d7bfb804b5b230a76af8c.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/roc.png"></p><ol><li>visualization</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def plot_confusion_matrix(cm, classes,</span><br><span class="line">                          normalize=False,</span><br><span class="line">                          title=&apos;Confusion matrix&apos;,</span><br><span class="line">                          cmap=plt.cm.Blues):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This function prints and plots the confusion matrix.</span><br><span class="line">    Normalization can be applied by setting `normalize=True`.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if normalize:</span><br><span class="line">        cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]</span><br><span class="line">        print(&quot;Normalized confusion matrix&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line"></span><br><span class="line">    print(cm)</span><br><span class="line"></span><br><span class="line">    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=45)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = &apos;.2f&apos; if normalize else &apos;d&apos;</span><br><span class="line">    thresh = cm.max() / 2.</span><br><span class="line">    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=&quot;center&quot;,</span><br><span class="line">                 color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.ylabel(&apos;True label&apos;)</span><br><span class="line">    plt.xlabel(&apos;Predicted label&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_temp = predictions.select(&quot;label&quot;).groupBy(&quot;label&quot;)\</span><br><span class="line">                        .count().sort(&apos;count&apos;, ascending=False).toPandas()</span><br><span class="line">class_temp = class_temp[&quot;label&quot;].values.tolist()</span><br><span class="line">class_names = map(str, class_temp)</span><br><span class="line"># # # print(class_name)</span><br><span class="line">class_names</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;low&apos;, &apos;high&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line">y_true = predictions.select(&quot;label&quot;)</span><br><span class="line">y_true = y_true.toPandas()</span><br><span class="line"></span><br><span class="line">y_pred = predictions.select(&quot;predictedLabel&quot;)</span><br><span class="line">y_pred = y_pred.toPandas()</span><br><span class="line"></span><br><span class="line">cnf_matrix = confusion_matrix(y_true, y_pred,labels=class_names)</span><br><span class="line">cnf_matrix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[392, 169],</span><br><span class="line">       [ 32,  61]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Plot non-normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names,</span><br><span class="line">                      title=&apos;Confusion matrix, without normalization&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Confusion matrix, without normalization</span><br><span class="line">[[392 169]</span><br><span class="line"> [ 32  61]]</span><br></pre></td></tr></table></figure><p><img src="G:/PYthonLearning/learning-pyspark-zh-master/docs/img/0e33aec96020afa0297be6d91db0d5d8.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/nb_c1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Plot normalized confusion matrix</span><br><span class="line">plt.figure()</span><br><span class="line">plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,</span><br><span class="line">                      title=&apos;Normalized confusion matrix&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Normalized confusion matrix</span><br><span class="line">[[0.69875223 0.30124777]</span><br><span class="line"> [0.34408602 0.65591398]]</span><br></pre></td></tr></table></figure><p><img src="img/9b41f0fbb97ef7ddd6383753e6ad1c26.jpg" alt="https://runawayhorse001.github.io/LearningApacheSpark/_images/nb_c2.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PySpark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天池-饿了么智慧物流</title>
      <link href="/2020/04/11/%E5%A4%A9%E6%B1%A0-%E9%A5%BF%E4%BA%86%E4%B9%88/"/>
      <url>/2020/04/11/%E5%A4%A9%E6%B1%A0-%E9%A5%BF%E4%BA%86%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="top-5"><a href="#top-5" class="headerlink" title="top 5%"></a>top 5%</h1><p><img src="https://s1.ax1x.com/2020/04/24/Jrp4pj.jpg" alt="Jrp4pj.jpg"><br><img src="https://s1.ax1x.com/2020/04/24/JrpfhQ.jpg" alt="JrpfhQ.jpg"></p><p>1.feature</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.utils <span class="keyword">import</span> shuffle</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1_featuretask</span><span class="params">(train_path,test_path)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------文件读取----------------------'</span>)</span><br><span class="line">    <span class="comment"># 读取数据并加入date列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_datafile</span><span class="params">(rootpath, selct)</span>:</span></span><br><span class="line">        file_path = rootpath + selct + <span class="string">'/'</span></span><br><span class="line">        data_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(file_path):</span><br><span class="line">            date = f.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">'_'</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> selct == <span class="string">'action'</span>:</span><br><span class="line">                df = pd.read_csv(file_path + f, converters=&#123;<span class="string">'tracking_id'</span>: str&#125;)</span><br><span class="line">            <span class="keyword">elif</span> selct == <span class="string">'order'</span>:</span><br><span class="line">                df = pd.read_csv(file_path + f, converters=&#123;<span class="string">'tracking_id'</span>: str&#125;)</span><br><span class="line">            <span class="keyword">elif</span> selct == <span class="string">'courier'</span>:</span><br><span class="line">                df = pd.read_csv(file_path + f)</span><br><span class="line">            <span class="keyword">elif</span> selct == <span class="string">'distance'</span>:</span><br><span class="line">                df = pd.read_csv(file_path + f, converters=&#123;<span class="string">'tracking_id'</span>: str, <span class="string">'target_tracking_id'</span>: str&#125;)</span><br><span class="line">            df[<span class="string">'date'</span>] = date</span><br><span class="line">            data_list.append(df)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pd.concat(data_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorid</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'majorid'</span>] = df[<span class="string">'date'</span>].map(str) + df[<span class="string">'courier_id'</span>].map(str) + <span class="string">'_'</span> + df[<span class="string">'wave_index'</span>].map(str)</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dropdate</span><span class="params">(df)</span>:</span></span><br><span class="line">        df.drop([<span class="string">'date'</span>, <span class="string">'courier_id'</span>, <span class="string">'wave_index'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line">    print(<span class="string">'----------------------TASK1~特征工程----------------------'</span>)</span><br><span class="line">    print(<span class="string">'----------------------action的操作(1/4)----------------------'</span>)</span><br><span class="line">    <span class="comment">## action的操作</span></span><br><span class="line">    <span class="comment"># courier_id                      骑士id</span></span><br><span class="line">    <span class="comment"># wave_index                      波次index</span></span><br><span class="line">    <span class="comment"># tracking_id                     订单id</span></span><br><span class="line">    <span class="comment"># courier_wave_start_lng          波次起始时刻骑士位置</span></span><br><span class="line">    <span class="comment"># courier_wave_start_lat          波次起始时刻骑士位置</span></span><br><span class="line">    <span class="comment"># action_type                     行为类型</span></span><br><span class="line">    <span class="comment"># expect_time                     行为对应时刻</span></span><br><span class="line"></span><br><span class="line">    action_train = read_datafile(train_path, <span class="string">'action'</span>)</span><br><span class="line">    action_test = read_datafile(test_path, <span class="string">'action'</span>)</span><br><span class="line"></span><br><span class="line">    action_train = majorid(action_train)</span><br><span class="line">    action_test = majorid(action_test)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action_train_group</span><span class="params">(df)</span>:</span></span><br><span class="line">        groups = df.groupby([<span class="string">'majorid'</span>])</span><br><span class="line">        df_future = []</span><br><span class="line">        df_last = []</span><br><span class="line">        <span class="keyword">for</span> name, group <span class="keyword">in</span> tqdm(groups):</span><br><span class="line">            <span class="comment"># future_data代表后面55%个</span></span><br><span class="line">            future_data = group.tail(int(group.shape[<span class="number">0</span>] * <span class="number">0.55</span>))</span><br><span class="line">            last_data = group.drop(future_data.index)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># last操作</span></span><br><span class="line">            last_data = last_data.tail(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 此时last_data 为最后一组数</span></span><br><span class="line">            last_data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对future处理:把第一个样本标记为正样本</span></span><br><span class="line">            <span class="comment"># (一般是把(二分类)任务中要查找(识别)出来的类别称做正类)</span></span><br><span class="line">            future_data[<span class="string">'label'</span>] = <span class="number">0</span></span><br><span class="line">            future_data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">            future_data.loc[<span class="number">0</span>, <span class="string">'label'</span>] = <span class="number">1</span>  <span class="comment"># 标记正负样本</span></span><br><span class="line"></span><br><span class="line">            df_future.append(future_data)</span><br><span class="line">            df_last.append(last_data)</span><br><span class="line">        return_last = pd.concat(df_last)</span><br><span class="line">        return_future = pd.concat(df_future)</span><br><span class="line">        return_last.rename(&#123;<span class="string">'expect_time'</span>: <span class="string">'last_time'</span>&#125;, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 把expecttime列重命名</span></span><br><span class="line">        return_future = shuffle(return_future)  <span class="comment"># 随机打乱顺序</span></span><br><span class="line">        <span class="keyword">return</span> return_last, return_future</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action_test_group</span><span class="params">(df)</span>:</span></span><br><span class="line">        groups = df.groupby([<span class="string">'majorid'</span>])</span><br><span class="line">        df_future = []</span><br><span class="line">        df_last = []</span><br><span class="line">        <span class="keyword">for</span> name, group <span class="keyword">in</span> tqdm(groups):</span><br><span class="line">            future_data = group[group[<span class="string">'expect_time'</span>] == <span class="number">0</span>]</span><br><span class="line">            last_data = group.drop(future_data.index)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># last操作</span></span><br><span class="line">            last_data = last_data.tail(<span class="number">1</span>)</span><br><span class="line">            last_data.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># future操作</span></span><br><span class="line">            future_data[<span class="string">'label'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            df_future.append(future_data)</span><br><span class="line">            df_last.append(last_data)</span><br><span class="line">        return_last = pd.concat(df_last)</span><br><span class="line">        return_future = pd.concat(df_future)</span><br><span class="line">        return_last.rename(&#123;<span class="string">'expect_time'</span>: <span class="string">'last_time'</span>&#125;, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> return_last, return_future</span><br><span class="line"></span><br><span class="line">    action_train_last, action_train_future = action_train_group(action_train)</span><br><span class="line">    action_test_last, action_test_future = action_test_group(action_test)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------distance操作(2/4)----------------------'</span>)</span><br><span class="line">    <span class="comment"># ## distance操作</span></span><br><span class="line">    <span class="comment"># courier_id          骑士id</span></span><br><span class="line">    <span class="comment"># wave_index          波次id</span></span><br><span class="line">    <span class="comment"># tracking_id         源订单id</span></span><br><span class="line">    <span class="comment"># source_type         源点类型（Assign/PickFood/DeliverFood）</span></span><br><span class="line">    <span class="comment"># source_lng          源点经度</span></span><br><span class="line">    <span class="comment"># source_lat          源点纬度</span></span><br><span class="line">    <span class="comment"># target_tracking_id  目标订单id</span></span><br><span class="line">    <span class="comment"># target_type         目标点类型（Assign/PickFood/DeliverFood）</span></span><br><span class="line">    <span class="comment"># target_lng          目标点经度</span></span><br><span class="line">    <span class="comment"># target_lat          目标点纬度</span></span><br><span class="line">    <span class="comment"># grid_distance       源点与目标点的高德距离</span></span><br><span class="line"></span><br><span class="line">    distance_train = read_datafile(train_path, <span class="string">'distance'</span>)</span><br><span class="line">    distance_test = read_datafile(test_path, <span class="string">'distance'</span>)</span><br><span class="line"></span><br><span class="line">    distance_train = majorid(distance_train)</span><br><span class="line">    distance_test = majorid(distance_test)</span><br><span class="line"></span><br><span class="line">    distance_train = dropdate(distance_train)</span><br><span class="line">    distance_test = dropdate(distance_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算曼哈顿距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tanlism_distance</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'target_tan'</span>] = (df[<span class="string">'source_lat'</span>] - df[<span class="string">'target_lat'</span>]) / (</span><br><span class="line">                df[<span class="string">'source_lng'</span>] - df[<span class="string">'target_lng'</span>])  <span class="comment"># df会自动处理出正无穷和负无穷，很秀</span></span><br><span class="line">        df[<span class="string">'target_tan'</span>] = np.arctan(df[<span class="string">'target_tan'</span>])</span><br><span class="line">        df[<span class="string">'target_tan'</span>] = np.degrees(df[<span class="string">'target_tan'</span>])</span><br><span class="line">        df[<span class="string">'target_MHD'</span>] = abs(df[<span class="string">'source_lat'</span>] - df[<span class="string">'target_lat'</span>]) + abs(</span><br><span class="line">            df[<span class="string">'source_lng'</span>] - df[<span class="string">'target_lng'</span>])  <span class="comment"># 加入曼哈顿距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    distance_train = tanlism_distance(distance_train)</span><br><span class="line">    distance_test = tanlism_distance(distance_test)</span><br><span class="line"></span><br><span class="line">    rename_rule = &#123;<span class="string">'source_type'</span>: <span class="string">'action_type'</span>&#125;</span><br><span class="line"></span><br><span class="line">    distance_test.rename(rename_rule, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    distance_train.rename(rename_rule, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    feature_train = pd.merge(left=action_train_last, right=distance_train,</span><br><span class="line">                             on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>, <span class="string">'action_type'</span>],</span><br><span class="line">                             how=<span class="string">'left'</span>)</span><br><span class="line">    feature_test = pd.merge(left=action_test_last, right=distance_test, on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>, <span class="string">'action_type'</span>],</span><br><span class="line">                            how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">    rename_rule = &#123;<span class="string">'tracking_id'</span>: <span class="string">'last_tracking_id'</span>, <span class="string">'action_type'</span>: <span class="string">'last_action_type'</span>,</span><br><span class="line">                   <span class="string">'target_tracking_id'</span>: <span class="string">'tracking_id'</span>, <span class="string">'target_type'</span>: <span class="string">'action_type'</span>&#125;</span><br><span class="line"></span><br><span class="line">    feature_test.rename(rename_rule, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    feature_train.rename(rename_rule, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    feature_test.drop([<span class="string">'courier_wave_start_lng'</span>, <span class="string">'courier_wave_start_lat'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    feature_train.drop([<span class="string">'courier_wave_start_lng'</span>, <span class="string">'courier_wave_start_lat'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    feature_train = dropdate(feature_train)</span><br><span class="line">    feature_test = dropdate(feature_test)</span><br><span class="line"></span><br><span class="line">    feature_train = pd.merge(left=action_train_future, right=feature_train,</span><br><span class="line">                             on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>, <span class="string">'action_type'</span>],</span><br><span class="line">                             how=<span class="string">'left'</span>)</span><br><span class="line">    feature_test = pd.merge(left=action_test_future, right=feature_test, on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>, <span class="string">'action_type'</span>],</span><br><span class="line">                            how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> action_test, action_test_future, action_test_last</span><br><span class="line">    <span class="keyword">del</span> action_train, action_train_future, action_train_last</span><br><span class="line">    <span class="keyword">del</span> distance_test, distance_train</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------order操作(3/4)----------------------'</span>)</span><br><span class="line">    <span class="comment"># ## order操作</span></span><br><span class="line">    <span class="comment"># courier_id           骑士id</span></span><br><span class="line">    <span class="comment"># wave_index           波次id</span></span><br><span class="line">    <span class="comment"># tracking_id          订单id</span></span><br><span class="line">    <span class="comment"># weather_grade        天气状况(正常天气/轻微恶劣天气/恶劣天气/极恶劣天气/罕见恶劣天气)</span></span><br><span class="line">    <span class="comment"># pick_lng             取餐经度</span></span><br><span class="line">    <span class="comment"># pick_lat             取餐纬度</span></span><br><span class="line">    <span class="comment"># deliver_lng          送餐经度</span></span><br><span class="line">    <span class="comment"># deliver_lat          送餐纬度</span></span><br><span class="line">    <span class="comment"># create_time          订单创建时间</span></span><br><span class="line">    <span class="comment"># confirm_time         订单确认时间</span></span><br><span class="line">    <span class="comment"># assigned_time        订单分配时间</span></span><br><span class="line">    <span class="comment"># time                 时间戳</span></span><br><span class="line">    <span class="comment"># promise_deliver_time 承诺送达时间</span></span><br><span class="line">    <span class="comment"># estimate_pick_time   预计取餐时间</span></span><br><span class="line">    <span class="comment"># aoi_id               送餐点所在aoi id，aoi_id是可以唯一标识一个小区，写字楼园区，学校，医院等</span></span><br><span class="line">    <span class="comment"># shop_id              商户id，可以唯一标识一个商户</span></span><br><span class="line"></span><br><span class="line">    order_train = read_datafile(train_path, <span class="string">'order'</span>)</span><br><span class="line">    order_test = read_datafile(test_path, <span class="string">'order'</span>)</span><br><span class="line"></span><br><span class="line">    order_test = majorid(order_test)</span><br><span class="line">    order_train = majorid(order_train)</span><br><span class="line"></span><br><span class="line">    order_test = dropdate(order_test)</span><br><span class="line">    order_train = dropdate(order_train)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tanlism_order</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'delivery_tan'</span>] = (df[<span class="string">'deliver_lat'</span>] - df[<span class="string">'pick_lat'</span>]) / (df[<span class="string">'deliver_lng'</span>] - df[<span class="string">'pick_lng'</span>])</span><br><span class="line">        df[<span class="string">'delivery_tan'</span>] = np.arctan(df[<span class="string">'delivery_tan'</span>])</span><br><span class="line">        df[<span class="string">'delivery_tan'</span>] = np.degrees(df[<span class="string">'delivery_tan'</span>])</span><br><span class="line">        df[<span class="string">'delivery_MHD'</span>] = abs(df[<span class="string">'deliver_lat'</span>] - df[<span class="string">'pick_lat'</span>]) + abs(</span><br><span class="line">            df[<span class="string">'deliver_lng'</span>] - df[<span class="string">'pick_lng'</span>])  <span class="comment"># 加入曼哈顿距离</span></span><br><span class="line"></span><br><span class="line">        df.drop([<span class="string">'deliver_lat'</span>, <span class="string">'pick_lat'</span>, <span class="string">'deliver_lng'</span>, <span class="string">'pick_lng'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    order_test = tanlism_order(order_test)</span><br><span class="line">    order_train = tanlism_order(order_train)</span><br><span class="line"></span><br><span class="line">    feature_test = pd.merge(left=feature_test, right=order_test, on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>], how=<span class="string">'left'</span>)</span><br><span class="line">    feature_train = pd.merge(left=feature_train, right=order_train, on=[<span class="string">'majorid'</span>, <span class="string">'tracking_id'</span>], how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------courier操作(4/4)----------------------'</span>)</span><br><span class="line">    <span class="comment"># ## courier操作</span></span><br><span class="line">    <span class="comment"># courier_id 骑士id</span></span><br><span class="line">    <span class="comment"># level      新老骑士</span></span><br><span class="line">    <span class="comment"># speed      骑士速度</span></span><br><span class="line">    <span class="comment"># max_load   背单能力</span></span><br><span class="line"></span><br><span class="line">    courier_train = read_datafile(train_path, <span class="string">'courier'</span>)</span><br><span class="line">    courier_test = read_datafile(test_path, <span class="string">'courier'</span>)</span><br><span class="line"></span><br><span class="line">    feature_test = pd.merge(left=feature_test, right=courier_test, on=[<span class="string">'courier_id'</span>, <span class="string">'date'</span>], how=<span class="string">'left'</span>)</span><br><span class="line">    feature_train = pd.merge(left=feature_train, right=courier_train, on=[<span class="string">'courier_id'</span>, <span class="string">'date'</span>], how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入新的特征：id, rush和road</span></span><br><span class="line">    feature_train[<span class="string">'id'</span>] = range(feature_train.shape[<span class="number">0</span>])</span><br><span class="line">    feature_test[<span class="string">'id'</span>] = range(feature_test.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rush</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'rush'</span>] = (df[<span class="string">'last_time'</span>] - df[<span class="string">'create_time'</span>]) / (df[<span class="string">'promise_deliver_time'</span>] - df[<span class="string">'create_time'</span>])</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    feature_train = add_rush(feature_train)</span><br><span class="line">    feature_test = add_rush(feature_test)</span><br><span class="line"></span><br><span class="line">    a = time.strftime(<span class="string">'%a_%H'</span>, time.localtime(<span class="number">1582094246</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据日期转化 分为  工作日/周末   高峰/非高峰</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_road</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'now'</span>] = df[<span class="string">'last_time'</span>].apply(<span class="keyword">lambda</span> x: time.strftime(<span class="string">'%a_%H'</span>, time.localtime(x)))  <span class="comment"># 格式化时间戳为本地的时间</span></span><br><span class="line">        df[<span class="string">'is_holiday'</span>] = df[<span class="string">'now'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x.split(<span class="string">'_'</span>)[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'Sat'</span>, <span class="string">'Sun'</span>] <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        busytime = [<span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>, <span class="string">'17'</span>, <span class="string">'18'</span>]</span><br><span class="line">        normtime = [<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'13'</span>, <span class="string">'14'</span>, <span class="string">'15'</span>, <span class="string">'16'</span>, <span class="string">'19'</span>, <span class="string">'20'</span>, <span class="string">'21'</span>, <span class="string">'22'</span>]</span><br><span class="line">        df[<span class="string">'road'</span>] = df[<span class="string">'now'</span>].apply(</span><br><span class="line">            <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x.split(<span class="string">'_'</span>)[<span class="number">1</span>] <span class="keyword">in</span> busytime <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">if</span> x.split(<span class="string">'_'</span>)[<span class="number">1</span>] <span class="keyword">in</span> normtime <span class="keyword">else</span> <span class="number">3</span>)</span><br><span class="line">        df.drop([<span class="string">'now'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    feature_test = add_road(feature_test)</span><br><span class="line">    feature_train = add_road(feature_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># weather_grade转化为特征</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weather</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="string">'正常天气'</span>:</span><br><span class="line">            x = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> x == <span class="string">'轻微恶劣天气'</span>:</span><br><span class="line">            x = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> x == <span class="string">'恶劣天气'</span>:</span><br><span class="line">            x = <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> x == <span class="string">'极恶劣天气'</span>:</span><br><span class="line">            x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'weather_grade'</span>] = feature_train[<span class="string">'weather_grade'</span>].apply(<span class="keyword">lambda</span> x: weather(x))</span><br><span class="line">    feature_test[<span class="string">'weather_grade'</span>] = feature_test[<span class="string">'weather_grade'</span>].apply(<span class="keyword">lambda</span> x: weather(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入expect_time-create_time和promise_deliver_time-expect_time作为预测的目标值</span></span><br><span class="line">    <span class="comment"># 一个时间是 从 下订单 到 这一action 之间的时间--&gt;已花费时间</span></span><br><span class="line">    <span class="comment"># 另一方  是 从 这一action 到 承诺送达的时间--&gt;剩余时间</span></span><br><span class="line">    <span class="comment"># expect_time就相当于当前时间</span></span><br><span class="line">    feature_train[<span class="string">'expect_used_time'</span>] = feature_train[<span class="string">'expect_time'</span>] - feature_train[<span class="string">'create_time'</span>]</span><br><span class="line">    feature_train[<span class="string">'will_residue_time'</span>] = feature_train[<span class="string">'promise_deliver_time'</span>] - feature_train[<span class="string">'expect_time'</span>]</span><br><span class="line">    feature_test[<span class="string">'expect_used_time'</span>] = <span class="number">0</span></span><br><span class="line">    feature_test[<span class="string">'will_residue_time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># feature_train.info()</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------异常值处理----------------------'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 异常值处理</span></span><br><span class="line">    <span class="comment"># 重新包装了一个异常值处理函数，把异常值清洗设为50%中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deal_outliers</span><span class="params">(df, col)</span>:</span></span><br><span class="line">        <span class="comment"># df = feature_train</span></span><br><span class="line">        <span class="comment"># col = 'expect_used_time'</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Box_outliers</span><span class="params">(data_ser)</span>:</span></span><br><span class="line">            iqr = <span class="number">3</span> * (data_ser.quantile(<span class="number">0.75</span>) - data_ser.quantile(<span class="number">0.25</span>))</span><br><span class="line">            val_low = data_ser.quantile(<span class="number">0.25</span>) - iqr</span><br><span class="line">            val_up = data_ser.quantile(<span class="number">0.75</span>) + iqr</span><br><span class="line">            <span class="keyword">return</span> val_low, val_up</span><br><span class="line"></span><br><span class="line">        data_ser = df[col]</span><br><span class="line">        val_low, val_up = Box_outliers(df[col])</span><br><span class="line">        std_data = df[col].quantile(<span class="number">0.5</span>)</span><br><span class="line">        df[col] = df[col].apply(<span class="keyword">lambda</span> x: std_data <span class="keyword">if</span> x &lt; val_low <span class="keyword">else</span> std_data <span class="keyword">if</span> x &gt; val_up <span class="keyword">else</span> x)</span><br><span class="line"></span><br><span class="line">        sns.boxplot(y=df[col], data=df, palette=<span class="string">"Set1"</span>)</span><br><span class="line">        <span class="keyword">return</span> df[col]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下边是实际需要运行的</span></span><br><span class="line">    feature_train[<span class="string">'expect_used_time'</span>] = deal_outliers(feature_train, <span class="string">'expect_used_time'</span>)</span><br><span class="line">    feature_train[<span class="string">'will_residue_time'</span>] = deal_outliers(feature_train, <span class="string">'will_residue_time'</span>)</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'expect_used_time'</span>].describe()</span><br><span class="line"></span><br><span class="line">    feature_test.to_pickle(<span class="string">'../user_data/feature_test_reg.pkl'</span>)</span><br><span class="line">    feature_train.to_pickle(<span class="string">'../user_data/feature_train_reg.pkl'</span>)</span><br><span class="line">    print(<span class="string">'******************特征工程完毕******************'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    train_path = <span class="string">'../data/eleme_round1_train_20200313/'</span></span><br><span class="line">    test_path = <span class="string">'../data/eleme_round1_testB_20200413/'</span></span><br><span class="line">    task1_featuretask(train_path,test_path)</span><br></pre></td></tr></table></figure><p>2.model</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GroupKFold, KFold</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2_regressortask</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'----------------------TASK2~回归问题12----------------------'</span>)</span><br><span class="line">    feature_test = pd.read_pickle(<span class="string">'../user_data/feature_test_reg.pkl'</span>)</span><br><span class="line">    feature_train = pd.read_pickle(<span class="string">'../user_data/feature_train_reg.pkl'</span>)</span><br><span class="line"></span><br><span class="line">    reg_prediction = feature_test</span><br><span class="line">    reg_prediction[<span class="string">'expect_time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 注意这边的 'expect_time'</span></span><br><span class="line">    <span class="comment"># 为什么是0，是因为expect_time 早已变成last_time</span></span><br><span class="line">    reg_prediction[<span class="string">'expect_used_time'</span>] = <span class="number">0</span></span><br><span class="line">    reg_prediction[<span class="string">'will_residue_time'</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------回归问题1预测expect_used_time----------------------'</span>)</span><br><span class="line">    <span class="comment"># # 建立时间预测的回归任务1</span></span><br><span class="line">    <span class="comment"># print('----------------------回归1调参----------------------')</span></span><br><span class="line">    <span class="comment"># y_col = 'expect_used_time'</span></span><br><span class="line">    <span class="comment"># # x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'target_tan', 'delivery_tan', 'delivery_MHD', 'target_MHD']# 加入expect_used_time和will_residue_time之后的x_col</span></span><br><span class="line">    <span class="comment"># x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'delivery_MHD', 'target_MHD']</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># t0 = time.time()</span></span><br><span class="line">    <span class="comment"># X_train, X_val, Y_train, Y_val = train_test_split(feature_train[x_col], feature_train[y_col], test_size=0.25)</span></span><br><span class="line">    <span class="comment"># def find_best_param(model):</span></span><br><span class="line">    <span class="comment">#     lgb_param_test = &#123;</span></span><br><span class="line">    <span class="comment">#         'n_estimators': [10000],</span></span><br><span class="line">    <span class="comment">#         'learning_rate': [0.05],</span></span><br><span class="line">    <span class="comment">#         'min_child_weight': [0],</span></span><br><span class="line">    <span class="comment">#         'max_delta_step': [1],</span></span><br><span class="line">    <span class="comment">#         'colsample_bytree': [0.5,0.8],</span></span><br><span class="line">    <span class="comment">#         'reg_alpha': [0.8,1,1.2],</span></span><br><span class="line">    <span class="comment">#         'reg_lambda': [0.8,1,1.2],</span></span><br><span class="line">    <span class="comment">#         'scale_pos_weight': [0.8,1,1.2],</span></span><br><span class="line">    <span class="comment">#         'num_leaves': [340,350,400],</span></span><br><span class="line">    <span class="comment">#         'max_depth': [90,100,130],</span></span><br><span class="line">    <span class="comment">#         'subsample': [ 0.1,0.12,0.14],</span></span><br><span class="line">    <span class="comment">#         'min_child_samples': [1,2,4,3],</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># # 注意RandomizedSearchCV跟GridSearchCV的参数 param_distributions跟param_grid作用相同，但名字不同</span></span><br><span class="line">    <span class="comment">#     grid_search = RandomizedSearchCV(estimator=model, param_distributions=lgb_param_test, scoring='mean_squared_error', cv=3)</span></span><br><span class="line">    <span class="comment"># #     grid_search = GridSearchCV(estimator=model, param_grid=xgb_param_test, scoring='mean_squared_error', cv=5)</span></span><br><span class="line">    <span class="comment">#     grid_search.fit(X_train,Y_train,</span></span><br><span class="line">    <span class="comment">#                     eval_names=['train', 'valid'],</span></span><br><span class="line">    <span class="comment">#                     eval_set=[(X_train, Y_train), (X_val, Y_val)],</span></span><br><span class="line">    <span class="comment">#                     verbose=500,</span></span><br><span class="line">    <span class="comment">#                     eval_metric='mae',</span></span><br><span class="line">    <span class="comment">#                     early_stopping_rounds=100)</span></span><br><span class="line">    <span class="comment">#     print(grid_search.best_params_)</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># lgbreg = lgb.LGBMRegressor(objective = 'regression_l1',metric = 'mae')</span></span><br><span class="line">    <span class="comment"># find_best_param(lgbreg)</span></span><br><span class="line">    <span class="comment"># gc.collect()</span></span><br><span class="line">    <span class="comment"># t1 = time.time()</span></span><br><span class="line">    <span class="comment"># print('end train, use&#123;&#125; second'.format(t1-t0))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立时间预测的回归任务1</span></span><br><span class="line">    y_col = <span class="string">'expect_used_time'</span></span><br><span class="line">    <span class="comment"># x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'target_tan', 'delivery_tan', 'delivery_MHD', 'target_MHD']# 加入expect_used_time和will_residue_time之后的x_col</span></span><br><span class="line">    x_col = [<span class="string">'weather_grade'</span>, <span class="string">'level'</span>, <span class="string">'speed'</span>, <span class="string">'max_load'</span>, <span class="string">'is_holiday'</span>, <span class="string">'rush'</span>, <span class="string">'road'</span>, <span class="string">'grid_distance'</span>,</span><br><span class="line">             <span class="string">'delivery_MHD'</span>,</span><br><span class="line">             <span class="string">'target_MHD'</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    model = lgb.LGBMRegressor(objective=<span class="string">'regression_l1'</span>, metric=<span class="string">'mae'</span>,</span><br><span class="line">                              subsample=<span class="number">0.14</span>, scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">                              reg_lambda=<span class="number">1.2</span>, reg_alpha=<span class="number">1</span>, num_leaves=<span class="number">400</span>,</span><br><span class="line">                              n_estimators=<span class="number">10000</span>, min_child_weight=<span class="number">0</span>,</span><br><span class="line">                              min_child_samples=<span class="number">2</span>, max_depth=<span class="number">130</span>,</span><br><span class="line">                              max_delta_step=<span class="number">1</span>, learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                              colsample_bytree=<span class="number">0.5</span></span><br><span class="line">                              )</span><br><span class="line"></span><br><span class="line">    valueK = <span class="number">10</span></span><br><span class="line">    oof = []</span><br><span class="line">    df_importance_list = []</span><br><span class="line"></span><br><span class="line">    kfold = KFold(n_splits=valueK, shuffle=<span class="literal">True</span>, random_state=<span class="number">2020</span>)</span><br><span class="line">    <span class="keyword">for</span> fold_id, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(kfold.split(feature_train[x_col], feature_train[y_col])):</span><br><span class="line">        X_train = feature_train.iloc[trn_idx][x_col]</span><br><span class="line">        Y_train = feature_train.iloc[trn_idx][y_col]</span><br><span class="line"></span><br><span class="line">        X_val = feature_train.iloc[val_idx][x_col]</span><br><span class="line">        Y_val = feature_train.iloc[val_idx][y_col]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'\nFold&#123;&#125; Training ======================================\n'</span>.format(fold_id + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        lgb_model = model.fit(</span><br><span class="line">            X_train,</span><br><span class="line">            Y_train,</span><br><span class="line">            eval_names=[<span class="string">'train'</span>, <span class="string">'valid'</span>],</span><br><span class="line">            eval_set=[(X_train, Y_train), (X_val, Y_val)],</span><br><span class="line">            verbose=<span class="number">500</span>,</span><br><span class="line">            eval_metric=<span class="string">'mae'</span>,</span><br><span class="line">            early_stopping_rounds=<span class="number">100</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pred_val = lgb_model.predict(X_val, num_iteration=lgb_model.best_iteration_)</span><br><span class="line">        df_oof = feature_train.iloc[val_idx][[<span class="string">'id'</span>, y_col]].copy()</span><br><span class="line">        df_oof[<span class="string">'pred'</span>] = pred_val</span><br><span class="line">        oof.append(df_oof)</span><br><span class="line"></span><br><span class="line">        pred_test = lgb_model.predict(feature_test[x_col], num_iteration=lgb_model.best_iteration_)</span><br><span class="line">        reg_prediction[<span class="string">'expect_used_time'</span>] += (pred_test / valueK)</span><br><span class="line"></span><br><span class="line">        df_importance = pd.DataFrame(&#123;</span><br><span class="line">            <span class="string">'column'</span>: x_col,</span><br><span class="line">            <span class="string">'importance'</span>: lgb_model.feature_importances_</span><br><span class="line">        &#125;)</span><br><span class="line">        df_importance_list.append(df_importance)</span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">        joblib.dump(lgb_model, <span class="string">'../user_data/model_data/model1&#123;&#125;.dat'</span>.format(fold_id))</span><br><span class="line">        <span class="comment">#     del lgb_model, pred_val, pred_test, X_train, Y_train, X_val, Y_val</span></span><br><span class="line">        gc.collect()</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    print(<span class="string">'end train, use&#123;&#125; second'</span>.format(t1 - t0))</span><br><span class="line"></span><br><span class="line">    df_oof = pd.concat(oof)</span><br><span class="line">    mae = metrics.mean_absolute_error(df_oof[y_col], df_oof[<span class="string">'pred'</span>])</span><br><span class="line">    print(<span class="string">'mae:'</span>, mae)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------回归问题2预测will_residue_time----------------------'</span>)</span><br><span class="line">    <span class="comment"># # 建立时间预测的回归任务2</span></span><br><span class="line">    <span class="comment"># print('----------------------回归2调参----------------------')</span></span><br><span class="line">    <span class="comment"># y_col = 'will_residue_time'</span></span><br><span class="line">    <span class="comment"># # x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'target_tan', 'delivery_tan', 'delivery_MHD', 'target_MHD']# 加入expect_used_time和will_residue_time之后的x_col</span></span><br><span class="line">    <span class="comment"># x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'delivery_MHD', 'target_MHD']</span></span><br><span class="line">    <span class="comment"># # x_col = ['speed', 'rush', 'grid_distance', 'delivery_MHD', 'target_MHD']</span></span><br><span class="line">    <span class="comment"># t0 = time.time()</span></span><br><span class="line">    <span class="comment"># X_train, X_val, Y_train, Y_val = train_test_split(feature_train[x_col], feature_train[y_col], test_size=0.25)</span></span><br><span class="line">    <span class="comment"># def find_best_param(model):</span></span><br><span class="line">    <span class="comment">#     lgb_param_test = &#123;'n_estimators':[10000],</span></span><br><span class="line">    <span class="comment">#     'num_leaves':[300],</span></span><br><span class="line">    <span class="comment">#     'max_depth':[10,20],</span></span><br><span class="line">    <span class="comment">#     'learning_rate': [0.05],</span></span><br><span class="line">    <span class="comment"># #     'bagging_fraction': [0.5,0.8,1],</span></span><br><span class="line">    <span class="comment"># #     'feature_fraction': [0.8],</span></span><br><span class="line">    <span class="comment">#     'reg_alpha' : [0,0.2,0.5],</span></span><br><span class="line">    <span class="comment">#     'reg_lambda' : [0,0.2,0.5]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># # 注意RandomizedSearchCV跟GridSearchCV的参数 param_distributions跟param_grid作用相同，但名字不同</span></span><br><span class="line">    <span class="comment">#     grid_search = RandomizedSearchCV(estimator=model, param_distributions=lgb_param_test, scoring='mean_squared_error', cv=3)</span></span><br><span class="line">    <span class="comment"># #     grid_search = GridSearchCV(estimator=model, param_grid=xgb_param_test, scoring='mean_squared_error', cv=5)</span></span><br><span class="line">    <span class="comment">#     grid_search.fit(X_train,Y_train,</span></span><br><span class="line">    <span class="comment">#                     eval_names=['train', 'valid'],</span></span><br><span class="line">    <span class="comment">#                     eval_set=[(X_train, Y_train), (X_val, Y_val)],</span></span><br><span class="line">    <span class="comment">#                     verbose=500,</span></span><br><span class="line">    <span class="comment">#                     eval_metric='mae',</span></span><br><span class="line">    <span class="comment">#                     early_stopping_rounds=100)</span></span><br><span class="line">    <span class="comment">#     print(grid_search.best_params_)</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># lgbreg = lgb.LGBMRegressor(objective = 'regression_l1',metric = 'mae')</span></span><br><span class="line">    <span class="comment"># find_best_param(lgbreg)</span></span><br><span class="line">    <span class="comment"># gc.collect()</span></span><br><span class="line">    <span class="comment"># t1 = time.time()</span></span><br><span class="line">    <span class="comment"># print('end train, use&#123;&#125; second'.format(t1-t0))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立时间预测的回归任务2</span></span><br><span class="line">    y_col = <span class="string">'will_residue_time'</span></span><br><span class="line">    <span class="comment"># x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'target_tan', 'delivery_tan', 'delivery_MHD', 'target_MHD']# 加入expect_used_time和will_residue_time之后的x_col</span></span><br><span class="line">    <span class="comment"># x_col = ['weather_grade', 'level', 'speed', 'max_load', 'is_holiday', 'rush', 'road', 'grid_distance', 'delivery_MHD',</span></span><br><span class="line">    <span class="comment">#          'target_MHD']</span></span><br><span class="line">    x_col = [<span class="string">'speed'</span>, <span class="string">'rush'</span>, <span class="string">'grid_distance'</span>, <span class="string">'delivery_MHD'</span>, <span class="string">'target_MHD'</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    model = lgb.LGBMRegressor(</span><br><span class="line">        metric=<span class="string">'mae'</span>,</span><br><span class="line">        num_leaves=<span class="number">64</span>,</span><br><span class="line">        max_depth=<span class="number">7</span>,</span><br><span class="line">        n_estimators=<span class="number">300</span>,</span><br><span class="line">        learning_rate=<span class="number">0.05</span>,</span><br><span class="line">        bagging_fraction=<span class="number">1</span>,</span><br><span class="line">        feature_fraction=<span class="number">0.8</span>,</span><br><span class="line">        reg_alpha=<span class="number">0</span>,</span><br><span class="line">        reg_lambda=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    valueK = <span class="number">10</span></span><br><span class="line">    oof = []</span><br><span class="line">    df_importance_list = []</span><br><span class="line"></span><br><span class="line">    kfold = KFold(n_splits=valueK, shuffle=<span class="literal">True</span>, random_state=<span class="number">2020</span>)</span><br><span class="line">    <span class="keyword">for</span> fold_id, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(kfold.split(feature_train[x_col], feature_train[y_col])):</span><br><span class="line">        X_train = feature_train.iloc[trn_idx][x_col]</span><br><span class="line">        Y_train = feature_train.iloc[trn_idx][y_col]</span><br><span class="line"></span><br><span class="line">        X_val = feature_train.iloc[val_idx][x_col]</span><br><span class="line">        Y_val = feature_train.iloc[val_idx][y_col]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'\nFold&#123;&#125; Training ======================================\n'</span>.format(fold_id + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        lgb_model = model.fit(</span><br><span class="line">            X_train,</span><br><span class="line">            Y_train,</span><br><span class="line">            eval_names=[<span class="string">'train'</span>, <span class="string">'valid'</span>],</span><br><span class="line">            eval_set=[(X_train, Y_train), (X_val, Y_val)],</span><br><span class="line">            verbose=<span class="number">500</span>,</span><br><span class="line">            eval_metric=<span class="string">'mae'</span>,</span><br><span class="line">            early_stopping_rounds=<span class="number">100</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pred_val = lgb_model.predict(X_val, num_iteration=lgb_model.best_iteration_)</span><br><span class="line">        df_oof = feature_train.iloc[val_idx][[<span class="string">'id'</span>, y_col]].copy()</span><br><span class="line">        df_oof[<span class="string">'pred'</span>] = pred_val</span><br><span class="line">        oof.append(df_oof)</span><br><span class="line"></span><br><span class="line">        pred_test = lgb_model.predict(feature_test[x_col], num_iteration=lgb_model.best_iteration_)</span><br><span class="line">        reg_prediction[<span class="string">'will_residue_time'</span>] += (pred_test / valueK)</span><br><span class="line"></span><br><span class="line">        df_importance = pd.DataFrame(&#123;</span><br><span class="line">            <span class="string">'column'</span>: x_col,</span><br><span class="line">            <span class="string">'importance'</span>: lgb_model.feature_importances_</span><br><span class="line">        &#125;)</span><br><span class="line">        df_importance_list.append(df_importance)</span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">        joblib.dump(lgb_model, <span class="string">'../user_data/model_data/model2&#123;&#125;.dat'</span>.format(fold_id))</span><br><span class="line">        <span class="comment"># del lgb_model, pred_val, pred_test, X_train, Y_train, X_val, Y_val</span></span><br><span class="line">        <span class="comment"># gc.collect()</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    print(<span class="string">'end train, use&#123;&#125; second'</span>.format(t1 - t0))</span><br><span class="line"></span><br><span class="line">    df_oof = pd.concat(oof)</span><br><span class="line">    mae = metrics.mean_absolute_error(df_oof[y_col], df_oof[<span class="string">'pred'</span>])</span><br><span class="line">    print(<span class="string">'mae:'</span>, mae)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----------------------计算expect_time----------------------'</span>)</span><br><span class="line">    <span class="comment"># 还原expect_time</span></span><br><span class="line">    reg_prediction[<span class="string">'expect_time'</span>] = reg_prediction[<span class="string">'promise_deliver_time'</span>] - reg_prediction[</span><br><span class="line">        <span class="string">'will_residue_time'</span>]  <span class="comment"># 只使用后一个</span></span><br><span class="line"></span><br><span class="line">    feature_train.to_pickle(<span class="string">'../user_data/regfuture_train_regend.pkl'</span>)</span><br><span class="line">    reg_prediction.to_pickle(<span class="string">'../user_data/regfuture_test_regend.pkl'</span>)</span><br><span class="line">    print(<span class="string">'******************回归问题完毕******************'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task3_classifiertask</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'----------------------TASK3~分类问题----------------------'</span>)</span><br><span class="line">    feature_train = pd.read_pickle(<span class="string">'../user_data/regfuture_train_regend.pkl'</span>)</span><br><span class="line">    feature_test = pd.read_pickle(<span class="string">'../user_data/regfuture_test_regend.pkl'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特征 deadline--&gt;还剩下的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deadLine</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'deadline'</span>] = df[<span class="string">'promise_deliver_time'</span>] - df[<span class="string">'expect_time'</span>]</span><br><span class="line">        df[<span class="string">'need_speed'</span>] = df[<span class="string">'grid_distance'</span>] / df[<span class="string">'deadline'</span>]</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    feature_train = deadLine(feature_train)</span><br><span class="line">    feature_test = deadLine(feature_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新包装了一个异常值处理函数，把异常值清洗设为50%中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deal_outliers</span><span class="params">(df, col)</span>:</span></span><br><span class="line">        <span class="comment"># df = feature_train</span></span><br><span class="line">        <span class="comment"># col = 'expect_used_time'</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Box_outliers</span><span class="params">(data_ser)</span>:</span></span><br><span class="line">            iqr = <span class="number">3</span> * (data_ser.quantile(<span class="number">0.75</span>) - data_ser.quantile(<span class="number">0.25</span>))</span><br><span class="line">            val_low = data_ser.quantile(<span class="number">0.25</span>) - iqr</span><br><span class="line">            val_up = data_ser.quantile(<span class="number">0.75</span>) + iqr</span><br><span class="line">            <span class="keyword">return</span> val_low, val_up</span><br><span class="line"></span><br><span class="line">        data_ser = df[col]</span><br><span class="line">        val_low, val_up = Box_outliers(df[col])</span><br><span class="line">        std_data = df[col].quantile(<span class="number">0.5</span>)</span><br><span class="line">        df[col] = df[col].apply(<span class="keyword">lambda</span> x: std_data <span class="keyword">if</span> x &lt; val_low <span class="keyword">else</span> std_data <span class="keyword">if</span> x &gt; val_up <span class="keyword">else</span> x)</span><br><span class="line"></span><br><span class="line">        sns.boxplot(y=df[col], data=df, palette=<span class="string">"Set1"</span>)</span><br><span class="line">        <span class="keyword">return</span> df[col]</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'need_speed'</span>] = deal_outliers(feature_train, <span class="string">'need_speed'</span>)</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'deadline'</span>] = deal_outliers(feature_train, <span class="string">'deadline'</span>)</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'deadline'</span>].plot.hist()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_Picked</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'is_picked'</span>] = df[<span class="string">'last_time'</span>] - df[<span class="string">'estimate_pick_time'</span>]</span><br><span class="line">        df[<span class="string">'is_picked'</span>] = df[<span class="string">'is_picked'</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    feature_test = is_Picked(feature_test)</span><br><span class="line">    feature_train = is_Picked(feature_train)</span><br><span class="line"></span><br><span class="line">    feature_train.to_pickle(<span class="string">'../user_data/future_train_clf.pkl'</span>)</span><br><span class="line">    feature_test.to_pickle(<span class="string">'../user_data/future_test_clf.pkl'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 分类模型</span></span><br><span class="line">    <span class="comment"># 目标：提高回归任务的mae，以提高expect_time预测精准度。</span></span><br><span class="line"></span><br><span class="line">    feature_train = pd.read_pickle(<span class="string">'../user_data/future_train_clf.pkl'</span>)</span><br><span class="line">    feature_test = pd.read_pickle(<span class="string">'../user_data/future_test_clf.pkl'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 临时特征工程</span></span><br><span class="line">    feature_test[<span class="string">'label'</span>] = <span class="number">0</span></span><br><span class="line">    feature_train[<span class="string">'train'</span>] = <span class="number">1</span></span><br><span class="line">    feature_test[<span class="string">'train'</span>] = <span class="number">0</span></span><br><span class="line">    feature = feature_train.append(feature_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将送餐点和商户的信息 标签编码LabelEncoder</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">'aoi_id'</span>, <span class="string">'shop_id'</span>]:</span><br><span class="line">        print(f)</span><br><span class="line">        lbl = LabelEncoder()</span><br><span class="line">        feature[f] = lbl.fit_transform(feature[f].astype(str))</span><br><span class="line"></span><br><span class="line">    feature_train = feature[feature[<span class="string">'train'</span>] == <span class="number">1</span>].copy()</span><br><span class="line">    feature_test = feature[feature[<span class="string">'train'</span>] == <span class="number">0</span>].copy()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_Residue_Time</span><span class="params">(df)</span>:</span></span><br><span class="line">        df[<span class="string">'total_residue_time'</span>] = df[<span class="string">'promise_deliver_time'</span>] - df[<span class="string">'estimate_pick_time'</span>]</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    feature_train = total_Residue_Time(feature_train)</span><br><span class="line">    feature_test = total_Residue_Time(feature_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回到模型</span></span><br><span class="line">    prediction = feature_test[</span><br><span class="line">        [<span class="string">'courier_id'</span>, <span class="string">'wave_index'</span>, <span class="string">'tracking_id'</span>, <span class="string">'courier_wave_start_lng'</span>, <span class="string">'courier_wave_start_lat'</span>, <span class="string">'action_type'</span>,</span><br><span class="line">         <span class="string">'expect_time'</span>, <span class="string">'date'</span>, <span class="string">'id'</span>, <span class="string">'majorid'</span>, <span class="string">'label'</span>]]</span><br><span class="line">    prediction[<span class="string">'label'</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print('----------------------分类调参----------------------')</span></span><br><span class="line">    <span class="comment"># y_col = 'label'</span></span><br><span class="line">    <span class="comment"># # x_col = ['grid_distance', 'target_tan', 'target_MHD', 'weather_grade', 'aoi_id', 'shop_id', 'delivery_tan', 'delivery_MHD', 'level', 'speed', 'max_load', 'rush', 'road', 'expect_used_time', 'will_residue_time', 'deadline', 'need_speed', 'is_picked']</span></span><br><span class="line">    <span class="comment"># # x_col = ['grid_distance', 'target_tan', 'target_MHD', 'weather_grade', 'delivery_tan', 'delivery_MHD', 'level', 'speed', 'max_load', 'rush', 'road', 'expect_used_time', 'will_residue_time', 'deadline', 'need_speed', 'is_picked']# 939-911</span></span><br><span class="line">    <span class="comment"># x_col = ['grid_distance', 'target_MHD', 'weather_grade', 'delivery_MHD', 'level', 'speed', 'max_load', 'rush', 'road', 'deadline', 'need_speed', 'is_picked']#</span></span><br><span class="line">    <span class="comment"># # x_col = ['rush', 'target_MHD', 'delivery_MHD', 'grid_distance', 'max_load', 'is_picked']# 783-772-718</span></span><br><span class="line">    <span class="comment"># # x_col = ['rush', 'target_MHD', 'delivery_MHD', 'grid_distance', 'max_load', 'is_picked', 'aoi_id', 'shop_id', 'courier_id']# 797-767-716</span></span><br><span class="line">    <span class="comment"># t0 = time.time()</span></span><br><span class="line">    <span class="comment"># X_train, X_val, Y_train, Y_val = train_test_split(feature_train[x_col], feature_train[y_col], test_size=0.25)</span></span><br><span class="line">    <span class="comment"># def find_best_param(model):</span></span><br><span class="line">    <span class="comment">#     lgb_param_test = &#123;</span></span><br><span class="line">    <span class="comment">#         'n_estimators': [10000],</span></span><br><span class="line">    <span class="comment">#         'learning_rate': [0.1],</span></span><br><span class="line">    <span class="comment">#         'num_leaves': [10,6,7],</span></span><br><span class="line">    <span class="comment">#         'max_depth': [300,32,64,128],</span></span><br><span class="line">    <span class="comment">#         'subsample': [0.5,0.8,1],</span></span><br><span class="line">    <span class="comment">#         'reg_alpha': [0.8,1,0,0.5],</span></span><br><span class="line">    <span class="comment">#         'reg_lambda': [0.8,1,0,0.5],</span></span><br><span class="line">    <span class="comment">#         'feature_fraction': [0.5,0.8,1],</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># # 注意RandomizedSearchCV跟GridSearchCV的参数 param_distributions跟param_grid作用相同，但名字不同</span></span><br><span class="line">    <span class="comment">#     grid_search = RandomizedSearchCV(estimator=model, param_distributions=lgb_param_test, scoring='accuracy', cv=3)</span></span><br><span class="line">    <span class="comment"># #     grid_search = GridSearchCV(estimator=model, param_grid=lgb_param_test, scoring='accuracy', cv=5)</span></span><br><span class="line">    <span class="comment">#     grid_search.fit(X_train,Y_train,</span></span><br><span class="line">    <span class="comment">#                     eval_names=['train', 'valid'],</span></span><br><span class="line">    <span class="comment">#                     eval_set=[(X_train, Y_train), (X_val, Y_val)],</span></span><br><span class="line">    <span class="comment">#                     verbose=500,</span></span><br><span class="line">    <span class="comment">#                     eval_metric='auc',</span></span><br><span class="line">    <span class="comment">#                     early_stopping_rounds=100)</span></span><br><span class="line">    <span class="comment">#     print(grid_search.best_params_)</span></span><br><span class="line">    <span class="comment"># #</span></span><br><span class="line">    <span class="comment"># lgbreg = lgb.LGBMClassifier(metric = 'auc')</span></span><br><span class="line">    <span class="comment"># find_best_param(lgbreg)</span></span><br><span class="line">    <span class="comment"># gc.collect()</span></span><br><span class="line">    <span class="comment"># t1 = time.time()</span></span><br><span class="line">    <span class="comment"># print('end train, use&#123;&#125; second'.format(t1-t0))</span></span><br><span class="line"></span><br><span class="line">    y_col = <span class="string">'label'</span></span><br><span class="line">    <span class="comment"># x_col = ['grid_distance', 'target_tan', 'target_MHD', 'weather_grade', 'aoi_id', 'shop_id', 'delivery_tan', 'delivery_MHD', 'level', 'speed', 'max_load', 'rush', 'road', 'expect_used_time', 'will_residue_time', 'deadline', 'need_speed', 'is_picked']</span></span><br><span class="line">    <span class="comment"># x_col = ['grid_distance', 'target_tan', 'target_MHD', 'weather_grade', 'delivery_tan', 'delivery_MHD', 'level', 'speed', 'max_load', 'rush', 'road', 'expect_used_time', 'will_residue_time', 'deadline', 'need_speed', 'is_picked']# 939-911</span></span><br><span class="line">    <span class="comment"># x_col = ['grid_distance', 'target_MHD', 'weather_grade', 'delivery_MHD', 'level', 'speed', 'max_load', 'r# 783-772-718</span></span><br><span class="line">    x_col = [<span class="string">'rush'</span>, <span class="string">'target_MHD'</span>, <span class="string">'delivery_MHD'</span>, <span class="string">'grid_distance'</span>, <span class="string">'max_load'</span>, <span class="string">'is_picked'</span>, <span class="string">'aoi_id'</span>, <span class="string">'shop_id'</span>,</span><br><span class="line">             <span class="string">'courier_id'</span>]</span><br><span class="line"></span><br><span class="line">    model = lgb.LGBMClassifier(metric=<span class="string">'auc'</span>,</span><br><span class="line">                               num_leaves=<span class="number">7</span>,</span><br><span class="line">                               max_depth=<span class="number">128</span>,</span><br><span class="line">                               learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                               n_estimators=<span class="number">10000</span>,</span><br><span class="line">                               subsample=<span class="number">0.8</span>,</span><br><span class="line">                               feature_fraction=<span class="number">0.8</span>,</span><br><span class="line">                               reg_alpha=<span class="number">1</span>,</span><br><span class="line">                               reg_lambda=<span class="number">0.5</span>,</span><br><span class="line">                               )</span><br><span class="line"></span><br><span class="line">    oof = []</span><br><span class="line">    df_importance_list = []</span><br><span class="line"></span><br><span class="line">    kfold = GroupKFold(n_splits=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> fold_id, (trn_idx, val_idx) <span class="keyword">in</span> enumerate(</span><br><span class="line">            kfold.split(feature_train[x_col], feature_train[y_col], feature_train[<span class="string">'majorid'</span>])):</span><br><span class="line">        X_train = feature_train.iloc[trn_idx][x_col]</span><br><span class="line">        Y_train = feature_train.iloc[trn_idx][y_col]</span><br><span class="line"></span><br><span class="line">        X_val = feature_train.iloc[val_idx][x_col]</span><br><span class="line">        Y_val = feature_train.iloc[val_idx][y_col]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'\nFold_&#123;&#125; Training ================================\n'</span>.format(fold_id + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        lgb_model = model.fit(</span><br><span class="line">            X_train,</span><br><span class="line">            Y_train,</span><br><span class="line">            eval_names=[<span class="string">'train'</span>, <span class="string">'valid'</span>],</span><br><span class="line">            eval_set=[(X_train, Y_train), (X_val, Y_val)],</span><br><span class="line">            verbose=<span class="number">500</span>,</span><br><span class="line">            eval_metric=<span class="string">'auc'</span>,</span><br><span class="line">            early_stopping_rounds=<span class="number">100</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pred_val = lgb_model.predict_proba(X_val, num_iteration=lgb_model.best_iteration_)[:, <span class="number">1</span>]</span><br><span class="line">        df_oof = feature_train.iloc[val_idx][[<span class="string">'id'</span>, <span class="string">'majorid'</span>, y_col]].copy()</span><br><span class="line">        df_oof[<span class="string">'pred'</span>] = pred_val</span><br><span class="line">        oof.append(df_oof)</span><br><span class="line"></span><br><span class="line">        pred_test = lgb_model.predict_proba(feature_test[x_col], num_iteration=lgb_model.best_iteration_)[:, <span class="number">1</span>]</span><br><span class="line">        prediction[<span class="string">'label'</span>] += pred_test / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        df_importance = pd.DataFrame(&#123;</span><br><span class="line">            <span class="string">'column'</span>: x_col,</span><br><span class="line">            <span class="string">'importance'</span>: lgb_model.feature_importances_,</span><br><span class="line">        &#125;)</span><br><span class="line">        df_importance_list.append(df_importance)</span><br><span class="line">        joblib.dump(lgb_model, <span class="string">'../user_data/model_data/model3&#123;&#125;.dat'</span>.format(fold_id))</span><br><span class="line">    <span class="comment"># 验证recall，对feature_train 和 oof</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_func</span><span class="params">(majorid)</span>:</span></span><br><span class="line">        majorid = majorid.values.tolist()</span><br><span class="line">        max_index = majorid.index(max(majorid))</span><br><span class="line">        result = np.zeros(len(majorid))</span><br><span class="line">        result[max_index] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Acc</span><span class="params">(df)</span>:</span></span><br><span class="line">        TP = df[(df[<span class="string">'label'</span>] == <span class="number">1</span>) &amp; (df[<span class="string">'result'</span>] == <span class="number">1</span>)].shape[<span class="number">0</span>]  <span class="comment"># 预测正确，预测的值为真</span></span><br><span class="line">        TN = df[(df[<span class="string">'label'</span>] == <span class="number">0</span>) &amp; (df[<span class="string">'result'</span>] == <span class="number">0</span>)].shape[<span class="number">0</span>]  <span class="comment"># 预测正确，预测的值为假</span></span><br><span class="line">        FP = df[(df[<span class="string">'label'</span>] == <span class="number">0</span>) &amp; (df[<span class="string">'result'</span>] == <span class="number">1</span>)].shape[<span class="number">0</span>]  <span class="comment"># 预测错误，预测的值为真</span></span><br><span class="line">        FN = df[(df[<span class="string">'label'</span>] == <span class="number">1</span>) &amp; (df[<span class="string">'result'</span>] == <span class="number">0</span>)].shape[<span class="number">0</span>]  <span class="comment"># 预测错误，预测的值为假</span></span><br><span class="line">        TP_FN = df[df[<span class="string">'label'</span>] == <span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">        TP_FP = df[df[<span class="string">'result'</span>] == <span class="number">1</span>].shape[<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">'recall:&#123;&#125;'</span>.format(TP / TP_FN))</span><br><span class="line">        print(<span class="string">'acc:&#123;&#125;'</span>.format(TP / TP_FP))</span><br><span class="line"></span><br><span class="line">    feature_train[<span class="string">'pred_val'</span>] = lgb_model.predict_proba(feature_train[x_col], num_iteration=lgb_model.best_iteration_)[</span><br><span class="line">                                :, <span class="number">1</span>]</span><br><span class="line">    feature_train[<span class="string">'result'</span>] = feature_train.groupby([<span class="string">'majorid'</span>])[<span class="string">'pred_val'</span>].transform(result_func)</span><br><span class="line">    Acc(feature_train)</span><br><span class="line">    print(<span class="string">'******************分类问题完毕******************'</span>)</span><br><span class="line">    print(<span class="string">'----------------------zip输出----------------------'</span>)</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    prediction[<span class="string">'rusult'</span>] = prediction.groupby([<span class="string">'majorid'</span>])[<span class="string">'label'</span>].transform(result_func)</span><br><span class="line">    subfile = prediction[prediction[<span class="string">'rusult'</span>] == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    result = subfile[</span><br><span class="line">        [<span class="string">'courier_id'</span>, <span class="string">'wave_index'</span>, <span class="string">'tracking_id'</span>, <span class="string">'courier_wave_start_lng'</span>, <span class="string">'courier_wave_start_lat'</span>, <span class="string">'action_type'</span>,</span><br><span class="line">         <span class="string">'expect_time'</span>, <span class="string">'date'</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> zipfile</span><br><span class="line">    os.makedirs(<span class="string">'../action_predict'</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># f = zipfile.ZipFile('./action_predict/&#123;&#125;.zip'.format('result'), 'w', zipfile.ZIP_DEFLATED)</span></span><br><span class="line">    <span class="keyword">for</span> date <span class="keyword">in</span> result[<span class="string">'date'</span>].unique():</span><br><span class="line">        df_temp = result[result[<span class="string">'date'</span>] == date]</span><br><span class="line">        <span class="keyword">del</span> df_temp[<span class="string">'date'</span>]</span><br><span class="line">        df_temp.to_csv(<span class="string">'../action_predict/action_&#123;&#125;.txt'</span>.format(date), index=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># f.write('./action_predict/action_&#123;&#125;.txt'.format(date), 'action_&#123;&#125;.txt'.format(date))</span></span><br><span class="line">    <span class="comment"># f.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    task2_regressortask()</span><br><span class="line">    task3_classifiertask()</span><br></pre></td></tr></table></figure><p>3.main</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> feature.feature <span class="keyword">import</span> task1_featuretask</span><br><span class="line"><span class="keyword">from</span> model.model <span class="keyword">import</span> task2_regressortask,task3_classifiertask</span><br><span class="line"></span><br><span class="line">train_path = <span class="string">'../data/eleme_round1_train_20200313/'</span></span><br><span class="line">test_path = <span class="string">'../data/eleme_round1_testB_20200413/'</span></span><br><span class="line">task1_featuretask(train_path,test_path)</span><br><span class="line">task2_regressortask()</span><br><span class="line">task3_classifiertask()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ML，天池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据清洗时的一些指标</title>
      <link href="/2020/04/01/%E5%A4%A9%E6%B1%A0/"/>
      <url>/2020/04/01/%E5%A4%A9%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法常见的评估指标"><a href="#算法常见的评估指标" class="headerlink" title="算法常见的评估指标"></a>算法常见的评估指标</h1><h2 id="分类算法常见的评估指标如下："><a href="#分类算法常见的评估指标如下：" class="headerlink" title="分类算法常见的评估指标如下："></a>分类算法常见的评估指标如下：</h2><ul><li>对于二类分类器/分类算法，评价指标主要有accuracy， [Precision，Recall，F-score，Pr曲线]，ROC-AUC曲线。</li><li>对于多类分类器/分类算法，评价指标主要有accuracy， [宏平均和微平均，F-score]。</li></ul><table><thead><tr><th>预测（横） 实际（纵）</th><th>+</th><th>-</th></tr></thead><tbody><tr><td>+</td><td>tp</td><td>fn</td></tr><tr><td>-</td><td>fp</td><td>tn</td></tr></tbody></table><p>tp tn 代表预测正确</p><ul><li>准确率(Accuracy)<br><img src="https://math.jianshu.com/math?formula=accuracy%3D%5Cfrac%7Btp%2Btn%7D%7Btp%2Bfp%2Btn%2Bfn%7D" alt="accuracy=\frac{tp+tn}{tp+fp+tn+fn}"><br> accuracy是最常见也是最基本的评价指标。但是，在二分类且正负样本不平衡的情况下，尤其是对于较少数样本类感兴趣时，accuracy基本无参考价值。如欺诈检测、癌症检测等，100个样例中，99个负例，1个正例。模型将任意样本都分为负例，accuracy值为0.99。但是，拿这个模型去检测新样本，一个正例也分不出来。</li><li>精确率(Precision)、召回率(Recall)<br> <img src="https://math.jianshu.com/math?formula=precision%3D%5Cfrac%7Btp%7D%7Btp%2Bfp%7D%EF%BC%8Crecall%3D%5Cfrac%7Btp%7D%7Btp%2Bfn%7D" alt="precision=\frac{tp}{tp+fp}，recall=\frac{tp}{tp+fn}"><br> precision是相对于模型预测而言的，可以理解为模型做出新预测时的自信度得分是多少或做出这个预测是对的可能性是多少。自信度。<br> recall是相对于真实标签而言的，可以理解为模型预测出的正例占实际正例的比例。覆盖率。<br> 如果模型很贪婪，想要覆盖更多的样本，那么它就有可能会犯错。这个时候的recall值常很高，precision常很低。如果模型很保守，只对很确定的样本做出预测，则precision值常很高，recall值常很低。我们可以选择只看我们感兴趣的样本类，也就是较少数样本类的precision和recall来评价模型的好坏。<br> 疾病检测、反垃圾等，是在保证精确率的条件下提升召回率；搜索等是在保证召回率的情况下提升精确率。</li><li>F1值(F1-score)<br> <img src="https://math.jianshu.com/math?formula=f1-score%3D%5Cfrac%7B2%7D%7B%5Cfrac%7B1%7D%7BP%7D%2B%5Cfrac%7B1%7D%7BR%7D%7D%3D%5Cfrac%7B2PR%7D%7BP%2BR%7D" alt="f1-score=\frac{2}{\frac{1}{P}+\frac{1}{R}}=\frac{2PR}{P+R}"><br> F1值是个综合考虑precision值和recall值的指标。<br> 多类别分类时，有宏平均(macro-average)和微平均(micro-average)两种。<br> 宏平均是指先对每个类别单独计算F1值。取这些值的算术平均值作为全局指标。这种方式平等地对待每个类别，所以其值主要受稀有类别的影响，更能体现模型在稀有类别上的表现。<br> 微平均是指先累加各个类别的tp、fp、tn、fn值，再由这些值来计算F1值。这种方式平等地对待每个样本，所以其值主要受到常见类别的影响。</li><li>ROC-AUC<br> <img src="https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7Dsensitivity%26%3Drecall%3Dtrue%5C%20positive%5C%20rate%5C%5C%20%26%3D%5Cfrac%7Btp%7D%7Btp%2Bfn%7D%5C%5C%20%26%3DP(%5Chat%7By%7D%3D1%7Cy%3D1)%5Cend%7Baligned%7D" alt="\begin{aligned}sensitivity&amp;=recall=true\ positive\ rate\\ &amp;=\frac{tp}{tp+fn}\\ &amp;=P(\hat{y}=1|y=1)\end{aligned}"><br> <img src="https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7Dspecifity%26%3D1-false%5C%20positive%5C%20rate%5C%5C%20%26%3D%5Cfrac%7Btn%7D%7Bfp%2Btn%7D%5C%5C%20%26%3DP(%5Chat%7By%7D%3D0%7Cy%3D0)%5Cend%7Baligned%7D" alt="\begin{aligned}specifity&amp;=1-false\ positive\ rate\\ &amp;=\frac{tn}{fp+tn}\\ &amp;=P(\hat{y}=0|y=0)\end{aligned}"><br> 无论<img src="https://math.jianshu.com/math?formula=y" alt="y">的真实概率是多少，都不会影响sensitivity和specificity。也就是说，这两个指标是不会受到不平衡数据的影响的。而<img src="https://math.jianshu.com/math?formula=precision%3DP(y%3D1%7C%5Chat%7By%7D%3D1)" alt="precision=P(y=1|\hat{y}=1)">是会受到数据集中正负比例的影响的。<br> ROC曲线(Receiver Operating Characteristic Curve)是一个以fpr为<img src="https://math.jianshu.com/math?formula=x" alt="x">轴，tpr为<img src="https://math.jianshu.com/math?formula=y" alt="y">轴，取不同的score threshold画出来的。<br> 基本上，ROC曲线下面积即AUC越大，或者说曲线越接近于左上角(fpr=0, tpr=1)，那么模型的分类效果就越好。一般来说，最优score threshold就是ROC曲线离<img src="https://math.jianshu.com/math?formula=y%3Dx" alt="y=x">基准线最远的一点或者说是ROC曲线离左上角最近的一点对应的阈值，再或者是根据用户自定义的cost function来决定的。<br> AUC就是从所有正例样本中随机选择出一个样本，在所有负例样本中随机选择出一个样本，使用分类器进行预测。将正例样本预测为正的概率记作<img src="https://math.jianshu.com/math?formula=P_1" alt="P_1">，将负例样本预测为负的概率记作<img src="https://math.jianshu.com/math?formula=P_0" alt="P_0">，<img src="https://math.jianshu.com/math?formula=P_1%3EP_0" alt="P_1&gt;P_0">的概率就等于AUC值。因此，AUC反映的是分类器对于样本的排序能力。根据这个解释，如果我们完全随机地对样本进行分类，那么AUC应该接近于0.5。另外，AUC值对于样本类别是否均衡并不敏感，这也是不均衡样本通常使用AUC评价分类器性能的一个原因。通常使用AUC的目的，一是为了比较不同模型性能的好坏，二是为了找到得到最佳指标值的那个阈值点。</li><li>PR-AUC<br> PR曲线，是以P为<img src="https://math.jianshu.com/math?formula=y" alt="y">轴，以R为<img src="https://math.jianshu.com/math?formula=x" alt="x">轴，取不同的概率阈值得到不同的(p,r)点后画成的线。<br> 为了解决P、R、F-Measure(即<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B%5Clambda%20%5Cfrac%7B1%7D%7BP%7D%2B(1-%5Clambda)%5Cfrac%7B1%7D%7BR%7D%7D" alt="\frac{1}{\lambda \frac{1}{P}+(1-\lambda)\frac{1}{R}}">)的单点局限性，得到一个能够反映全局的指标，使用PR-AUC/AP。同样地，PR-AUC值越大，或者说曲线越接近右上角(p=1, r=1)，那么模型就越理想、越好。<br> <img src="https://math.jianshu.com/math?formula=AP%3D%5Cint_0%5E1%20p(r)d(r)" alt="AP=\int_0^1 p(r)d(r)"><ul><li>AAP(Approximated Average Precision)<br> AAP将PR-AUC面积分割成不同的长方形然后求面积和。<br> <img src="https://math.jianshu.com/math?formula=AAP%3D%5Csum_%7Bk%3D1%7D%5E%7BN%7Dp(k)%5CDelta%20r(k)" alt="AAP=\sum_{k=1}^{N}p(k)\Delta r(k)"></li><li>IAP(Interpolated Average Precision)<br> 如果存在r’&gt;r且p’&gt;p，使用p’代替p参与面积计算。AAP会比IAP离实际的PR-AUC更近，面积也会小点。<br> PASCAL VOC中使用IAP作为AP值，认为这一方法能够有效地减少PR曲线中的抖动。然后对于多类别进行AP取平均操作后得mAP值。</li></ul></li></ul><p>算法倾向如果是“宁可错杀一千，不可放过一个”，可以设定在合理的precision值下，最高的recall值作为最优点，找到这个点对应的阈值。总之，我们可以根据具体的应用或者是偏好，在曲线上找到最优的点，去调整模型的阈值，从而得到一个符合具体应用的模型。</p><h2 id="对于回归预测类常见的评估指标如下"><a href="#对于回归预测类常见的评估指标如下" class="headerlink" title="对于回归预测类常见的评估指标如下:"></a>对于回归预测类常见的评估指标如下:</h2><ul><li>平均绝对误差（Mean Absolute Error，MAE），均方误差（Mean Squared Error，MSE），平均绝对百分误差（Mean Absolute Percentage Error，MAPE），均方根误差（Root Mean Squared Error）， R2（R-Square）</li></ul><p><strong>平均绝对误差</strong> <strong>平均绝对误差（Mean Absolute Error，MAE）</strong>:平均绝对误差，其能更好地反映预测值与真实值误差的实际情况，其计算公式如下：<br>$$<br>MAE=\frac{1}{N} \sum_{i=1}^{N}\left|y_{i}-\hat{y}<em>{i}\right|<br>$$<br><strong>均方误差</strong> <strong>均方误差（Mean Squared Error，MSE）</strong>,均方误差,其计算公式为：<br>$$<br>MSE=1NN∑i=1(yi−^yi)2MSE=1N∑i=1N(yi−y^i)2<br>$$<br><strong>R2（R-Square）的公式为</strong>： 残差平方和：<br>$$<br>SSres=∑(yi−^yi)2SSres=∑(yi−y^i)2<br>$$<br>总平均值:<br>$$<br>SStot=∑(yi−¯¯¯yi)2SStot=∑(yi−y¯i)2<br>$$<br>其中¯¯¯yy¯表示yy的平均值 得到R2R2表达式为：<br>$$<br>R^{2}=1-\frac{SS</em>{res}}{SS_{tot}}=1-\frac{\sum\left(y_{i}-\hat{y}<em>{i}\right)^{2}}{\sum\left(y</em>{i}-\overline{y}\right)^{2}}<br>$$<br>R2用于度量因变量的变异中可由自变量解释部分所占的比例，取值范围是 0~1，R2越接近1,表明回归平方和占总平方和的比例越大,回归线与各观测点越接近，用x的变化来解释y值变化的部分就越多,回归的拟合程度就越好。所以R2也称为拟合优度（Goodness of Fit）的统计量。</p><p>yi表示真实值，^yi表示预测值，¯yii表示样本均值。得分越高拟合效果越好。</p><h2 id="偏度和峰度"><a href="#偏度和峰度" class="headerlink" title="偏度和峰度"></a>偏度和峰度</h2><p><img src="https://s1.ax1x.com/2020/03/30/Guu8it.png" alt="Guu8it.png"></p><p><img src="https://s1.ax1x.com/2020/03/30/Gunx2T.png" alt="Gunx2T.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天池-二手车交易价格预测</title>
      <link href="/2020/03/30/%E5%A4%A9%E6%B1%A0%20-%20%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E4%BB%B7%E6%A0%BC%E9%A2%84%E6%B5%8B/"/>
      <url>/2020/03/30/%E5%A4%A9%E6%B1%A0%20-%20%E4%BA%8C%E6%89%8B%E8%BD%A6%E4%BA%A4%E6%98%93%E4%BB%B7%E6%A0%BC%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>作为第一次参加数据分析的比赛，之前一直把知识都停留在表面，等到自己真正写起来，才发现很多地方都不会！！最后成绩197，虽然很低，但是也是自己努力的成果，从一个连基础的机器学习算法都不了解的小白，到一个可以进行简单预测，并调参的中白 :)</p><p><img src="https://s1.ax1x.com/2020/04/24/JrSVaD.jpg" alt="JrSVaD.jpg"></p><p>得益于这次比赛是由 <code>Datawhale与天池</code>联合发起的，在论坛提供了很多学习的知识，并且有大佬分析自己的baseline和思路，这种学习的氛围真的挺好的，否则自己太容易变成闷葫芦了~~防止闭门造车！！</p><p>先上个代码~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> boxcox, inv_boxcox</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line">data_train = pd.read_csv(<span class="string">"./Train_data.csv"</span>, sep=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># print(data_train.info())</span></span><br><span class="line"><span class="comment"># print(data_train.describe())</span></span><br><span class="line"></span><br><span class="line">data_test = pd.read_csv(<span class="string">"./TestA_data.csv"</span>, sep=<span class="string">","</span>)</span><br><span class="line">train_num = data_train.shape[<span class="number">0</span>]</span><br><span class="line">y_train = data_train[<span class="string">'price'</span>]</span><br><span class="line"><span class="comment">## 注意这里对y进行了boxcox变换</span></span><br><span class="line">y_train = boxcox(y_train, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">all_data = pd.concat((data_train, data_test)).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">all_data.drop([<span class="string">'price'</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processing_data</span><span class="params">(X)</span>:</span></span><br><span class="line">    number_X = X.select_dtypes(exclude=object)</span><br><span class="line">    <span class="comment">## 1.将数值型feature里的缺失值填补为他们每个featuer的均值</span></span><br><span class="line">    my_imputer = preprocessing.Imputer(strategy=<span class="string">'mean'</span>)</span><br><span class="line">    new_number_X = my_imputer.fit_transform(number_X)</span><br><span class="line">    <span class="comment">## （偏度）绝对值大于0.75的特征进行一个boxcox变换</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> number_X.columns:</span><br><span class="line">        <span class="keyword">if</span> abs(number_X[i].skew()) &gt; <span class="number">0.75</span>:</span><br><span class="line">            number_X[i] = boxcox(number_X[i], <span class="number">0</span>)</span><br><span class="line">    number_X = pd.DataFrame(new_number_X, columns=number_X.columns)</span><br><span class="line">    <span class="comment"># print('--------------------数字型特征已处理完毕--------------------')</span></span><br><span class="line"></span><br><span class="line">    category_X = X.select_dtypes(include=object)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> category_X.columns:</span><br><span class="line">        category_X[i] = category_X[i].fillna(<span class="string">'noinfo'</span>)</span><br><span class="line">    <span class="comment"># print('--------------------类别特征已处理完毕--------------------')</span></span><br><span class="line"></span><br><span class="line">    X = pd.concat([number_X, category_X], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># all_data = processing_data(all_data)</span></span><br><span class="line">all_data = pd.get_dummies(all_data, drop_first=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBRegressor</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, RandomizedSearchCV, StratifiedKFold, train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_log_error</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> boxcox, inv_boxcox</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor, GradientBoostingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, LassoCV, RidgeCV</span><br><span class="line"></span><br><span class="line">X_train = all_data[:<span class="number">150000</span>]</span><br><span class="line"></span><br><span class="line">X_train, x_val, y_train, y_val = train_test_split(X_train, y_train, test_size=<span class="number">0.25</span>)</span><br><span class="line">X_test = all_data[<span class="number">150000</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次</span></span><br><span class="line"><span class="comment"># &#123;'subsample': 1, 'scale_pos_weight': 0.5, 'reg_lambda': 1, 'reg_alpha': 0.5,</span></span><br><span class="line"><span class="comment"># 'n_estimators': 450, 'min_child_weight': 1, 'max_depth': 6, 'max_delta_step': 3,</span></span><br><span class="line"><span class="comment"># 'learning_rate': 0.08, 'colsample_bytree': 0.7&#125;</span></span><br><span class="line"><span class="comment"># &#123;'subsample': 0.1, 'num_leaves': 350, 'n_estimators': 300, 'min_child_samples': 4, 'max_depth': 90,</span></span><br><span class="line"><span class="comment"># 'learning_rate': 0.15&#125;</span></span><br><span class="line"><span class="comment"># 0.11190316301363079</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def find_best_param(model):</span></span><br><span class="line"><span class="comment">#     xgb_param_test = &#123;</span></span><br><span class="line"><span class="comment">#         'n_estimators': [450],</span></span><br><span class="line"><span class="comment">#         'max_depth': [6, 7, 8],</span></span><br><span class="line"><span class="comment">#         'learning_rate': [0.02, 0.05, 0.08],</span></span><br><span class="line"><span class="comment">#         'min_child_weight': [0, 1,2],</span></span><br><span class="line"><span class="comment">#         'max_delta_step': [ 3,4,5],</span></span><br><span class="line"><span class="comment">#         'subsample': [0.5, 0.8, 1],</span></span><br><span class="line"><span class="comment">#         'colsample_bytree': [0.5, 0.7, 1],</span></span><br><span class="line"><span class="comment">#         'reg_alpha': [0.2, 0.5, 1],</span></span><br><span class="line"><span class="comment">#         'reg_lambda': [0.3, 0.5, 1],</span></span><br><span class="line"><span class="comment">#         'scale_pos_weight': [0.3, 0.5, 1]</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment">#     # 注意RandomizedSearchCV跟GridSearchCV的参数 param_distributions跟param_grid作用相同，但名字不同</span></span><br><span class="line"><span class="comment">#     grid_search = RandomizedSearchCV(estimator=model, param_distributions=xgb_param_test, scoring='mean_squared_error',</span></span><br><span class="line"><span class="comment">#                                      cv=3)</span></span><br><span class="line"><span class="comment">#     #     grid_search = GridSearchCV(estimator=model, param_grid=xgb_param_test, scoring='mean_squared_error', cv=5)</span></span><br><span class="line"><span class="comment">#     grid_search.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment">#     print(grid_search.best_params_)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #</span></span><br><span class="line"><span class="comment"># xgbreg = XGBRegressor()</span></span><br><span class="line"><span class="comment"># find_best_param(xgbreg)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def find_best_param1(model):</span></span><br><span class="line"><span class="comment">#     lgb_param_test = &#123;</span></span><br><span class="line"><span class="comment">#         'num_leaves': [250, 300, 350],</span></span><br><span class="line"><span class="comment">#         'max_depth': [90, 100, 130],</span></span><br><span class="line"><span class="comment">#         'subsample': [0.1, 0.12, 0.15],</span></span><br><span class="line"><span class="comment">#         'min_child_samples': [3, 4, 5],</span></span><br><span class="line"><span class="comment">#         'learning_rate': [0.05,0.1,0.15],</span></span><br><span class="line"><span class="comment">#         'n_estimators': [100,200,300]</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 注意RandomizedSearchCV跟GridSearchCV的参数 param_distributions跟param_grid作用相同，但名字不同</span></span><br><span class="line"><span class="comment">#     grid_search = RandomizedSearchCV(estimator=model, param_distributions=lgb_param_test, scoring='mean_squared_error',</span></span><br><span class="line"><span class="comment">#                                      cv=3)</span></span><br><span class="line"><span class="comment">#     #     grid_search = GridSearchCV(estimator=model, param_grid=xgb_param_test, scoring='mean_squared_error', cv=5)</span></span><br><span class="line"><span class="comment">#     grid_search.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment">#     print(grid_search.best_params_)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lgbreg = LGBMRegressor(objective='regression_l1')</span></span><br><span class="line"><span class="comment"># find_best_param1(lgbreg)</span></span><br><span class="line"><span class="comment"># # ======================================================</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'--------------------正在进行模型训练--------------------'</span>)</span><br><span class="line"><span class="comment"># 最终模型与测试集答案相比的误差：0.10836896959704842，n=10000，0.05</span></span><br><span class="line">xgbreg1 = XGBRegressor(subsample=<span class="number">1</span>, scale_pos_weight=<span class="number">0.5</span>, reg_lambda=<span class="number">1</span>, reg_alpha=<span class="number">0.5</span>,</span><br><span class="line">                       n_estimators=<span class="number">10000</span>, min_child_weight=<span class="number">1</span>, max_depth=<span class="number">6</span>, max_delta_step=<span class="number">3</span>,</span><br><span class="line">                       learning_rate=<span class="number">0.05</span>, colsample_bytree=<span class="number">0.7</span>)</span><br><span class="line">xgbreg1.fit(X_train, y_train)</span><br><span class="line">xgb_train_pred = xgbreg1.predict(X_train)</span><br><span class="line">xgb_test_pred = xgbreg1.predict(x_val)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lgbreg = LGBMRegressor(objective=<span class="string">'regression_l1'</span>, subsample=<span class="number">0.1</span>, num_leaves=<span class="number">350</span>,</span><br><span class="line">                       min_child_samples=<span class="number">4</span>, max_depth=<span class="number">90</span>,n_estimators=<span class="number">10000</span>,learning_rate=<span class="number">0.05</span>)</span><br><span class="line">lgbreg.fit(X_train, y_train)</span><br><span class="line">lgb_train_pred = lgbreg.predict(X_train)</span><br><span class="line">lgb_test_pred = lgbreg.predict(x_val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def rmsle(y, y_pred):</span></span><br><span class="line"><span class="comment">#     return np.sqrt(mean_squared_log_error(y, y_pred))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error, mean_squared_log_error</span><br><span class="line"><span class="comment"># y_train = inv_boxcox(y_train,0)</span></span><br><span class="line"><span class="comment"># lgb_train_pred = inv_boxcox(lgb_train_pred,0)</span></span><br><span class="line"><span class="comment"># xgb_train_pred = inv_boxcox(xgb_train_pred,0)</span></span><br><span class="line">print(<span class="string">'LGBM与训练集答案相比的对数误差：&#123;&#125;'</span>.format(mean_absolute_error(y_train, lgb_train_pred)))</span><br><span class="line">print(<span class="string">'Xgboost与训练集答案相比的误差：&#123;&#125;'</span>.format(mean_absolute_error(y_train, xgb_train_pred)))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # y_val = inv_boxcox(y_val,0)</span></span><br><span class="line"><span class="comment"># # lgb_test_pred = inv_boxcox(lgb_test_pred,0)</span></span><br><span class="line"><span class="comment"># # xgb_test_pred = inv_boxcox(xgb_test_pred,0)</span></span><br><span class="line">ensemble_pred = <span class="number">0.5</span> * xgb_test_pred + <span class="number">0.5</span> * lgb_test_pred</span><br><span class="line"></span><br><span class="line">print(<span class="string">'lgb与测试集答案相比的误差：&#123;&#125;'</span>.format(mean_absolute_error(y_val, lgb_test_pred)))</span><br><span class="line">print(<span class="string">'xgb与测试集答案相比的误差：&#123;&#125;'</span>.format(mean_absolute_error(y_val, xgb_test_pred)))</span><br><span class="line">print(<span class="string">'最终模型与测试集答案相比的误差：&#123;&#125;'</span>.format(mean_absolute_error(y_val, ensemble_pred)))</span><br><span class="line"></span><br><span class="line">p1 = lgbreg.predict(X_test)</span><br><span class="line">p2 = xgbreg1.predict(X_test)</span><br><span class="line">p = <span class="number">0.5</span>*p1+<span class="number">0.5</span>*p2</span><br><span class="line">p = inv_boxcox(p,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">sub = pd.DataFrame()</span><br><span class="line">sub[<span class="string">'SaleID'</span>] =X_test.index</span><br><span class="line">sub[<span class="string">'price'</span>] = p</span><br><span class="line">sub.to_csv(<span class="string">'./house3.csv'</span>,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xgbreg1 = XGBRegressor(subsample=0.8, scale_pos_weight=0.5, reg_lambda=0.5, reg_alpha=1,</span></span><br><span class="line"><span class="comment">#                        n_estimators=4000, min_child_weight=1, max_depth=7, max_delta_step=2,</span></span><br><span class="line"><span class="comment">#                        learning_rate=0.08, colsample_bytree=0.7)</span></span><br><span class="line"><span class="comment"># lgbreg = LGBMRegressor(objective='regression_l1', subsample=0.15, num_leaves=350, min_child_samples=4, max_depth=90,n_estimators=4000)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ML，天池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统知识学习</title>
      <link href="/2020/03/16/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/16/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统基础"><a href="#推荐系统基础" class="headerlink" title="推荐系统基础"></a>推荐系统基础</h1><h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><h3 id="推荐的概念"><a href="#推荐的概念" class="headerlink" title="推荐的概念"></a>推荐的概念</h3><ul><li>信息过滤系统 解决 信息过载 用户需求不明确的问题<ul><li>利用一定的规则将物品排序 展示给需求不明确的用户</li></ul></li><li>推荐 搜索区别<ul><li>推荐个性化较强，用户被动的接受，希望能够提供持续的服务</li><li>搜索个性化弱，用户主动搜索，快速满足用户的需求</li></ul></li><li>推荐和 web项目区别<ul><li>构建稳定的信息流通通道</li><li>推荐 信息过滤系统</li><li>web 对结果有明确预期</li><li>推荐 结果是概率问题</li></ul></li></ul><h3 id="Lambda-架构介绍"><a href="#Lambda-架构介绍" class="headerlink" title="Lambda 架构介绍"></a>Lambda 架构介绍</h3><p><img src="https://s1.ax1x.com/2020/03/18/8DnuIf.png" alt="8DnuIf.png"></p><ul><li>离线计算和实时计算共同提供服务的问题</li><li>离线计算优缺点<ul><li>优点 能够处理的数据量可以很大 比如pb级别</li><li>缺点 速度比较慢 分钟级别的延迟</li></ul></li><li>实时计算<ul><li>优点 响应快 来一条数据处理一条 ms级别响应</li><li>缺点 处理的数据量小一些</li></ul></li><li>离线计算的框架<ul><li>hadoop hdfs mapreduce</li><li>spark core , spark sql</li><li>hive</li></ul></li><li>实时计算框架<ul><li>spark streaming</li><li>storm</li><li>flink</li></ul></li><li>消息中间件<ul><li>flume 日志采集系统</li><li>kafka 消息队列</li></ul></li><li>存储相关<ul><li>hbase nosql数据库</li><li>hive  sql操作hdfs数据</li></ul></li></ul><h3 id="推荐算法架构"><a href="#推荐算法架构" class="headerlink" title="推荐算法架构"></a>推荐算法架构</h3><ul><li><p>召回</p><ul><li><p>协同过滤  算相似度 memory base</p></li><li><p>基于模型的 model base  矩阵分解</p></li><li><p>基于内容</p><ul><li>分词</li><li>词权重（提取关键词） tf-idf</li><li>word2Vec 词向量</li><li>物品向量</li></ul></li></ul></li><li><p>排序</p><ul><li>逻辑回归</li></ul></li><li><p>策略调整</p></li></ul><p>  整体流程</p><p><img src="https://s1.ax1x.com/2020/03/18/8DlFu4.jpg" alt="8DlFu4.jpg"></p><p>lambda内</p><p><img src="https://s1.ax1x.com/2020/03/18/8D1mZj.png" alt="8D1mZj.png"></p><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li>推荐模型构建流程</li><li>推荐算法概述</li><li>基于协同过滤的推荐算法</li><li>协同过滤实现</li></ul><h3 id="一-推荐模型构建流程"><a href="#一-推荐模型构建流程" class="headerlink" title="一 推荐模型构建流程"></a>一 推荐模型构建流程</h3><p>Data(数据)-&gt;Features(特征)-&gt;ML Algorithm(机器学习算法)-&gt;Prediction Output(预测输出)</p><ul><li>数据清洗/数据处理</li></ul><p><img src="https://s1.ax1x.com/2020/03/20/8cChRJ.png" alt="8cChRJ.png"></p><ul><li><p>数据来源</p><ul><li>显性数据<ul><li>Rating 打分</li><li>Comments 评论/评价</li></ul></li><li>隐形数据<ul><li> Order history 历史订单</li><li> Cart events    加购物车</li><li> Page views    页面浏览</li><li> Click-thru      点击</li><li> Search log     搜索记录</li></ul></li></ul></li><li><p>数据量/数据能否满足要求</p></li><li><p>特征工程</p></li><li><p>从数据中筛选特征</p><ul><li>一个给定的商品，可能被拥有类似品味或需求的用户购买</li><li>使用用户行为数据描述商品</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/03/20/8cPgOI.png" alt="8cPgOI.png"></p><ul><li><p>用数据表示特征</p><ul><li><p>将所有用户行为合并在一起 ，形成一个user-item 矩阵</p><p><img src="https://s1.ax1x.com/2020/03/20/8cijKA.png" alt="8cijKA.png">选择合适的算法</p></li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/03/20/8cFpUf.png" alt="8cFpUf.png"></p><ul><li><p>产生推荐结果</p><p><img src="https://s1.ax1x.com/2020/03/20/8cFi8g.png" alt="8cFi8g.png"></p></li></ul><h3 id="二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）"><a href="#二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）" class="headerlink" title="二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）"></a>二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</h3><h4 id="协同过滤-CF-思路介绍"><a href="#协同过滤-CF-思路介绍" class="headerlink" title="协同过滤(CF)思路介绍"></a>协同过滤(CF)思路介绍</h4><ul><li><p>CF <strong>物以类聚人以群分</strong></p></li><li><p>做协同过滤的话 首先特征工程把 用户-物品的评分矩阵创建出来</p></li><li><p>基于用户的协同过滤</p><p><img src="https://s1.ax1x.com/2020/03/19/8r3IJI.png" alt="8r3IJI.png"></p><ul><li>给用户A 找到最相似的N个用户</li><li>N个用户消费过哪些物品</li><li>N个用户消费过的物品中-A用户消费过的就是推荐结果</li></ul></li><li><p>基于物品的协同过滤</p><p><img src="https://s1.ax1x.com/2020/03/19/8r3xFs.png" alt="8r3xFs.png"></p><ul><li>给物品A 找到最相似的N个物品</li><li>A用户消费记录 找到这些物品的相似物品</li><li>从这些相似物品先去重-A用户消费过的就是推荐结果</li></ul></li></ul><h3 id="三-相似度计算-Similarity-Calculation"><a href="#三-相似度计算-Similarity-Calculation" class="headerlink" title="三 相似度计算(Similarity Calculation)"></a>三 相似度计算(Similarity Calculation)</h3><h4 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul><li>余弦相似度、皮尔逊相关系数<ul><li>向量的夹角余弦值</li><li>皮尔逊会对向量的每一个分量做中心化</li><li>余弦只考虑方向 不考虑向量长度</li><li>如果评分数据是连续的数值比较适合中余弦、皮尔逊计算相似度</li></ul></li><li>杰卡德相似度<ul><li>交集/并集</li><li>计算评分是0 1 布尔值的相似度</li></ul></li></ul><h4 id="使用不同相似度计算方式实现协同过滤"><a href="#使用不同相似度计算方式实现协同过滤" class="headerlink" title="使用不同相似度计算方式实现协同过滤"></a>使用不同相似度计算方式实现协同过滤</h4><ul><li><p>如果 买/没买 点/没点数据 0/1 适合使用<strong>杰卡德相似度</strong></p><ul><li>from sklearn.metrics import jaccard_similarity_score</li><li>jaccard_similarity_score(df[‘Item A’],df[‘Item B’])</li><li>from sklearn.metrics.pairwise import pairwise_distances</li><li>user_similar = 1-pairwise_distances(df,metric=’jaccard’)</li></ul></li><li><p>一般用评分去做协同过滤 推荐使用<strong>皮尔逊相关系数</strong>(sim是交集除并集)</p><ul><li><p>评分预测</p></li><li><p>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$</p></li></ul></li><li><p>基于用户和基于物品的协同过滤 严格上说，属于两种算法，实践中可以都做出来，对比效果，选择最靠谱的</p></li></ul><h3 id="协同过滤推荐算法代码实现："><a href="#协同过滤推荐算法代码实现：" class="headerlink" title="协同过滤推荐算法代码实现："></a>协同过滤推荐算法代码实现：</h3><ul><li><p>构建数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算时我们数据通常都需要对数据进行处理，或者编码，目的是为了便于我们对数据进行运算处理，比如这里是比较简单的情形，我们用1、0分别来表示用户的是否购买过该物品，则我们的数据集其实应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>有了数据集，接下来我们就可以进行相似度的计算，不过对于相似度的计算其实是有很多专门的相似度计算方法的，比如余弦相似度、皮尔逊相关系数、杰卡德相似度等等。这里我们选择使用杰卡德相似系数[0,1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接计算某两项的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line"><span class="comment"># 计算Item A 和Item B的相似度</span></span><br><span class="line">print(jaccard_similarity_score(df[<span class="string">"Item A"</span>], df[<span class="string">"Item B"</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数(相似度=1-距离)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">print(item_similar)</span><br></pre></td></tr></table></figure><p>有了两两的相似度，接下来就可以筛选TOP-N相似结果，并进行推荐了</p></li><li><p>User-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line">topN_users = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> user_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = user_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = list(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_users[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Top2相似用户："</span>)</span><br><span class="line">pprint(topN_users)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user, sim_users <span class="keyword">in</span> topN_users.items():</span><br><span class="line">    rs_result = set()    <span class="comment"># 存储推荐结果</span></span><br><span class="line">    <span class="keyword">for</span> sim_user <span class="keyword">in</span> sim_users:</span><br><span class="line">        <span class="comment"># 构建初始的推荐结果</span></span><br><span class="line">        <span class="comment">#dropna()的使用  b=a.dropna()，则直接将a中的nan值给删除掉了</span></span><br><span class="line">        <span class="comment"># 使用loc:只能指定行列索引的名字</span></span><br><span class="line">        <span class="comment"># 使用iloc可以通过索引的下标去获取</span></span><br><span class="line">        <span class="comment"># 使用ix进行下表和名称组合做引</span></span><br><span class="line">        rs_result = rs_result.union(set(df.ix[sim_user].replace(<span class="number">0</span>,np.nan).dropna().index))</span><br><span class="line">    <span class="comment"># 过滤掉已经购买过的物品</span></span><br><span class="line">    rs_result -= set(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line">print(<span class="string">"最终推荐结果："</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li><li><p>Item-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">print(item_similar)</span><br><span class="line"></span><br><span class="line">topN_items = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> item_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = item_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = list(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_items[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Top2相似物品："</span>)</span><br><span class="line">pprint(topN_items)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> df.index:    <span class="comment"># 遍历所有用户</span></span><br><span class="line">    rs_result = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index:   <span class="comment"># 取出每个用户当前已购物品列表</span></span><br><span class="line">        <span class="comment"># 根据每个物品找出最相似的TOP-N物品，构建初始推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(topN_items[item])</span><br><span class="line">    <span class="comment"># 过滤掉用户已购的物品</span></span><br><span class="line">    rs_result -= set(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    <span class="comment"># 添加到结果中</span></span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"></span><br><span class="line">print(<span class="string">"最终推荐结果："</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li></ul><p><strong>关于协同过滤推荐算法使用的数据集</strong></p><p>在前面的demo中，我们只是使用用户对物品的一个购买记录，类似也可以是比如浏览点击记录、收听记录等等。这样数据我们预测的结果其实相当于是在预测用户是否对某物品感兴趣，对于喜好程度不能很好的预测。</p><p>因此在协同过滤推荐算法中其实会更多的利用用户对物品的“评分”数据来进行预测，通过评分数据集，我们可以预测用户对于他没有评分过的物品的评分。其实现原理和思想和都是一样的，只是使用的数据集是用户-物品的评分数据。</p><p><strong>关于用户-物品评分矩阵</strong></p><p>用户-物品的评分矩阵，根据评分矩阵的稀疏程度会有不同的解决方案</p><ul><li><p>稠密评分矩阵</p><p><img src="https://s1.ax1x.com/2020/03/20/828fEV.png" alt="828fEV.png"></p></li><li><p>稀疏评分矩阵</p><p><img src="https://s1.ax1x.com/2020/03/20/823Ofg.png" alt="823Ofg.png"></p></li></ul><p>这里先介绍稠密评分矩阵的处理，稀疏矩阵的处理相对会复杂一些，我们到后面再来介绍。</p><h4 id="使用协同过滤推荐算法对用户进行评分预测"><a href="#使用协同过滤推荐算法对用户进行评分预测" class="headerlink" title="使用协同过滤推荐算法对用户进行评分预测"></a>使用协同过滤推荐算法对用户进行评分预测</h4><ul><li><p>数据集：</p><p><img src="https://s1.ax1x.com/2020/03/20/828fEV.png" alt="828fEV.png"></p><p><strong>目的：预测用户1对物品E的评分</strong></p></li><li><p>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p><blockquote><p>pandas中corr方法可直接用于计算皮尔逊相关系数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line">print(user_similar.round(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line">print(item_similar.round(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 运行结果：</span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  1.0000  0.8528  0.7071  0.0000 -0.7921</span><br><span class="line">User2  0.8528  1.0000  0.4677  0.4900 -0.9001</span><br><span class="line">User3  0.7071  0.4677  1.0000 -0.1612 -0.4666</span><br><span class="line">User4  0.0000  0.4900 -0.1612  1.0000 -0.6415</span><br><span class="line">User5 -0.7921 -0.9001 -0.4666 -0.6415  1.0000</span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  1.0000 -0.4767 -0.1231  0.5322  0.9695</span><br><span class="line">Item B -0.4767  1.0000  0.6455 -0.3101 -0.4781</span><br><span class="line">Item C -0.1231  0.6455  1.0000 -0.7206 -0.4276</span><br><span class="line">Item D  0.5322 -0.3101 -0.7206  1.0000  0.5817</span><br><span class="line">Item E  0.9695 -0.4781 -0.4276  0.5817  1.0000</span><br></pre></td></tr></table></figure><p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p><p><strong>注意：</strong>我们在预测评分时，往往是通过与其有正相关的用户或物品进行预测，如果不存在正相关的情况，那么将无法做出预测。这一点尤其是在稀疏评分矩阵中尤为常见，因为稀疏评分矩阵中很难得出正相关系数。</p></li><li><p><strong>评分预测：</strong></p><p><strong>User-Based CF 评分预测：使用用户间的相似度进行预测</strong></p><p>关于评分预测的方法也有比较多的方案，下面介绍一种效果比较好的方案，该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测：<br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$<br>我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p><p>​<br>$$<br>pred(u_1, i_5) =\cfrac{0.85<em>3+0.71</em>5}{0.85+0.71} = 3.91<br>$$<br>最终预测出用户1对物品5的评分为3.91</p><p><strong>Item-Based CF 评分预测：使用物品间的相似度进行预测</strong></p><p>这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测<br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{j\in I_{rated}}sim(i,j)<em>r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}<br>$$<br>我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下：<br>$$<br>pred(u_1, i_5) = \cfrac {0.97</em>5+0.58*4}{0.97+0.58} = 4.63<br>$$<br>对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法，各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估，因此在实现推荐系统时这两种算法往往都是需要去实现的，然后对产生的推荐效果进行评估分析选出更优方案。</p></li></ul><h3 id="基于模型的方法–解决用户和物品矩阵比较稀疏的情况"><a href="#基于模型的方法–解决用户和物品矩阵比较稀疏的情况" class="headerlink" title="基于模型的方法–解决用户和物品矩阵比较稀疏的情况"></a>基于模型的方法–解决用户和物品矩阵比较稀疏的情况</h3><ul><li><p>思想</p><ul><li>通过机器学习算法，在数据中找出模式，并将用户与物品间的互动方式模式化</li><li>基于模型的协同过滤方式是构建协同过滤更高级的算法</li></ul></li><li><p>近邻模型的问题</p><ul><li>物品之间存在相关性, 信息量并不随着向量维度增加而线性增加</li><li>矩阵元素稀疏, 计算结果不稳定,增减一个向量维度, 导致近邻结果差异很大的情况存在</li></ul></li><li><p>算法分类</p><ul><li>基于图的模型</li><li><strong>基于矩阵分解的方法</strong></li></ul></li><li><p>基于图的模型</p><ul><li>基于邻域的模型看做基于图的模型的简单形式</li></ul><p><img src="https://s1.ax1x.com/2020/03/21/8R24bt.png" alt="8R24bt.png"></p><ul><li>原理<ul><li>将用户的行为数据表示为二分图</li><li>基于二分图为用户进行推荐</li><li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li></ul></li></ul></li><li><p>基于矩阵分解的模型–降维</p><ul><li><p>原理</p><ul><li><p>根据用户与物品的潜在表现，我们就可以预测用户对未评分的物品的喜爱程度</p></li><li><p>把原来的大矩阵, 近似分解成两个小矩阵的乘积, 在实际推荐计算时不再使用大矩阵, 而是使用分解得到的两个小矩阵  </p></li><li><p>用户-物品评分矩阵A是M X N维, 即一共有M个用户, n个物品 我们选一个很小的数 K (K&lt;&lt; M, K&lt;&lt;N)</p></li><li><p>通过计算得到两个矩阵U V  U是M * K矩阵 , 矩阵V是 N * K</p><p>$U_{m<em>k} V^{T}_{n</em>k} 约等于 A_{m*n}$</p><p>类似这样的计算过程就是矩阵分解</p></li></ul></li><li><p>基于矩阵分解的方法</p><ul><li>ALS交替最小二乘<ul><li>ALS-WR(加权正则化交替最小二乘法): alternating-least-squares with weighted-λ –regularization</li><li>将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户做商品推荐了。</li></ul></li><li>SVD奇异值分解矩阵</li></ul></li></ul></li><li><p>ALS方法–交替最小二乘法来优化损失</p><p><img src="https://s1.ax1x.com/2020/03/21/8R2T58.png" alt="8R2T58.png"></p><ul><li>ALS的矩阵分解算法常应用于推荐系统中，将用户(user)对商品(item)的评分矩阵，分解为用户对商品隐含特征的偏好矩阵，和商品在隐含特征上的映射矩阵。</li><li>与传统的矩阵分解SVD方法来分解矩阵R(R∈ℝm×n)不同的是，ALS(alternating least squares)希望找到两个低维矩阵，以 R̃ =XY 来逼近矩阵R，其中 ，X∈ℝm×d，Y∈ℝd×n，这样，将问题的复杂度由O(m<em>n)转换为O((m+n)</em>d)。</li><li>计算X和Y过程：首先用一个小于1的随机数初始化Y，并根据公式求X，此时就可以得到初始的XY矩阵了，根据平方差和得到的X，重新计算并覆盖Y，计算差平方和，反复进行以上两步的计算，直到差平方和小于一个预设的数，或者迭代次数满足要求则停止</li></ul></li></ul><h2 id="四-推荐系统评估"><a href="#四-推荐系统评估" class="headerlink" title="四 推荐系统评估"></a>四 推荐系统评估</h2><ul><li><p>好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢</p></li><li><p>显示反馈和隐式反馈</p><table>  <tr>    <th></th>    <th>显式反馈</th>    <th>隐式反馈</th>  </tr>  <tr> <td> 例子 </td> <td> 电影/书籍评分  是否喜欢这个推荐 </td> <td> 播放/点击 评论 下载 购买 </td>  </tr>  <tr>    <td> 准确性 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 数量 </td>    <td> 少 </td>    <td> 多 </td>  </tr>  <tr>    <td> 获取成本 </td>    <td> 高 </td>    <td> 低 </td>  </tr></table></li><li><p>常用评估指标</p><p>• 准确性  • 信任度<br>• 满意度  • 实时性<br>• 覆盖率  • 鲁棒性<br>• 多样性  • 可扩展性<br>• 新颖性  • 商业⽬标<br>• 惊喜度  • ⽤户留存</p><ul><li><p>准确性 (理论角度) Netflix 美国录像带租赁</p><ul><li>评分预测–线性回归<ul><li>RMSE   MAE</li></ul></li><li>topN推荐<ul><li>召回率 精准率</li></ul></li></ul></li><li><p>准确性 (业务角度)</p></li><li><p>覆盖度</p><ul><li>信息熵 对于推荐越大越好</li><li>覆盖率</li></ul></li><li><p>多样性&amp;新颖性&amp;惊喜性</p><ul><li>多样性：推荐列表中两两物品的不相似性。（相似性如何度量？</li><li>新颖性：未曾关注的类别、作者；推荐结果的平均流⾏度</li><li>惊喜性：历史不相似（惊）但很满意（喜）</li><li>往往需要牺牲准确性</li><li>使⽤历史⾏为预测⽤户对某个物品的喜爱程度</li><li>系统过度强调实时性</li></ul></li><li><p>Exploitation &amp; Exploration 探索与利用问题</p><ul><li>Exploitation(开发 利用)：选择现在可能最佳的⽅案</li><li>Exploration(探测 搜索)：选择现在不确定的⼀些⽅案，但未来可能会有⾼收益的⽅案</li><li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化<br>长期的⽬标</li></ul></li><li><p>EE问题实践</p><ul><li>兴趣扩展: 相似话题, 搭配推荐</li><li>人群算法: userCF 用户聚类</li><li>平衡个性化推荐和热门推荐比例</li><li>随机丢弃用户行为历史</li><li>随机扰动模型参数</li></ul></li><li><p>EE可能带来的问题</p><ul><li>探索伤害用户体验, 可能导致用户流失</li><li>探索带来的长期收益(留存率)评估周期长, KPI压力大</li><li>如何平衡实时兴趣和长期兴趣</li><li>如何平衡短期产品体验和长期系统生态</li><li>如何平衡大众口味和小众需求</li></ul></li><li><p>评估方法</p><ul><li>问卷调查: 成本高</li><li>离线评估:<ul><li>只能在用户看到过的候选集上做评估, 且跟线上真实效果存在偏差</li><li>只能评估少数指标</li><li>速度快, 不损害用户体验</li></ul></li><li>在线评估: 灰度发布 &amp; A/B测试 50% 全量上线</li><li>实践: 离线评估和在线评估结合, 定期做问卷调查</li></ul></li></ul></li></ul><h3 id="五-推荐系统的冷启动问题"><a href="#五-推荐系统的冷启动问题" class="headerlink" title="五 推荐系统的冷启动问题"></a>五 推荐系统的冷启动问题</h3><ul><li><p>推荐系统冷启动概念</p><ul><li>⽤户冷启动：如何为新⽤户做个性化推荐</li><li>物品冷启动：如何将新物品推荐给⽤户（协同过滤）</li><li>系统冷启动：⽤户冷启动+物品冷启动</li><li>本质是推荐系统依赖历史数据，没有历史数据⽆法预测⽤户偏好</li></ul></li><li><p>用户冷启动</p><ul><li><p>1.收集⽤户特征</p><ul><li><p>⽤户注册信息：性别、年龄、地域</p></li><li><p>设备信息：定位、⼿机型号、app列表</p></li><li><p>社交信息、推⼴素材、安装来源</p></li></ul></li><li><p>2 引导用户填写兴趣</p></li><li><p>3 使用其它站点的行为数据, 例如腾讯视频&amp;QQ音乐 今日头条&amp;抖音</p></li><li><p>4 新老用户推荐策略的差异</p><ul><li>新⽤户在冷启动阶段更倾向于热门排⾏榜，⽼⽤户会更加需要长尾推荐</li><li>Explore Exploit⼒度</li><li>使⽤单独的特征和模型预估</li></ul></li><li><p>举例 性别与电视剧的关系</p></li></ul></li><li><p>物品冷启动</p><ul><li>给物品打标签–构建物品画像</li><li>利用物品的内容信息，将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。</li></ul></li><li><p>系统冷启动</p><ul><li>基于内容的推荐 系统早期</li><li>基于内容的推荐逐渐过渡到协同过滤</li><li>基于内容的推荐和协同过滤的推荐结果都计算出来 加权求和得到最终推荐结果</li></ul></li></ul><h2 id="案例–基于协同过滤的电影推荐"><a href="#案例–基于协同过滤的电影推荐" class="headerlink" title="案例–基于协同过滤的电影推荐"></a>案例–基于协同过滤的电影推荐</h2><p>前面我们已经基本掌握了协同过滤推荐算法，以及其中两种最基本的实现方案：User-Based CF和Item-Based CF，下面我们将利用真是的数据来进行实战演练。</p><p>案例需求 演示效果</p><p>分析案例</p><h4 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h4><p><a href="https://grouplens.org/datasets/movielens/latest/" target="_blank" rel="noopener">MovieLens Latest Datasets Small</a></p><p>建议下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip" target="_blank" rel="noopener">ml-latest-small.zip</a>，数据量小，便于我们单机使用和运行</p><p>目标：根据<code>ml-latest-small/ratings.csv</code>（用户-电影评分数据），分别实现User-Based CF和Item-Based CF，并进行电影评分的预测，然后为用户实现电影推荐</p><h4 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h4><ul><li><p>加载ratings.csv，并转换为用户-电影评分矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">"./datasets/ml-latest-small/ratings.csv"</span></span><br><span class="line">CACHE_DIR = <span class="string">"./datasets/cache/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(data_path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 数据集缓存地址</span></span><br><span class="line">    cache_path = os.path.join(CACHE_DIR, <span class="string">"ratings_matrix.cache"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"开始加载数据集..."</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache_path):    <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">        print(<span class="string">"加载缓存中..."</span>)</span><br><span class="line">        ratings_matrix = pd.read_pickle(cache_path) <span class="comment"># 转换成pickle加快操作</span></span><br><span class="line">        print(<span class="string">"从缓存加载数据集完毕"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"加载新数据中..."</span>)</span><br><span class="line">        <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">        dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">        <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">        ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>)) <span class="comment"># 读取前三列</span></span><br><span class="line">        <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">        ratings_matrix = ratings.pivot_table(index=[<span class="string">"userId"</span>], columns=[<span class="string">"movieId"</span>], values=<span class="string">"rating"</span>)</span><br><span class="line">        <span class="comment"># 存入缓存文件</span></span><br><span class="line">        ratings_matrix.to_pickle(cache_path)</span><br><span class="line">        print(<span class="string">"数据集加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span>  ratings_matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br></pre></td></tr></table></figure></li></ul><p>(<a href="https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html</a>) 透视表知识点补充</p><h4 id="相似度计算-1"><a href="#相似度计算-1" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul><li><p>计算用户或物品两两相似度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span><span class="params">(ratings_matrix, based=<span class="string">"user"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param based: "user" or "item"</span></span><br><span class="line"><span class="string">    :return: 相似度矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"user_similarity.cache"</span>)</span><br><span class="line">    item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"item_similarity.cache"</span>)</span><br><span class="line">    <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">    <span class="comment"># 用户相似度</span></span><br><span class="line">    <span class="keyword">if</span> based == <span class="string">"user"</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">            print(<span class="string">"正从缓存加载用户相似度矩阵"</span>)</span><br><span class="line">            similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"开始计算用户相似度矩阵"</span>)</span><br><span class="line">            similarity = ratings_matrix.T.corr()</span><br><span class="line">            similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> based == <span class="string">"item"</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">            print(<span class="string">"正从缓存加载物品相似度矩阵"</span>)</span><br><span class="line">            similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"开始计算物品相似度矩阵"</span>)</span><br><span class="line">            similarity = ratings_matrix.corr()</span><br><span class="line">            similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Unhandled 'based' Value: %s"</span>%based)</span><br><span class="line">    print(<span class="string">"相似度矩阵计算/加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    print(user_similar)</span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"item"</span>)</span><br><span class="line">    print(item_similar)</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上实现，仅用于实验阶段，因为工业上、或生产环境中，数据量是远超过我们本例中使用的数据量的，而pandas是无法支撑起大批量数据的运算的，因此工业上通常会使用spark、mapReduce等分布式计算框架来实现，我们后面的课程中也是建立在此基础上进行实践的。</p><p>但是正如前面所说，推荐算法的思想和理念都是统一的，不论使用什么平台工具、有多大的数据体量，其背后的实现原理都是不变的。</p><p>所以在本节，大家要深刻去学习的是推荐算法的业务流程，以及在具体的业务场景中，如本例的电影推荐，如何实现出推荐算法，并产生推荐结果。</p><h2 id="案例–算法实现：User-Based-CF-预测评分"><a href="#案例–算法实现：User-Based-CF-预测评分" class="headerlink" title="案例–算法实现：User-Based CF 预测评分"></a>案例–算法实现：User-Based CF 预测评分</h2><p><strong>评分预测公式：</strong><br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>实现评分预测方法：<code>predict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(uid, iid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分..."</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">    similar_users = user_similar[uid].drop([uid]).dropna()</span><br><span class="line">    <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">    similar_users = similar_users.where(similar_users&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;没有相似的用户"</span> % uid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">    ids = set(ratings_matrix[iid].dropna().index)&amp;set(similar_users.index)</span><br><span class="line">    finally_similar_users = similar_users.ix[list(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">        <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">        sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">        <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">        sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">"预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f"</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> round(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, user_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, user_similar)</span><br></pre></td></tr></table></figure></li><li><p>实现预测全部评分方法：<code>predict_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(uid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>添加过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span><span class="params">(uid, item_ids, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(uid, ratings_matrix, user_similar, filter_rule=None)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常："unhot","rated",["unhot","rated"],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"unhot"</span>:</span><br><span class="line">        <span class="string">'''过滤非热门电影'''</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"rated"</span>:</span><br><span class="line">        <span class="string">'''过滤用户评分过的电影'''</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, list) <span class="keyword">and</span> set(filter_rule) == set([<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">        <span class="string">'''过滤非热门和用户已经评分过的电影'''</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = set(ids1)&amp;set(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"无效的过滤参数"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure></li><li><p>根据预测评分为指定用户进行TOP-N推荐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span><span class="params">(k)</span>:</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>])</span><br><span class="line">    <span class="keyword">return</span> sorted(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br></pre></td></tr></table></figure></li></ul><h2 id="案例–算法实现：Item-Based-CF-预测评分"><a href="#案例–算法实现：Item-Based-CF-预测评分" class="headerlink" title="案例–算法实现：Item-Based CF 预测评分"></a>案例–算法实现：Item-Based CF 预测评分</h2><p><strong>评分预测公式：</strong><br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}<br>$$<br>(与U-B一样)</p><h3 id="Model-Based-协同过滤算法"><a href="#Model-Based-协同过滤算法" class="headerlink" title="Model-Based 协同过滤算法"></a>Model-Based 协同过滤算法</h3><p>随着机器学习技术的逐渐发展与完善，推荐系统也逐渐运用机器学习的思想来进行推荐。将机器学习应用到推荐系统中的方案真是不胜枚举。以下对Model-Based CF算法做一个大致的分类：</p><ul><li>基于分类算法、回归算法、聚类算法</li><li>基于矩阵分解的推荐</li><li>基于神经网络算法</li><li>基于图模型算法</li></ul><p>接下来我们重点学习以下几种应用较多的方案：</p><ul><li><strong>基于K最近邻的协同过滤推荐</strong></li><li><strong>基于回归模型的协同过滤推荐</strong></li><li><strong>基于矩阵分解的协同过滤推荐</strong></li></ul><h2 id="基于K最近邻的协同过滤推荐"><a href="#基于K最近邻的协同过滤推荐" class="headerlink" title="基于K最近邻的协同过滤推荐"></a>基于K最近邻的协同过滤推荐</h2><p>基于K最近邻的协同过滤推荐其实本质上就是MemoryBased CF，只不过在选取近邻的时候，加上K最近邻的限制。</p><p>这里我们直接根据MemoryBased CF的代码实现</p><p>修改以下地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollaborativeFiltering</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    based = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k=<span class="number">40</span>, rules=None, use_cache=False, standard=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param k: 取K个最近邻来进行预测</span></span><br><span class="line"><span class="string">        :param rules: 过滤规则，四选一，否则将抛异常："unhot", "rated", ["unhot","rated"], None</span></span><br><span class="line"><span class="string">        :param use_cache: 相似度计算结果是否开启缓存</span></span><br><span class="line"><span class="string">        :param standard: 评分标准化方法，None表示不使用、mean表示均值中心化、zscore表示Z-Score标准化</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.k = <span class="number">40</span></span><br><span class="line">        self.rules = rules</span><br><span class="line">        self.use_cache = use_cache</span><br><span class="line">        self.standard = standard</span><br></pre></td></tr></table></figure><p>修改所有的选取近邻的地方的代码，根据相似度来选取K个最近邻</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">similar_users = self.similar[uid].drop([uid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br><span class="line"></span><br><span class="line">similar_items = self.similar[iid].drop([iid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br></pre></td></tr></table></figure><p>  <strong>最终代码汇总</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">"../datasets/ml-latest-small/ratings.csv"</span></span><br><span class="line">CACHE_DIR = <span class="string">"../datasets/cache/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollaborativeFiltering</span><span class="params">(object)</span>:</span></span><br><span class="line">    based = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k=<span class="number">40</span>, rules=None, use_cache=False, standard=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param k: 取K个最近邻来进行预测</span></span><br><span class="line"><span class="string">        :param rules: 过滤规则，四选一，否则将抛异常："unhot", "rated", ["unhot","rated"], None</span></span><br><span class="line"><span class="string">        :param use_cache: 相似度计算结果是否开启缓存</span></span><br><span class="line"><span class="string">        :param standard: 评分标准化方法，None表示不使用、mean表示均值中心化、zscore表示Z-Score标准化</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.k = <span class="number">40</span></span><br><span class="line">        self.rules = rules</span><br><span class="line">        self.use_cache = use_cache</span><br><span class="line">        self.standard = standard</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self, data_path)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        加载数据</span></span><br><span class="line"><span class="string">        :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">        :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">        :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 数据集缓存地址</span></span><br><span class="line">        cache_path = os.path.join(CACHE_DIR, <span class="string">"ratings_matrix.cache"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"开始加载数据集..."</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(cache_path):  <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">            print(<span class="string">"加载缓存中..."</span>)</span><br><span class="line">            ratings_matrix = pd.read_pickle(cache_path)  <span class="comment"># 转换成pickle加快操作</span></span><br><span class="line">            print(<span class="string">"从缓存加载数据集完毕"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"加载新数据中..."</span>)</span><br><span class="line">            <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">            dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">            <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">            ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))  <span class="comment"># 读取前三列</span></span><br><span class="line">            <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">            ratings_matrix = ratings.pivot_table(index=[<span class="string">"userId"</span>], columns=[<span class="string">"movieId"</span>], values=<span class="string">"rating"</span>)</span><br><span class="line">            <span class="comment"># 存入缓存文件</span></span><br><span class="line">            ratings_matrix.to_pickle(cache_path)</span><br><span class="line">            print(<span class="string">"数据集加载完毕"</span>)</span><br><span class="line">        <span class="keyword">return</span> ratings_matrix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相似度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span><span class="params">(self, ratings_matrix, based=<span class="string">"user"</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        :param based: "user" or "item"</span></span><br><span class="line"><span class="string">        :return: 相似度矩阵</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"user_similarity.cache"</span>)</span><br><span class="line">        item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"item_similarity.cache"</span>)</span><br><span class="line">        <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">        <span class="comment"># 用户相似度</span></span><br><span class="line">        <span class="keyword">if</span> based == <span class="string">"user"</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">                print(<span class="string">"正从缓存加载用户相似度矩阵"</span>)</span><br><span class="line">                similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"开始计算用户相似度矩阵"</span>)</span><br><span class="line">                similarity = ratings_matrix.T.corr()</span><br><span class="line">                similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> based == <span class="string">"item"</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">                print(<span class="string">"正从缓存加载物品相似度矩阵"</span>)</span><br><span class="line">                similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"开始计算物品相似度矩阵"</span>)</span><br><span class="line">                similarity = ratings_matrix.corr()</span><br><span class="line">                similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unhandled 'based' Value: %s"</span> % based)</span><br><span class="line">        print(<span class="string">"相似度矩阵计算/加载完毕"</span>)</span><br><span class="line">        <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户指定商品的评分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">        :param uid: 用户ID</span></span><br><span class="line"><span class="string">        :param iid: 物品ID</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">        :return: 预测的评分值</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        print(<span class="string">"开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分..."</span> % (uid, iid))</span><br><span class="line">        <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">        similar_users = user_similar[uid].drop([uid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br><span class="line">        <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">        similar_users = similar_users.where(similar_users &gt; <span class="number">0</span>).dropna()</span><br><span class="line">        <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;没有相似的用户"</span> % uid)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">        <span class="comment"># (其中就是筛选出来的用户以下条件:1.是uid的近邻用户 2. 且这些用户对iid有评分)</span></span><br><span class="line">        ids = set(ratings_matrix[iid].dropna().index) &amp; set(similar_users.index)</span><br><span class="line">        finally_similar_users = similar_users.ix[list(ids)]  <span class="comment"># ids内是索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">        sum_up = <span class="number">0</span>  <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">        sum_down = <span class="number">0</span>  <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">        <span class="comment"># iteritems()与itemgetter()函数作用(https://www.cnblogs.com/SpringFull/p/10168533.html)</span></span><br><span class="line">        <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">            <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">            sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">            <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">            sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">            <span class="comment"># 计算分子的值</span></span><br><span class="line">            sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">            <span class="comment"># 计算分母的值</span></span><br><span class="line">            sum_down += similarity</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">        predict_rating = sum_up / sum_down</span><br><span class="line">        print(<span class="string">"预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f"</span> % (uid, iid, predict_rating))</span><br><span class="line">        <span class="keyword">return</span> round(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="comment"># def predict_all(uid, ratings_matrix, user_similar):</span></span><br><span class="line">    <span class="comment">#     '''</span></span><br><span class="line">    <span class="comment">#     预测全部评分</span></span><br><span class="line">    <span class="comment">#     :param uid: 用户id</span></span><br><span class="line">    <span class="comment">#     :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line">    <span class="comment">#     :param user_similar: 用户两两间的相似度</span></span><br><span class="line">    <span class="comment">#     :return: 生成器，逐个返回预测评分</span></span><br><span class="line">    <span class="comment">#     '''</span></span><br><span class="line">    <span class="comment">#     # 准备要预测的物品的id列表</span></span><br><span class="line">    <span class="comment">#     item_ids = ratings_matrix.columns</span></span><br><span class="line">    <span class="comment">#     # 逐个预测</span></span><br><span class="line">    <span class="comment">#     for iid in item_ids:</span></span><br><span class="line">    <span class="comment">#         try:</span></span><br><span class="line">    <span class="comment">#             rating = predict(uid, iid, ratings_matrix, user_similar)</span></span><br><span class="line">    <span class="comment">#         except Exception as e:</span></span><br><span class="line">    <span class="comment">#             print(e)</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             yield uid, iid, rating</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加过滤条件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span><span class="params">(self, uid, item_ids, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测全部评分</span></span><br><span class="line"><span class="string">        :param uid: 用户id</span></span><br><span class="line"><span class="string">        :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">        :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 逐个预测</span></span><br><span class="line">        <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                rating = self.predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(self, uid, ratings_matrix, user_similar, filter_rule=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">        :param uid: 用户ID</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">        :param filter_rule: 过滤规则，只能是四选一，否则将抛异常："unhot","rated",["unhot","rated"],None</span></span><br><span class="line"><span class="string">        :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">            item_ids = ratings_matrix.columns</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"unhot"</span>:</span><br><span class="line">            <span class="string">'''过滤非热门电影'''</span></span><br><span class="line">            <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">            count = ratings_matrix.count()</span><br><span class="line">            <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">            item_ids = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"rated"</span>:</span><br><span class="line">            <span class="string">'''过滤用户评分过的电影'''</span></span><br><span class="line">            <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">            user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">            <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">            _ = user_ratings &lt; <span class="number">6</span>  <span class="comment"># 这里的 _ 存的是判断结果(T/F)</span></span><br><span class="line">            item_ids = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, list) <span class="keyword">and</span> set(filter_rule) == set([<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">            <span class="string">'''过滤非热门和用户已经评分过的电影'''</span></span><br><span class="line">            count = ratings_matrix.count()</span><br><span class="line">            ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">            user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">            _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">            ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">            <span class="comment"># 取二者交集</span></span><br><span class="line">            item_ids = set(ids1) &amp; set(ids2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无效的过滤参数"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self._predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据预测评分为指定用户进行TOP-N推荐</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span><span class="params">(self, result, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(result, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    U_I = CollaborativeFiltering(k=<span class="number">5</span>, rules=<span class="string">'unhot'</span>, use_cache=<span class="literal">False</span>, standard=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 1.数据集加载</span></span><br><span class="line">    ratings_matrix = U_I.load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.相似度计算-皮尔逊相似系数</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># print(user_similar)</span></span><br><span class="line">    <span class="comment"># item_similar = compute_pearson_similarity(ratings_matrix, based="item")</span></span><br><span class="line">    <span class="comment"># print(item_similar)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 预测给定用户对给定物品的评分值</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># # 预测用户1对物品1的评分</span></span><br><span class="line">    <span class="comment"># predict(1, 1, ratings_matrix, user_similar)</span></span><br><span class="line">    <span class="comment"># # 预测用户1对物品2的评分</span></span><br><span class="line">    <span class="comment"># predict(1, 2, ratings_matrix, user_similar)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 预测全部评分</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># for i in predict_all(1, ratings_matrix, user_similar):</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 添加过滤规则后,预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># for result in predict_all(1, ratings_matrix, user_similar, filter_rule=["unhot", "rated"]):</span></span><br><span class="line">    <span class="comment">#     print(result)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6.根据预测评分为指定用户进行TOP-N推荐</span></span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">    user_similar = U_I.compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    result = U_I.predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>])</span><br><span class="line">    top_k = U_I.top_k_rs_result(result, <span class="number">20</span>)</span><br><span class="line">    pprint(top_k)</span><br></pre></td></tr></table></figure><p>但由于我们的原始数据较少，这里我们的KNN方法的效果会比纯粹的MemoryBasedCF要差</p><h2 id="基于回归模型的协同过滤推荐"><a href="#基于回归模型的协同过滤推荐" class="headerlink" title="基于回归模型的协同过滤推荐"></a>基于回归模型的协同过滤推荐</h2><p>如果我们将评分看作是一个连续的值而不是离散的值，那么就可以借助线性回归思想来预测目标用户对某物品的评分。其中一种实现策略被称为Baseline（基准预测）。</p><h4 id="Baseline：基准预测"><a href="#Baseline：基准预测" class="headerlink" title="Baseline：基准预测"></a>Baseline：基准预测</h4><p>Baseline设计思想基于以下的假设：</p><ul><li>有些用户的评分普遍高于其他用户，有些用户的评分普遍低于其他用户。比如有些用户天生愿意给别人好评，心慈手软，比较好说话，而有的人就比较苛刻，总是评分不超过3分（5分满分）</li><li>一些物品的评分普遍高于其他物品，一些物品的评分普遍低于其他物品。比如一些物品一被生产便决定了它的地位，有的比较受人们欢迎，有的则被人嫌弃。</li></ul><p>这个用户或物品普遍高于或低于平均值的差值，我们称为偏置(bias)</p><p><strong>Baseline目标：</strong></p><ul><li>找出每个用户普遍高于或低于他人的偏置值 $b_u$</li><li>找出每件物品普遍高于或低于其他物品的偏置值$b_i$</li><li>我们的目标也就转化为寻找最优的$b_u$和$b_i$</li></ul><p>使用Baseline的算法思想预测评分的步骤如下：</p><ul><li><p>计算所有电影的平均评分$\mu$（即全局平均评分）</p></li><li><p>计算每个用户评分与平均评分$\mu$的偏置值$b_u$</p></li><li><p>计算每部电影所接受的评分与平均评分$\mu$的偏置值$b_i$</p></li><li><p>预测用户对电影的评分：<br>$$<br>\hat{r}<em>{ui} = b</em>{ui} = \mu + b_u + b_i<br>$$</p></li></ul><p>举例：</p><p>​    比如我们想通过Baseline来预测用户A对电影“阿甘正传”的评分，那么首先计算出整个评分数据集的平均评分$\mu$是3.5分；而用户A是一个比较苛刻的用户，他的评分比较严格，普遍比平均评分低0.5分，即用户A的偏置值$b_i$是-0.5；而电影“阿甘正传”是一部比较热门而且备受好评的电影，它的评分普遍比平均评分要高1.2分，那么电影“阿甘正传”的偏置值$b_i$是+1.2，因此就可以预测出用户A对电影“阿甘正传”的评分为：$3.5+(-0.5)+1.2$，也就是4.2分。</p><p>对于所有电影的平均评分$\mu$是直接能计算出的，因此问题在于要测出每个用户的$b_u$值和每部电影的$b_i$的值。对于线性回归问题，我们可以利用平方差构建损失函数如下：<br>$$<br>\begin{split}<br>Cost &amp;= \sum_{u,i\in R}(r_{ui}-\hat{r}<em>{ui})^2<br>\&amp;=\sum</em>{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2<br>\end{split}<br>$$<br><img src="https://s1.ax1x.com/2020/03/22/84zHbj.png" alt="84zHbj.png"></p><p>加入L2正则化：<br>$$<br>Cost=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>公式解析：</p><ul><li>公式第一部分$ \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2$是用来寻找与已知评分数据拟合最好的$b_u$和$b_i$</li><li>公式第二部分$\lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)$是正则化项，用于避免过拟合现象</li></ul><p>对于最小过程的求解，我们一般采用<strong>随机梯度下降法</strong>或者<strong>交替最小二乘法</strong>来优化实现。</p><h4 id="方法一：随机梯度下降法优化"><a href="#方法一：随机梯度下降法优化" class="headerlink" title="方法一：随机梯度下降法优化"></a>方法一：随机梯度下降法优化</h4><p><a href="https://blog.csdn.net/qq_38150441/article/details/80533891" target="_blank" rel="noopener">梯度下降知识点补充</a></p><p>使用随机梯度下降优化算法预测Baseline偏置值</p><h6 id="step-1：梯度下降法推导-–-要推出来b-u和b-i的表达式"><a href="#step-1：梯度下降法推导-–-要推出来b-u和b-i的表达式" class="headerlink" title="step 1：梯度下降法推导 –(要推出来b_u和b_i的表达式)"></a>step 1：梯度下降法推导 –(要推出来b_u和b_i的表达式)</h6><p>损失函数：<br>$$<br>\begin{split}<br>&amp;J(\theta)=Cost=f(b_u, b_i)\<br>\<br>&amp;J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>\end{split}<br>$$<br>梯度下降参数更新原始公式：<br>$$<br>\theta_j:=\theta_j-\alpha\cfrac{\partial }{\partial \theta_j}J(\theta)<br>$$<br>(对$b_u$和$b_i$求偏导)</p><p>梯度下降更新$b_u$:</p><p>​    损失函数偏导推导：<br>$$<br>\begin{split}<br>\cfrac{\partial}{\partial b_u} J(\theta)&amp;=\cfrac{\partial}{\partial b_u} f(b_u, b_i)<br>\&amp;=2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)(-1) + 2\lambda{b_u}<br>\&amp;=-2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda<em>b_u<br>\end{split}<br>$$<br>​    $b_u$更新(因为alpha可以人为控制，所以2可以省略掉)：<br>$$<br>\begin{split}<br>b_u&amp;:=b_u - \alpha</em>(-\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + \lambda * b_u)\<br>&amp;:=b_u + \alpha<em>(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) - \lambda</em> b_u)<br>\end{split}<br>$$<br>同理可得，梯度下降更新$b_i$:<br>$$<br>b_i:=b_i + \alpha<em>(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) -\lambda</em>b_i)<br>$$</p><h6 id="step-2：随机梯度下降"><a href="#step-2：随机梯度下降" class="headerlink" title="step 2：随机梯度下降"></a>step 2：随机梯度下降</h6><p>由于<strong>随机梯度下降法</strong>本质上利用<strong>每个样本的损失</strong>来更新参数，而不用每次求出全部的损失和，因此使用SGD时：(随机梯度下降每次只考虑一个样本，所以不用上面的求和)</p><p>单样本损失值：<br>$$<br>\begin{split}<br>error &amp;=r_{ui}-\hat{r}<em>{ui}<br>\&amp;= r</em>{ui}-(\mu+b_u+b_i)<br>\&amp;= r_{ui}-\mu-b_u-b_i<br>\end{split}<br>$$<br>参数更新：<br>$$<br>\begin{split}<br>b_u&amp;:=b_u + \alpha<em>((r_{ui}-\mu-b_u-b_i) -\lambda*b_u)  \<br>&amp;:=b_u + \alpha</em>(error - \lambda<em>b_u) \<br>\<br>b_i&amp;:=b_i + \alpha</em>((r_{ui}-\mu-b_u-b_i) -\lambda<em>b_i)\<br>&amp;:=b_i + \alpha</em>(error -\lambda*b_i)<br>\end{split}<br>$$</p><h6 id="step-3：算法实现"><a href="#step-3：算法实现" class="headerlink" title="step 3：算法实现"></a>step 3：算法实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFBySGD</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, alpha, reg, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                <span class="comment"># for是为了把全部数据遍历一遍，上面的for保证了每个数据遍历20次</span></span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line"><span class="comment"># 这边的bu和bi都是每个用户每个商品都不一样，相当于每个数都计算了20次</span></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = int(input(<span class="string">"uid: "</span>))</span><br><span class="line">        iid = int(input(<span class="string">"iid: "</span>))</span><br><span class="line">        print(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure><h6 id="Step-4-准确性指标评估"><a href="#Step-4-准确性指标评估" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><ul><li>添加test方法，然后使用之前实现accuary方法计算准确性指标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_split</span><span class="params">(data_path, x=<span class="number">0.8</span>, random=False)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始切分数据集..."</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">"userId"</span>).any().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">"userId"</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = list(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    print(<span class="string">"完成数据集切分..."</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuray</span><span class="params">(predict_results, method=<span class="string">"all"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse_mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>), round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">"rmse"</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">"mae"</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFBySGD</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, alpha, reg, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line"></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="string">'''评分预测'''</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据"</span>.format(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    trainset, testset = data_split(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rmse: "</span>, rmse, <span class="string">"mae: "</span>, mae)</span><br></pre></td></tr></table></figure><h4 id="方法二：交替最小二乘法优化"><a href="#方法二：交替最小二乘法优化" class="headerlink" title="方法二：交替最小二乘法优化"></a>方法二：交替最小二乘法优化</h4><p>使用交替最小二乘法优化算法预测Baseline偏置值</p><h6 id="step-1-交替最小二乘法推导"><a href="#step-1-交替最小二乘法推导" class="headerlink" title="step 1: 交替最小二乘法推导"></a>step 1: 交替最小二乘法推导</h6><p>最小二乘法和梯度下降法一样，可以用于求极值。</p><p><strong>最小二乘法思想：对损失函数求偏导，然后再使偏导为0</strong></p><p>同样，损失函数：<br>$$<br>J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda<em>(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>对损失函数求偏导：<br>$$<br>\cfrac{\partial}{\partial b_u} f(b_u, b_i) =-2 \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda * b_u<br>$$<br>令偏导为0，则可得：<br>$$<br>\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) = \lambda</em> b_u<br>\\sum_{u,i\in R}(r_{ui}-\mu-b_i) = \sum_{u,i\in R} b_u+\lambda * b_u<br>$$<br>为了简化公式，这里令$\sum_{u,i\in R} b_u \approx |R(u)|*b_u$，即直接假设每一项的偏置都相等，可得：<br>$$<br>b_u := \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_i)}{\lambda_1 + |R(u)|}<br>$$<br>其中$|R(u)|$表示用户$u$的有过评分数量</p><p>同理可得：<br>$$<br>b_i := \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_u)}{\lambda_2 + |R(i)|}<br>$$<br>其中$|R(i)|$表示物品$i$收到的评分数量</p><p>$b_u$和$b_i$分别属于用户和物品的偏置，因此他们的正则参数可以分别设置两个独立的参数</p><h6 id="step-2-交替最小二乘法应用"><a href="#step-2-交替最小二乘法应用" class="headerlink" title="step 2: 交替最小二乘法应用"></a>step 2: 交替最小二乘法应用</h6><p>通过最小二乘推导，我们最终分别得到了$b_u$和$b_i$的表达式，但他们的表达式中却又各自包含对方，因此这里我们将利用一种叫交替最小二乘的方法来计算他们的值：    </p><ul><li>计算其中一项，先固定其他未知参数，即看作其他未知参数为已知</li><li>如求$b_u$时，将$b_i$看作是已知；求$b_i$时，将$b_u$看作是已知；如此反复交替，不断更新二者的值，求得最终的结果。这就是<strong>交替最小二乘法（ALS）</strong></li></ul><h6 id="step-3-算法实现"><a href="#step-3-算法实现" class="headerlink" title="step 3: 算法实现"></a>step 3: 算法实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFByALS</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">als</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> zip(uids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _sum / (self.reg_bi + len(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> zip(iids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _sum / (self.reg_bu + len(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = int(input(<span class="string">"uid: "</span>))</span><br><span class="line">        iid = int(input(<span class="string">"iid: "</span>))</span><br><span class="line">        print(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure><h6 id="Step-4-准确性指标评估-1"><a href="#Step-4-准确性指标评估-1" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_split</span><span class="params">(data_path, x=<span class="number">0.8</span>, random=False)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始切分数据集..."</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">"userId"</span>).any().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">"userId"</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = list(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    print(<span class="string">"完成数据集切分..."</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuray</span><span class="params">(predict_results, method=<span class="string">"all"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse_mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>), round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">"rmse"</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">"mae"</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFByALS</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">als</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> zip(uids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _sum / (self.reg_bi + len(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> zip(iids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _sum / (self.reg_bu + len(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="string">'''评分预测'''</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据"</span>.format(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    trainset, testset = data_split(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rmse: "</span>, rmse, <span class="string">"mae: "</span>, mae)</span><br></pre></td></tr></table></figure><h2 id="基于矩阵分解的CF算法"><a href="#基于矩阵分解的CF算法" class="headerlink" title="基于矩阵分解的CF算法"></a>基于矩阵分解的CF算法</h2><h4 id="矩阵分解发展史"><a href="#矩阵分解发展史" class="headerlink" title="矩阵分解发展史"></a>矩阵分解发展史</h4><p><strong>Traditional SVD:</strong></p><p>通常SVD矩阵分解指的是SVD（奇异值）分解技术，在这我们姑且将其命名为Traditional SVD（传统并经典着）其公式如下：</p><p><img src="https://s1.ax1x.com/2020/03/24/8qBJOS.jpg" alt="8qBJOS.jpg"></p><p>Traditional SVD分解的形式为3个矩阵相乘，中间矩阵为奇异值矩阵。如果想运用SVD分解的话，有一个前提是要求矩阵是稠密的，即矩阵里的元素要非空，否则就不能运用SVD分解。</p><p>很显然我们的数据其实绝大多数情况下都是稀疏的，因此如果要使用Traditional SVD，一般的做法是先用均值或者其他统计学方法来填充矩阵，然后再运用Traditional SVD分解降维，但这样做明显对数据的原始性造成一定影响。</p><p><strong>FunkSVD（LFM）</strong></p><p>刚才提到的Traditional SVD首先需要填充矩阵，然后再进行分解降维，同时存在计算复杂度高的问题，因为要分解成3个矩阵，所以后来提出了Funk SVD的方法，它不在将矩阵分解为3个矩阵，而是分解为2个用户-隐含特征，项目-隐含特征的矩阵，Funk SVD也被称为最原始的LFM模型</p><p><img src="https://s1.ax1x.com/2020/03/24/8qBwYn.jpg" alt="8qBwYn.jpg"></p><p>借鉴线性回归的思想，通过最小化观察数据的平方来寻求最优的用户和项目的隐含向量表示。同时为了避免过度拟合（Overfitting）观测数据，又提出了带有L2正则项的FunkSVD，上公式：</p><p><img src="https://s1.ax1x.com/2020/03/24/8qBrlV.jpg" alt="8qBrlV.jpg"></p><p>以上两种最优化函数都可以通过梯度下降或者随机梯度下降法来寻求最优解。</p><p><strong>BiasSVD:</strong></p><p>在FunkSVD提出来之后，出现了很多变形版本，其中一个相对成功的方法是BiasSVD，顾名思义，即带有偏置项的SVD分解：</p><p><img src="https://s1.ax1x.com/2020/03/24/8qBfYR.jpg" alt="8qBfYR.jpg"></p><p>它基于的假设和Baseline基准预测是一样的，但这里将Baseline的偏置引入到了矩阵分解中</p><p><strong>SVD++:</strong></p><p>人们后来又提出了改进的BiasSVD，被称为SVD++，该算法是在BiasSVD的基础上添加了用户的隐式反馈信息：</p><p><img src="https://s1.ax1x.com/2020/03/24/8qB5Sx.jpg" alt="8qB5Sx.jpg"></p><p>显示反馈指的用户的评分这样的行为，隐式反馈指用户的浏览记录、购买记录、收听记录等。</p><p>SVD++是基于这样的假设：在BiasSVD基础上，认为用户对于项目的历史浏览记录、购买记录、收听记录等可以从侧面反映用户的偏好。</p><h2 id="基于矩阵分解的CF算法实现（一）：LFM"><a href="#基于矩阵分解的CF算法实现（一）：LFM" class="headerlink" title="基于矩阵分解的CF算法实现（一）：LFM"></a>基于矩阵分解的CF算法实现（一）：LFM</h2><p>LFM也就是前面提到的Funk SVD矩阵分解</p><h4 id="LFM原理解析"><a href="#LFM原理解析" class="headerlink" title="LFM原理解析"></a>LFM原理解析</h4><p>LFM(latent factor model)隐语义模型核心思想是通过隐含特征联系用户和物品，如下图：</p><p><img src="https://s1.ax1x.com/2020/03/24/8qD5Nj.png" alt="8qD5Nj.png"><img src="/img/LFM%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E5%9B%BE%E8%A7%A3.png" alt></p><ul><li>P矩阵是User-LF矩阵，即用户和隐含特征矩阵。LF有三个，表示共总有三个隐含特征。</li><li>Q矩阵是LF-Item矩阵，即隐含特征和物品的矩阵</li><li>R矩阵是User-Item矩阵，有P*Q得来</li><li><strong>能处理稀疏评分矩阵</strong></li></ul><p>利用矩阵分解技术，将原始User-Item的评分矩阵（稠密/稀疏）分解为P和Q矩阵，然后利用$P*Q$还原出User-Item评分矩阵$R$。整个过程相当于降维处理，其中：</p><ul><li><p>矩阵值$P_{11}$表示用户1对隐含特征1的权重值</p></li><li><p>矩阵值$Q_{11}$表示隐含特征1在物品1上的权重值</p></li><li><p>矩阵值$R_{11}$就表示预测的用户1对物品1的评分，且$R_{11}=\vec{P_{1,k}}\cdot \vec{Q_{k,1}}$</p><p><img src="https://s1.ax1x.com/2020/03/24/8qDWDS.png" alt="8qDWDS.png"></p></li></ul><p>利用LFM预测用户对物品的评分，$k$表示隐含特征数量：<br>$$<br>\begin{split}<br>\hat {r}<em>{ui} &amp;=\vec {p</em>{uk}}\cdot \vec {q_{ik}}<br>\&amp;={\sum_{k=1}}^k p_{uk}q_{ik}<br>\end{split}<br>$$<br>因此最终，我们的目标也就是要求出P矩阵和Q矩阵及其当中的每一个值，然后再对用户-物品的评分进行预测。</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>同样对于评分预测我们利用平方差来构建损失函数：<br>$$<br>\begin{split}<br>Cost &amp;= \sum_{u,i\in R} (r_{ui}-\hat{r}<em>{ui})^2<br>\&amp;=\sum</em>{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2<br>\end{split}<br>$$<br>加入L2正则化：<br>$$<br>Cost = \sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)<br>$$<br>对损失函数求偏导：<br>$$<br>\begin{split}<br>\cfrac {\partial}{\partial p_{uk}}Cost &amp;= \cfrac {\partial}{\partial p_{uk}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]<br>\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}<br>\\<br>\cfrac {\partial}{\partial q_{ik}}Cost &amp;= \cfrac {\partial}{\partial q_{ik}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]<br>\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-p_{uk}) + 2\lambda q_{ik}<br>\end{split}<br>$$</p><h4 id="随机梯度下降法优化"><a href="#随机梯度下降法优化" class="headerlink" title="随机梯度下降法优化"></a>随机梯度下降法优化</h4><p>梯度下降更新参数$p_{uk}$：<br>$$<br>\begin{split}<br>p_{uk}&amp;:=p_{uk} - \alpha\cfrac {\partial}{\partial p_{uk}}Cost<br>\&amp;:=p_{uk}-\alpha [2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}]<br>\&amp;:=p_{uk}+\alpha [\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda p_{uk}]<br>\end{split}<br>$$<br> 同理：<br>$$<br>\begin{split}<br>q_{ik}&amp;:=q_{ik} + \alpha[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda q_{ik}]<br>\end{split}<br>$$<br><strong>随机梯度下降：</strong> 向量乘法 每一个分量相乘 求和<br>$$<br>\begin{split}<br>&amp;p_{uk}:=p_{uk}+\alpha [(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda_1 p_{uk}]<br>\&amp;q_{ik}:=q_{ik} + \alpha[(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda_2 q_{ik}]<br>\end{split}<br>$$<br>由于P矩阵和Q矩阵是两个不同的矩阵，通常分别采取不同的正则参数，如$\lambda_1$和$\lambda_2$</p><p><strong>算法实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">LFM Model</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评分预测    1-5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFM</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, reg_p, reg_q, number_LatentFactors=<span class="number">10</span>, number_epochs=<span class="number">10</span>, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        self.alpha = alpha <span class="comment"># 学习率</span></span><br><span class="line">        self.reg_p = reg_p    <span class="comment"># P矩阵正则</span></span><br><span class="line">        self.reg_q = reg_q    <span class="comment"># Q矩阵正则</span></span><br><span class="line">        self.number_LatentFactors = number_LatentFactors  <span class="comment"># 隐式类别数量</span></span><br><span class="line">        self.number_epochs = number_epochs    <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        fit dataset</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        self.dataset = pd.DataFrame(dataset)</span><br><span class="line"></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line"></span><br><span class="line">        self.globalMean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line"></span><br><span class="line">        self.P, self.Q = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_matrix</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        初始化P和Q矩阵，同时为设置0，1之间的随机值作为初始值--防止×完全是0</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># User-LF</span></span><br><span class="line">        <span class="comment"># random.rand(x)取值范围是 [0,1)</span></span><br><span class="line">        P = dict(zip(</span><br><span class="line">            self.users_ratings.index,</span><br><span class="line">            np.random.rand(len(self.users_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="comment"># Item-LF</span></span><br><span class="line">        Q = dict(zip(</span><br><span class="line">            self.items_ratings.index,</span><br><span class="line">            np.random.rand(len(self.items_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        使用随机梯度下降，优化结果</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        P, Q = self._init_matrix()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span>%i)</span><br><span class="line">            error_list = []</span><br><span class="line">            <span class="keyword">for</span> uid, iid, r_ui <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                <span class="comment"># User-LF P</span></span><br><span class="line">                <span class="comment">## Item-LF Q</span></span><br><span class="line">                v_pu = P[uid] <span class="comment">#用户向量！！这是一个向量，PQ是矩阵</span></span><br><span class="line">                v_qi = Q[iid] <span class="comment">#物品向量</span></span><br><span class="line">                err = np.float32(r_ui - np.dot(v_pu, v_qi))</span><br><span class="line"></span><br><span class="line">                v_pu += self.alpha * (err * v_qi - self.reg_p * v_pu)</span><br><span class="line">                v_qi += self.alpha * (err * v_pu - self.reg_q * v_qi)</span><br><span class="line">                </span><br><span class="line">                P[uid] = v_pu </span><br><span class="line">                Q[iid] = v_qi</span><br><span class="line"><span class="comment"># 或者不从向量的角度考虑</span></span><br><span class="line">                <span class="comment"># for k in range(self.number_of_LatentFactors):</span></span><br><span class="line">                <span class="comment">#     v_pu[k] += self.alpha*(err*v_qi[k] - self.reg_p*v_pu[k])</span></span><br><span class="line">                <span class="comment">#     v_qi[k] += self.alpha*(err*v_pu[k] - self.reg_q*v_qi[k])</span></span><br><span class="line"></span><br><span class="line">                error_list.append(err ** <span class="number">2</span>)</span><br><span class="line">            print(np.sqrt(np.mean(error_list)))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="comment"># 如果uid或iid不在，我们使用全剧平均分作为预测结果返回</span></span><br><span class="line">        <span class="keyword">if</span> uid <span class="keyword">not</span> <span class="keyword">in</span> self.users_ratings.index <span class="keyword">or</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">return</span> self.globalMean</span><br><span class="line"></span><br><span class="line">        p_u = self.P[uid]</span><br><span class="line">        q_i = self.Q[iid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.dot(p_u, q_i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    lfm = LFM(<span class="number">0.02</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">10</span>, <span class="number">100</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    lfm.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = input(<span class="string">"uid: "</span>)</span><br><span class="line">        iid = input(<span class="string">"iid: "</span>)</span><br><span class="line">        print(lfm.predict(int(uid), int(iid)))</span><br></pre></td></tr></table></figure><h2 id="基于内容的推荐算法（Content-Based）"><a href="#基于内容的推荐算法（Content-Based）" class="headerlink" title="基于内容的推荐算法（Content-Based）"></a>基于内容的推荐算法（Content-Based）</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>基于内容的推荐方法是非常直接的，它以物品的内容描述信息为依据来做出的推荐，本质上是基于对物品和用户自身的特征或属性的直接分析和计算。</p><p>例如，假设已知电影A是一部喜剧，而恰巧我们得知某个用户喜欢看喜剧电影，那么我们基于这样的已知信息，就可以将电影A推荐给该用户。</p><h4 id="基于内容的推荐实现步骤"><a href="#基于内容的推荐实现步骤" class="headerlink" title="基于内容的推荐实现步骤"></a>基于内容的推荐实现步骤</h4><ul><li><p><strong>画像构建</strong>。顾名思义，画像就是刻画物品或用户的特征。本质上就是给用户或物品贴标签。</p><ul><li><p><strong>物品画像</strong>：例如给电影《战狼2》贴标签，可以有哪些？</p><p><img src="https://s1.ax1x.com/2020/03/24/8q4NvQ.png" alt="8q4NvQ.png"></p><p>“动作”、”吴京”、”吴刚”、”张翰”、”大陆电影”、”国产”、”爱国”、”军事”等等一系列标签是不是都可以贴上</p></li><li><p><strong>用户画像</strong>：例如已知用户的观影历史是：”《战狼1》”、”《战狼2》”、”《建党伟业》”、”《建军大业》”、”《建国大业》”、”《红海行动》”、”《速度与激情1-8》”等，我们是不是就可以分析出该用户的一些兴趣特征如：”爱国”、”战争”、”赛车”、”动作”、”军事”、”吴京”、”韩三平”等标签。</p></li></ul></li></ul><h6 id="问题：物品的标签来自哪儿？"><a href="#问题：物品的标签来自哪儿？" class="headerlink" title="问题：物品的标签来自哪儿？"></a>问题：物品的标签来自哪儿？</h6><ol><li>PGC    物品画像–冷启动<ul><li>物品自带的属性（物品一产生就具备的）：如电影的标题、导演、演员、类型等等</li><li>服务提供方设定的属性（服务提供方为物品附加的属性）：如短视频话题、微博话题（平台拟定）</li><li>其他渠道：如爬虫</li></ul></li><li>UGC    冷启动问题<ul><li>用户在享受服务过程中提供的物品的属性：如用户评论内容，微博话题（用户拟定）</li></ul></li></ol><p>根据PGC内容构建的物品画像的可以解决物品的冷启动问题</p><h6 id="基于内容推荐的算法流程："><a href="#基于内容推荐的算法流程：" class="headerlink" title="基于内容推荐的算法流程："></a>基于内容推荐的算法流程：</h6><ul><li>根据PGC/UGC内容构建物品画像</li><li>根据用户行为记录生成用户画像</li><li>根据用户画像从物品中寻找最匹配的TOP-N物品进行推荐</li></ul><h6 id="物品冷启动处理："><a href="#物品冷启动处理：" class="headerlink" title="物品冷启动处理："></a>物品冷启动处理：</h6><ul><li>根据PGC内容构建物品画像</li><li>利用物品画像计算物品间两两相似情况</li><li>为每个物品产生TOP-N最相似的物品进行相关推荐：如与该商品相似的商品有哪些？与该文章相似文章有哪些？</li></ul><h2 id="基于内容的电影推荐：物品画像"><a href="#基于内容的电影推荐：物品画像" class="headerlink" title="基于内容的电影推荐：物品画像"></a>基于内容的电影推荐：物品画像</h2><p>物品画像构建步骤：</p><ul><li>利用tags.csv中每部电影的标签作为电影的候选关键词</li><li>利用TF·IDF计算每部电影的标签的tfidf值，选取TOP-N个关键词作为电影画像标签</li><li>将电影的分类词直接作为每部电影的画像标签</li></ul><h2 id="基于TF-IDF的特征提取技术-算一下关键程度"><a href="#基于TF-IDF的特征提取技术-算一下关键程度" class="headerlink" title="基于TF-IDF的特征提取技术(算一下关键程度)"></a>基于TF-IDF的特征提取技术(算一下关键程度)</h2><p>前面提到，物品画像的特征标签主要都是指的如电影的导演、演员、图书的作者、出版社等结构话的数据，也就是他们的特征提取，尤其是体征向量的计算是比较简单的，如直接给作品的分类定义0或者1的状态。</p><p>但另外一些特征，比如电影的内容简介、电影的影评、图书的摘要等文本数据，这些被称为非结构化数据，首先他们本应该也属于物品的一个特征标签，但是这样的特征标签进行量化时，也就是计算它的特征向量时是很难去定义的。</p><p>因此这时就需要借助一些自然语言处理、信息检索等技术，将如用户的文本评论或其他文本内容信息的非结构化数据进行量化处理，从而实现更加完善的物品画像/用户画像。</p><p>TF-IDF算法便是其中一种在自然语言处理领域中应用比较广泛的一种算法。可用来提取目标文档中，并得到关键词用于计算对于目标文档的权重，并将这些权重组合到一起得到特征向量。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>TF-IDF自然语言处理领域中计算文档中词或短语的权值的方法，是<strong>词频</strong>（Term Frequency，TF）和逆转文档频率（Inverse Document Frequency，IDF）的乘积。TF指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被正规化，以防止它偏向长的文件（同一个词语在长文件里可能会比短文件有更高的词频，而不管该词语重要与否）。IDF是一个词语普遍重要性的度量，某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到。</p><p>TF-IDF算法基于一个这样的假设：若一个词语在目标文档中出现的频率高而在其他文档中出现的频率低，那么这个词语就可以用来区分出目标文档。这个假设需要掌握的有两点：</p><ul><li>在本文档出现的频率高；</li><li>在其他文档出现的频率低。</li></ul><p>因此，TF-IDF算法的计算可以分为词频（Term Frequency，TF）和逆转文档频率（Inverse Document Frequency，IDF）两部分，由TF和IDF的乘积来设置文档词语的权重。</p><p>TF指的是一个词语在文档中的出现频率。假设文档集包含的文档数为$$N$$，文档集中包含关键词$$k_i$$的文档数为$$n_i$$，$$f_{ij}$$表示关键词$$k_i$$在文档$$d_j$$中出现的次数，$$f_{dj}$$表示文档$$d_j$$中出现的词语总数，$$k_i$$在文档dj中的词频$$TF_{ij}$$定义为：$$TF_{ij}=\frac {f_{ij}}{f_{dj}}$$。并且注意，这个数字通常会被正规化，以防止它偏向长的文件（指同一个词语在长文件里可能会比短文件有更高的词频，而不管该词语重要与否）。</p><p>IDF是一个词语普遍重要性的度量。表示某一词语在整个文档集中出现的频率，由它计算的结果取对数得到关键词$$k_i$$的逆文档频率$$IDF_i$$：$$IDF_i=log\frac {N}{n_i}$$</p><p>由TF和IDF计算词语的权重为：$$w_{ij}=TF_{ij}$$<strong>·</strong>$$IDF_{i}=\frac {f_{ij}}{f_{dj}}$$<strong>·</strong>$$log\frac {N}{n_i}$$</p><p><strong>结论：TF-IDF与词语在文档中的出现次数成正比，与该词在整个文档集中的出现次数成反比。</strong></p><p><strong>用途：在目标文档中，提取关键词(特征标签)的方法就是将该文档所有词语的TF-IDF计算出来并进行对比，取其中TF-IDF值最大的k个数组成目标文档的特征向量用以表示文档。</strong></p><p>注意：文档中存在的停用词（Stop Words），如“是”、“的”之类的，对于文档的中心思想表达没有意义的词，在分词时需要先过滤掉再计算其他词语的TF-IDF值。</p><h4 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h4><p>对于计算影评的TF-IDF，以电影“加勒比海盗：黑珍珠号的诅咒”为例，假设它总共有1000篇影评，其中一篇影评的总词语数为200，其中出现最频繁的词语为“海盗”、“船长”、“自由”，分别是20、15、10次，并且这3个词在所有影评中被提及的次数分别为1000、500、100，就这3个词语作为关键词的顺序计算如下。</p><ol><li><p>将影评中出现的停用词过滤掉，计算其他词语的词频。以出现最多的三个词为例进行计算如下：</p><ul><li>“海盗”出现的词频为20/200＝0.1</li><li>“船长”出现的词频为15/200=0.075</li><li>“自由”出现的词频为10/200=0.05；</li></ul></li><li><p>计算词语的逆文档频率如下：</p><ul><li>“海盗”的IDF为：log(1000/1000)=0</li><li>“船长”的IDF为：log(1000/500)=0.3<br>“自由”的IDF为：log(1000/100)=1</li></ul></li><li><p>由1和2计算的结果求出词语的TF-IDF结果，“海盗”为0，“船长”为0.0225，“自由”为0.05。</p></li></ol><p>通过对比可得，该篇影评的关键词排序应为：“自由”、“船长”、“海盗”。把这些词语的TF-IDF值作为它们的权重按照对应的顺序依次排列，就得到这篇影评的特征向量，我们就用这个向量来代表这篇影评，向量中每一个维度的分量大小对应这个属性的重要性。</p><p>将总的影评集中所有的影评向量与特定的系数相乘求和，得到这部电影的综合影评向量，与电影的基本属性结合构建视频的物品画像，同理构建用户画像，可采用多种方法计算物品画像和用户画像之间的相似度，为用户做出推荐。</p><h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">- 利用tags.csv中每部电影的标签作为电影的候选关键词</span></span><br><span class="line"><span class="string">- 利用TF·IDF计算每部电影的标签的tfidf值，选取TOP-N个关键词作为电影画像标签</span></span><br><span class="line"><span class="string">- 并将电影的分类词直接作为每部电影的画像标签</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_movie_dataset</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 加载基于所有电影的标签</span></span><br><span class="line">    <span class="comment"># all-tags.csv来自ml-latest数据集中</span></span><br><span class="line">    <span class="comment"># 由于ml-latest-small中标签数据太多，因此借助其来扩充</span></span><br><span class="line">    _tags = pd.read_csv(<span class="string">"datasets/ml-latest-small/all-tags.csv"</span>, usecols=range(<span class="number">1</span>, <span class="number">3</span>)).dropna()</span><br><span class="line">    tags = _tags.groupby(<span class="string">"movieId"</span>).agg(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载电影列表数据集</span></span><br><span class="line">    movies = pd.read_csv(<span class="string">"datasets/ml-latest-small/movies.csv"</span>, index_col=<span class="string">"movieId"</span>)</span><br><span class="line">    <span class="comment"># 将类别词分开</span></span><br><span class="line">    movies[<span class="string">"genres"</span>] = movies[<span class="string">"genres"</span>].apply(<span class="keyword">lambda</span> x: x.split(<span class="string">"|"</span>))</span><br><span class="line">    <span class="comment"># 为每部电影匹配对应的标签数据，如果没有将会是NAN</span></span><br><span class="line">    movies_index = set(movies.index) &amp; set(tags.index)</span><br><span class="line">    new_tags = tags.loc[list(movies_index)]</span><br><span class="line">    ret = movies.join(new_tags)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建电影数据集，包含电影Id、电影名称、类别、标签四个字段</span></span><br><span class="line">    <span class="comment"># 如果电影没有标签数据，那么就替换为空列表</span></span><br><span class="line">    <span class="comment"># map(fun,可迭代对象)</span></span><br><span class="line">    movie_dataset = pd.DataFrame(</span><br><span class="line">        map(</span><br><span class="line">            <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>], x[<span class="number">2</span>]+x[<span class="number">3</span>]) <span class="keyword">if</span> x[<span class="number">3</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan <span class="keyword">else</span> (x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>], []), ret.itertuples())</span><br><span class="line">        , columns=[<span class="string">"movieId"</span>, <span class="string">"title"</span>, <span class="string">"genres"</span>,<span class="string">"tags"</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    movie_dataset.set_index(<span class="string">"movieId"</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> movie_dataset</span><br><span class="line"></span><br><span class="line">movie_dataset = get_movie_dataset()</span><br><span class="line">print(movie_dataset)</span><br></pre></td></tr></table></figure><h4 id="基于TF·IDF提取TOP-N关键词，构建电影画像"><a href="#基于TF·IDF提取TOP-N关键词，构建电影画像" class="headerlink" title="基于TF·IDF提取TOP-N关键词，构建电影画像"></a>基于TF·IDF提取TOP-N关键词，构建电影画像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> TfidfModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_movie_profile</span><span class="params">(movie_dataset)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    使用tfidf，分析提取topn关键词</span></span><br><span class="line"><span class="string">    :param movie_dataset: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    dataset = movie_dataset[<span class="string">"tags"</span>].values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> Dictionary</span><br><span class="line">    <span class="comment"># 根据数据集建立词袋，并统计词频，将所有词放入一个词典，使用索引进行获取</span></span><br><span class="line">    dct = Dictionary(dataset)</span><br><span class="line">    <span class="comment"># 根据将每条数据，返回对应的词索引和词频</span></span><br><span class="line">    corpus = [dct.doc2bow(line) <span class="keyword">for</span> line <span class="keyword">in</span> dataset]</span><br><span class="line">    <span class="comment"># 训练TF-IDF模型，即计算TF-IDF值</span></span><br><span class="line">    model = TfidfModel(corpus)</span><br><span class="line"></span><br><span class="line">    movie_profile = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, mid <span class="keyword">in</span> enumerate(movie_dataset.index):</span><br><span class="line">        <span class="comment"># 根据每条数据返回，向量</span></span><br><span class="line">        vector = model[corpus[i]]</span><br><span class="line">        <span class="comment"># 按照TF-IDF值得到top-n的关键词</span></span><br><span class="line">        movie_tags = sorted(vector, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">30</span>]</span><br><span class="line">        <span class="comment"># 根据关键词提取对应的名称--dct[x[0]]是找 在movie_tags中的索引</span></span><br><span class="line">        movie_profile[mid] = dict(map(<span class="keyword">lambda</span> x:(dct[x[<span class="number">0</span>]], x[<span class="number">1</span>]), movie_tags))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> movie_profile</span><br><span class="line"></span><br><span class="line">movie_dataset = get_movie_dataset()</span><br><span class="line">pprint(create_movie_profile(movie_dataset))</span><br></pre></td></tr></table></figure><h4 id="完善画像关键词"><a href="#完善画像关键词" class="headerlink" title="完善画像关键词"></a>完善画像关键词</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> TfidfModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_movie_profile</span><span class="params">(movie_dataset)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    使用tfidf，分析提取topn关键词</span></span><br><span class="line"><span class="string">    :param movie_dataset:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    dataset = movie_dataset[<span class="string">"tags"</span>].values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> Dictionary</span><br><span class="line">    <span class="comment"># 根据数据集建立词袋，并统计词频，将所有词放入一个词典，使用索引进行获取</span></span><br><span class="line">    dct = Dictionary(dataset)</span><br><span class="line">    <span class="comment"># 根据将每条数据，返回对应的词索引和词频</span></span><br><span class="line">    corpus = [dct.doc2bow(line) <span class="keyword">for</span> line <span class="keyword">in</span> dataset]</span><br><span class="line">    <span class="comment"># 训练TF-IDF模型，即计算TF-IDF值</span></span><br><span class="line">    model = TfidfModel(corpus)</span><br><span class="line"></span><br><span class="line">    _movie_profile = []</span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(movie_dataset.itertuples()):</span><br><span class="line">        mid = data[<span class="number">0</span>]</span><br><span class="line">        title = data[<span class="number">1</span>]</span><br><span class="line">        genres = data[<span class="number">2</span>]</span><br><span class="line">        vector = model[corpus[i]]</span><br><span class="line">        movie_tags = sorted(vector, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">30</span>]</span><br><span class="line">        topN_tags_weights = dict(map(<span class="keyword">lambda</span> x: (dct[x[<span class="number">0</span>]], x[<span class="number">1</span>]), movie_tags))</span><br><span class="line">        <span class="comment"># 将类别词的添加进去，并设置权重值为1.0</span></span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> genres:</span><br><span class="line">            topN_tags_weights[g] = <span class="number">1.0</span></span><br><span class="line">        topN_tags = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> topN_tags_weights.items()]</span><br><span class="line">        _movie_profile.append((mid, title, topN_tags, topN_tags_weights))</span><br><span class="line"></span><br><span class="line">    movie_profile = pd.DataFrame(_movie_profile, columns=[<span class="string">"movieId"</span>, <span class="string">"title"</span>, <span class="string">"profile"</span>, <span class="string">"weights"</span>])</span><br><span class="line">    movie_profile.set_index(<span class="string">"movieId"</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> movie_profile</span><br><span class="line"></span><br><span class="line">movie_dataset = get_movie_dataset()</span><br><span class="line">pprint(create_movie_profile(movie_dataset))</span><br></pre></td></tr></table></figure><p>为了根据指定关键词迅速匹配到对应的电影，因此需要对物品画像的标签词，建立<strong>倒排索引</strong></p><p><strong>倒排索引介绍</strong></p><p>通常数据存储数据，都是以物品的ID作为索引，去提取物品的其他信息数据</p><p>而倒排索引就是用物品的其他数据作为索引，去提取它们对应的物品的ID列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">建立tag-物品的倒排索引</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_inverted_table</span><span class="params">(movie_profile)</span>:</span></span><br><span class="line">    inverted_table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> mid, weights <span class="keyword">in</span> movie_profile[<span class="string">"weights"</span>].iteritems():</span><br><span class="line">        <span class="keyword">for</span> tag, weight <span class="keyword">in</span> weights.items():</span><br><span class="line">            <span class="comment">#到inverted_table dict 用tag作为Key去取值 如果取不到就返回[]</span></span><br><span class="line">            _ = inverted_table.get(tag, [])</span><br><span class="line">            _.append((mid, weight))</span><br><span class="line">            inverted_table.setdefault(tag, _)</span><br><span class="line">    <span class="keyword">return</span> inverted_table</span><br><span class="line"></span><br><span class="line">inverted_table = create_inverted_table(movie_profile)</span><br><span class="line">pprint(inverted_table)</span><br></pre></td></tr></table></figure><h2 id="基于内容的电影推荐：用户画像"><a href="#基于内容的电影推荐：用户画像" class="headerlink" title="基于内容的电影推荐：用户画像"></a>基于内容的电影推荐：用户画像</h2><p>用户画像构建步骤：</p><ul><li>根据用户的评分历史，结合物品画像，将有观影记录的电影的画像标签作为初始标签反打到用户身上</li><li>通过对用户观影标签的次数进行统计，计算用户的每个初始标签的权重值，排序后选取TOP-N作为用户最终的画像标签</li></ul><h4 id="用户画像建立"><a href="#用户画像建立" class="headerlink" title="用户画像建立"></a>用户画像建立</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> TfidfModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">user profile画像建立：</span></span><br><span class="line"><span class="string">1. 提取用户观看列表</span></span><br><span class="line"><span class="string">2. 根据观看列表和物品画像为用户匹配关键词，并统计词频</span></span><br><span class="line"><span class="string">3. 根据词频排序，最多保留TOP-k个词，这里K设为100，作为用户的标签</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_profile</span><span class="params">()</span>:</span></span><br><span class="line">    watch_record = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">2</span>), dtype=&#123;<span class="string">"userId"</span>:np.int32, <span class="string">"movieId"</span>: np.int32&#125;)</span><br><span class="line"></span><br><span class="line">    watch_record = watch_record.groupby(<span class="string">"userId"</span>).agg(list)</span><br><span class="line">    <span class="comment"># print(watch_record)</span></span><br><span class="line"></span><br><span class="line">    movie_dataset = get_movie_dataset()</span><br><span class="line">    movie_profile = create_movie_profile(movie_dataset)</span><br><span class="line"></span><br><span class="line">    user_profile = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> uid, mids <span class="keyword">in</span> watch_record.itertuples():</span><br><span class="line">        record_movie_prifole = movie_profile.loc[list(mids)]</span><br><span class="line">        counter = collections.Counter(reduce(<span class="keyword">lambda</span> x, y: list(x)+list(y), record_movie_prifole[<span class="string">"profile"</span>].values))</span><br><span class="line">        <span class="comment"># 兴趣词</span></span><br><span class="line">        interest_words = counter.most_common(<span class="number">50</span>)</span><br><span class="line">        maxcount = interest_words[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        interest_words = [(w,round(c/maxcount, <span class="number">4</span>)) <span class="keyword">for</span> w,c <span class="keyword">in</span> interest_words]</span><br><span class="line">        user_profile[uid] = interest_words</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_profile</span><br><span class="line"></span><br><span class="line">user_profile = create_user_profile()</span><br><span class="line">pprint(user_profile)</span><br></pre></td></tr></table></figure><h2 id="基于内容的电影推荐：为用户产生TOP-N推荐结果"><a href="#基于内容的电影推荐：为用户产生TOP-N推荐结果" class="headerlink" title="基于内容的电影推荐：为用户产生TOP-N推荐结果"></a>基于内容的电影推荐：为用户产生TOP-N推荐结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line">user_profile = create_user_profile()</span><br><span class="line"></span><br><span class="line">watch_record = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">2</span>),dtype=&#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32&#125;)</span><br><span class="line"></span><br><span class="line">watch_record = watch_record.groupby(<span class="string">"userId"</span>).agg(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> uid, interest_words <span class="keyword">in</span> user_profile.items():</span><br><span class="line">    result_table = &#123;&#125; <span class="comment"># 电影id:[0.2,0.5,0.7]</span></span><br><span class="line">    <span class="keyword">for</span> interest_word, interest_weight <span class="keyword">in</span> interest_words:</span><br><span class="line">        related_movies = inverted_table[interest_word]</span><br><span class="line">        <span class="keyword">for</span> mid, related_weight <span class="keyword">in</span> related_movies:</span><br><span class="line">            </span><br><span class="line">            _ = result_table.get(mid, [])</span><br><span class="line">            _.append(interest_weight)    <span class="comment"># 只考虑用户的兴趣程度</span></span><br><span class="line">            <span class="comment"># _.append(related_weight)    # 只考虑兴趣词与电影的关联程度</span></span><br><span class="line">            <span class="comment"># _.append(interest_weight*related_weight)    # 二者都考虑</span></span><br><span class="line">            result_table.setdefault(mid, _)</span><br><span class="line"><span class="comment"># 为什么要加起来是因为一个电影有多个标签</span></span><br><span class="line">    rs_result = map(<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], sum(x[<span class="number">1</span>])), result_table.items())</span><br><span class="line">    rs_result = sorted(rs_result, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:<span class="number">100</span>]</span><br><span class="line">    print(uid)</span><br><span class="line">    pprint(rs_result)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 历史数据  ==&gt;  历史兴趣程度 ==&gt;  历史推荐结果       离线推荐    离线计算</span></span><br><span class="line">    <span class="comment"># 在线推荐 ===&gt;    娱乐(王思聪)   ===&gt;   我 ==&gt;  王思聪 100%  </span></span><br><span class="line">    <span class="comment"># 近线：最近1天、3天、7天           实时计算</span></span><br></pre></td></tr></table></figure><h3 id="基于内容推荐流程总结"><a href="#基于内容推荐流程总结" class="headerlink" title="基于内容推荐流程总结"></a>基于内容推荐流程总结</h3><p>① 建立物品画像</p><ul><li>来源：①用户打tag ②电影的分类值</li><li>根据电影的id 把tag和分类值合并起来 求tf-idf</li><li>根据tf-idf的结果 为每一部电影筛选出 top-n（tf-idf比较大的）个关键词</li><li>电影id-关键词(<code>[&quot;profile&quot;]</code>)-关键词权重(<code>[&quot;weigts&quot;]</code>)</li></ul><p>② 建立倒排索引</p><ul><li>通过关键词找到电影</li><li>遍历 电影id-关键词-关键词权重 数据， 读取每一个关键词，用关键词作为key [(关键词对应的电影id和tf-idf)] 作为value 保存到dict当中</li></ul><p>③ 用户画像</p><ul><li>看用户看过那些电影， 到电影的 电影id-关键词-关键词权重 数据中 找到电影所对应的关键词  </li><li>把用户看过的所有的关键词放到一起 统计词频 每个词出现了几次</li><li>出现次数多的关键词 作为用户的兴趣词，这个兴趣词实际上就是用户画像的关键词</li></ul><p>④ 根据用户的兴趣词 找到兴趣词对应的电影 多个兴趣词可能对应一个电影 {电影id：[关键词1权重，关键词2权重]}</p><ul><li>把每一个部电影对应的关键词权重求和之后 排序  权重比较高的排在前面 推荐给用户</li></ul><hr><h1 id="介绍一下各种命令"><a href="#介绍一下各种命令" class="headerlink" title="介绍一下各种命令"></a>介绍一下各种命令</h1><h2 id="hadoop-hdfs"><a href="#hadoop-hdfs" class="headerlink" title="hadoop/hdfs"></a>hadoop/hdfs</h2><h3 id="HDFS-shell操作"><a href="#HDFS-shell操作" class="headerlink" title="HDFS shell操作"></a>HDFS shell操作</h3><ul><li><p>调用文件系统(FS)Shell命令应使用 bin/hadoop fs <args>的形式</args></p><ul><li><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>使用方法：hadoop fs -ls <args></args></p><p>如果是文件，则按照如下格式返回文件信息：<br>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：<br>目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID<br>示例：<br>hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile<br>返回值：<br>成功返回0，失败返回-1。 </dir></p></li><li><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>使用方法：hadoop fs -text <src> </src></p><p>将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。</p></li><li><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用方法：hadoop fs -mv URI [URI …] <dest></dest></p><p>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。<br>示例：</p><ul><li>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</li><li>hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>使用方法：hadoop fs -put <localsrc> … <dst></dst></localsrc></p><p>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。</p><ul><li>hadoop fs -put localfile /user/hadoop/hadoopfile</li><li>hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir</li><li>hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile</li><li>hadoop fs -put - hdfs://host:port/hadoop/hadoopfile<br>从标准输入中读取输入。</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>使用方法：hadoop fs -rm URI [URI …]</p><p>删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。<br>示例：</p><ul><li>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li></ul></li><li><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html</a></p></li></ul><h3 id="HDFS-shell操作练习"><a href="#HDFS-shell操作练习" class="headerlink" title="HDFS shell操作练习"></a>HDFS shell操作练习</h3><ul><li><p>在centos 中创建 test.txt  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br></pre></td></tr></table></figure></li><li><p>在centos中为test.txt 添加文本内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt</span><br></pre></td></tr></table></figure></li><li><p>在HDFS中创建 hadoop001/test 文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir -p /hadoop001/test</span><br></pre></td></tr></table></figure></li><li><p>把text.txt文件上传到HDFS中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put test.txt /hadoop001/test/</span><br></pre></td></tr></table></figure></li><li><p>查看hdfs中 hadoop001/test/test.txt 文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -cat /hadoop001/test/test.txt</span><br></pre></td></tr></table></figure></li><li><p>将hdfs中 hadoop001/test/test.txt文件下载到centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -get /hadoop001/test/test.txt test.txt</span><br></pre></td></tr></table></figure></li><li><p>删除HDFS中 hadoop001/test/</p><p>hadoop fs -rm -r /hadoop001</p></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy&amp;pandas&amp;机器学习算法</title>
      <link href="/2020/03/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习工作流程"><a href="#机器学习工作流程" class="headerlink" title="机器学习工作流程"></a>机器学习工作流程</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>了解机器学习的定义</li><li>知道机器学习的工作流程</li><li>掌握获取到的数据集的特性</li></ul><hr><h2 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1 什么是机器学习"></a>1 什么是机器学习</h2><p>机器学习是从<strong>数据</strong>中<strong>自动分析获得模型</strong>，并利用<strong>模型</strong>对未知数据进行预测。</p><p><img src="https://s1.ax1x.com/2020/03/29/GEgyge.png" alt="GEgyge.png"></p><h2 id="2-机器学习工作流程"><a href="#2-机器学习工作流程" class="headerlink" title="2 机器学习工作流程"></a>2 机器学习工作流程</h2><p><img src="https://s1.ax1x.com/2020/03/29/GEggud.png" alt="GEggud.png"></p><ul><li>机器学习工作流程总结<ul><li><strong>1.获取数据</strong></li><li><strong>2.数据基本处理</strong></li><li><strong>3.特征工程</strong></li><li><strong>4.机器学习(模型训练)</strong></li><li>5.模型评估<ul><li>结果达到要求，上线服务</li><li>没有达到要求，重新上面步骤</li></ul></li></ul></li></ul><h3 id="2-1-获取到的数据集介绍"><a href="#2-1-获取到的数据集介绍" class="headerlink" title="2.1 获取到的数据集介绍"></a>2.1 获取到的数据集介绍</h3><ul><li><p><strong>数据简介</strong></p><p>在数据集中一般：</p><ul><li>一行数据我们称为一个<strong>样本</strong></li><li>一列数据我们成为一个<strong>特征</strong></li><li>有些数据有<strong>目标值（标签值）</strong>，有些数据没有目标值（如上表中，电影类型就是这个数据集的目标值）</li></ul></li><li><p><strong>数据类型构成：</strong></p><ul><li>数据类型一：特征值+目标值（目标值是连续的和离散的）</li><li>数据类型二：只有特征值，没有目标值</li></ul></li><li><p><strong>数据分割：</strong></p><ul><li>机器学习一般的数据集会划分为两个部分：<ul><li>训练数据：用于训练，<strong>构建模型</strong></li><li>测试数据：在模型检验时使用，用于<strong>评估模型是否有效</strong></li></ul></li><li>划分比例：<ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 25%</li></ul></li></ul></li></ul><h3 id="2-2-数据基本处理"><a href="#2-2-数据基本处理" class="headerlink" title="2.2 数据基本处理"></a>2.2 数据基本处理</h3><p> 即对数据进行缺失值、去除异常值等处理</p><h3 id="2-3-特征工程"><a href="#2-3-特征工程" class="headerlink" title="2.3 特征工程"></a>2.3 特征工程</h3><h4 id="2-3-1什么是特征工程"><a href="#2-3-1什么是特征工程" class="headerlink" title="2.3.1什么是特征工程"></a>2.3.1什么是特征工程</h4><p>特征工程是使用<strong>专业背景知识和技巧处理数据</strong>，<strong>使得特征能在机器学习算法上发挥更好的作用的过程</strong>。</p><ul><li>意义：会直接影响机器学习的效果</li></ul><h4 id="2-3-2-为什么需要特征工程-Feature-Engineering"><a href="#2-3-2-为什么需要特征工程-Feature-Engineering" class="headerlink" title="2.3.2 为什么需要特征工程(Feature Engineering)"></a>2.3.2 为什么需要特征工程(Feature Engineering)</h4><blockquote><p>机器学习领域的大神Andrew Ng(吴恩达)老师说“Coming up with features is difficult, time-consuming, requires expert knowledge. “Applied machine learning” is basically feature engineering. ”</p><p>注：业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p></blockquote><h4 id="2-3-3-特征工程包含内容"><a href="#2-3-3-特征工程包含内容" class="headerlink" title="2.3.3 特征工程包含内容"></a>2.3.3 特征工程包含内容</h4><ul><li>特征提取</li><li>特征预处理</li><li>特征降维</li></ul><h4 id="2-3-4-各概念具体解释"><a href="#2-3-4-各概念具体解释" class="headerlink" title="2.3.4 各概念具体解释"></a>2.3.4 各概念具体解释</h4><ul><li><h5 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h5><ul><li>将任意数据（如文本或图像）转换为可用于机器学习的数字特征</li></ul></li><li><p>特征预处理</p><ul><li>通过<strong>一些转换函数</strong>将特征数据<strong>转换成更加适合算法模型</strong>的特征数据过程</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/03/29/GERIXQ.png" alt="GERIXQ.png"></p><h4 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h4><ul><li>指在某些限定条件下，<strong>降低随机变量(特征)个数</strong>，得到<strong>一组“不相关”主变量</strong>的过程</li></ul><h3 id="2-4-机器学习"><a href="#2-4-机器学习" class="headerlink" title="2.4 机器学习"></a>2.4 机器学习</h3><p><strong>选择合适的算法对模型进行训练</strong></p><h3 id="2-5-模型评估"><a href="#2-5-模型评估" class="headerlink" title="2.5 模型评估"></a>2.5 模型评估</h3><p><strong>对训练好的模型进行评估</strong></p><hr><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li>机器学习定义【掌握】<ul><li>机器学习是从<strong>数据</strong>中<strong>自动分析获得模型</strong>，并利用<strong>模型</strong>对未知数据进行预测</li></ul></li><li>机器学习工作流程总结【掌握】<ul><li><strong>1.获取数据</strong></li><li><strong>2.数据基本处理</strong></li><li><strong>3.特征工程</strong></li><li><strong>4.机器学习(模型训练)</strong></li><li>5.模型评估<ul><li>结果达到要求，上线服务</li><li>没有达到要求，重新上面步骤</li></ul></li></ul></li><li>获取到的数据集介绍【掌握】<ul><li>数据集中一行数据一般称为一个样本，一列数据一般称为一个特征。</li><li>数据集的构成：<ul><li>由特征值+目标值（部分数据集没有）构成</li></ul></li><li>为了模型的训练和测试，把数据集分为：<ul><li>训练数据（70%-80%）和测试数据（20%-30%）</li></ul></li></ul></li><li>特征工程包含内容【了解】<ul><li>特征提取</li><li>特征预处理</li><li>特征降维</li></ul></li></ul><h1 id="1-5-机器学习算法分类"><a href="#1-5-机器学习算法分类" class="headerlink" title="1.5 机器学习算法分类"></a>1.5 机器学习算法分类</h1><h2 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>了解机器学习常用算法的分类</li></ul><hr><p>根据<strong>数据集组成不同</strong>，可以把机器学习算法分为：</p><ul><li>监督学习</li><li>无监督学习</li><li>半监督学习</li><li>强化学习</li></ul><h2 id="1-监督学习"><a href="#1-监督学习" class="headerlink" title="1 监督学习"></a>1 监督学习</h2><ul><li>定义：<ul><li>输入数据是由输入特征值和目标值所组成。<ul><li>函数的输出可以是一个连续的值(称为回归），</li><li>或是输出是有限个离散值（称作分类）。</li></ul></li></ul></li></ul><h3 id="1-1-回归问题"><a href="#1-1-回归问题" class="headerlink" title="1.1 回归问题"></a>1.1 回归问题</h3><p>例如：预测房价，根据样本集拟合出一条连续曲线。</p><h3 id="1-2-分类问题"><a href="#1-2-分类问题" class="headerlink" title="1.2 分类问题"></a>1.2 分类问题</h3><p>例如：根据肿瘤特征判断良性还是恶性，得到的是结果是“良性”或者“恶性”，是离散的。</p><h2 id="2-无监督学习"><a href="#2-无监督学习" class="headerlink" title="2 无监督学习"></a>2 无监督学习</h2><ul><li><p>定义：</p><ul><li>输入数据是由输入特征值组成，没有目标值<ul><li>输入数据没有被标记，也没有确定的结果。样本数据类别未知；</li><li>需要根据样本间的相似性对样本集进行类别划分。</li></ul></li></ul></li></ul><ul><li><p><strong>有监督，无监督算法对比：</strong></p><p><img src="https://s1.ax1x.com/2020/03/30/GeHZO1.png" alt="GeHZO1.png"></p></li></ul><h2 id="3-半监督学习"><a href="#3-半监督学习" class="headerlink" title="3 半监督学习"></a>3 半监督学习</h2><ul><li>定义：<ul><li>训练集同时包含有标记样本数据和未标记样本数据。</li></ul></li></ul><p>举例：</p><ul><li><p><strong>监督学习训练方式：</strong></p><p><img src="https://s1.ax1x.com/2020/03/30/GeHTXR.png" alt="GeHTXR.png"></p></li><li><p><strong>半监督学习训练方式</strong>(少)</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/30/GeHXtO.png" alt="GeHXtO.png"></p><h2 id="4-强化学习-动态过程–上一步的输出是下一步的输入"><a href="#4-强化学习-动态过程–上一步的输出是下一步的输入" class="headerlink" title="4 强化学习(动态过程–上一步的输出是下一步的输入)"></a>4 强化学习(动态过程–上一步的输出是下一步的输入)</h2><ul><li>定义：<ul><li>实质是make decisions 问题，即自动进行决策，并且可以做连续决策。</li></ul></li></ul><p>举例：</p><p>小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。</p><p>小孩就是 <strong>agent</strong>，他试图通过采取<strong>行动</strong>（即行走）来操纵<strong>环境</strong>（行走的表面），并且从<strong>一个状态转变到另一个状态</strong>（即他走的每一步），当他完成任务的子任务（即走了几步）时，孩子得到<strong>奖励</strong>（给巧克力吃），并且当他不能走路时，就不会给巧克力。</p><p>主要包含五个元素：agent, action, reward, environment, observation；</p><p>强化学习的目标就是<strong>获得最多的累计奖励</strong>。</p><p>监督学习和强化学习的对比</p><table><thead><tr><th></th><th><strong>监督学习</strong></th><th><strong>强化学习</strong></th></tr></thead><tbody><tr><td>反馈映射</td><td>输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。</td><td>输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。</td></tr><tr><td>反馈时间</td><td>做了比较坏的选择会<strong>立刻反馈给算法</strong>。</td><td>结果<strong>反馈有延时</strong>，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。</td></tr><tr><td>输入特征</td><td>输入是<strong>独立同分布</strong>的。</td><td>面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。</td></tr></tbody></table><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><table><thead><tr><th align="left"></th><th align="center"><strong>In</strong></th><th align="center"><strong>Out</strong></th><th align="center"><strong>目的</strong></th><th align="center"><strong>案例</strong></th></tr></thead><tbody><tr><td align="left"><strong>监督学习</strong> <strong>(supervised learning)</strong></td><td align="center">有标签</td><td align="center">有反馈</td><td align="center">预测结果</td><td align="center">猫狗分类 房价预测</td></tr><tr><td align="left"><strong>无监督学习</strong> <strong>(unsupervised learning)</strong></td><td align="center">无标签</td><td align="center">无反馈</td><td align="center">发现潜在结构</td><td align="center">“物以类聚，人以群分”</td></tr><tr><td align="left"><strong>半监督学习</strong> <strong>(Semi-Supervised Learning)</strong></td><td align="center">部分有标签，部分无标签</td><td align="center">有反馈</td><td align="center">降低数据标记的难度</td><td align="center"></td></tr><tr><td align="left"><strong>强化学习</strong> <strong>(reinforcement learning)</strong></td><td align="center">决策流程及激励系统</td><td align="center">一系列行动</td><td align="center">长期利益最大化</td><td align="center">学下棋</td></tr></tbody></table><h1 id="1-6-模型评估"><a href="#1-6-模型评估" class="headerlink" title="1.6 模型评估"></a>1.6 模型评估</h1><h2 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>目标<ul><li>了解机器学习中模型评估的方法</li><li>知道过拟合、欠拟合发生情况</li></ul></li></ul><hr><p>模型评估是模型开发过程不可或缺的一部分。它有助于发现表达数据的最佳模型和所选模型将来工作的性能如何。</p><p>按照<strong>数据集的目标值不同</strong>，可以把模型评估分为<strong>分类模型评估和回归模型评估。</strong></p><h2 id="1-分类模型评估"><a href="#1-分类模型评估" class="headerlink" title="1 分类模型评估"></a>1 分类模型评估</h2><ul><li><h5 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a><strong>准确率</strong></h5><ul><li>预测正确的数占样本总数的比例。</li></ul></li><li><h5 id="其他评价指标：精确率、召回率、F1-score、AUC指标等"><a href="#其他评价指标：精确率、召回率、F1-score、AUC指标等" class="headerlink" title="其他评价指标：精确率、召回率、F1-score、AUC指标等"></a>其他评价指标：精确率、召回率、F1-score、AUC指标等</h5></li></ul><h2 id="2-回归模型评估"><a href="#2-回归模型评估" class="headerlink" title="2 回归模型评估"></a>2 回归模型评估</h2><h5 id="均方根误差（Root-Mean-Squared-Error，RMSE）"><a href="#均方根误差（Root-Mean-Squared-Error，RMSE）" class="headerlink" title="均方根误差（Root Mean Squared Error，RMSE）"></a>均方根误差（Root Mean Squared Error，RMSE）</h5><ul><li><p>RMSE是一个衡量回归模型误差率的常用公式。 不过，它仅能比较误差是相同单位的模型。</p><p><img src="https://s1.ax1x.com/2020/03/30/GeOvVI.png" alt="GeOvVI.png"></p></li></ul><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设上面的房价预测，只有五个样本，对应的</span><br><span class="line">真实值为：100,120,125,230,400</span><br><span class="line">预测值为：105,119,120,230,410</span><br></pre></td></tr></table></figure><p>那么使用均方根误差求解得：<br>$$<br>RMSE=\sqrt[2]{\frac{[(100-105)^2+(120-119)^2+5^2+0^2+10^2]}{5}} =5.495<br>$$</p><h5 id="其他评价指标：相对平方误差（Relative-Squared-Error，RSE）、平均绝对误差（Mean-Absolute-Error，MAE-、相对绝对误差（Relative-Absolute-Error，RAE"><a href="#其他评价指标：相对平方误差（Relative-Squared-Error，RSE）、平均绝对误差（Mean-Absolute-Error，MAE-、相对绝对误差（Relative-Absolute-Error，RAE" class="headerlink" title="其他评价指标：相对平方误差（Relative Squared Error，RSE）、平均绝对误差（Mean Absolute Error，MAE)、相对绝对误差（Relative Absolute Error，RAE)"></a>其他评价指标：相对平方误差（Relative Squared Error，RSE）、平均绝对误差（Mean Absolute Error，MAE)、相对绝对误差（Relative Absolute Error，RAE)</h5><h2 id="3-拟合"><a href="#3-拟合" class="headerlink" title="3 拟合"></a>3 拟合</h2><p>模型评估用于评价训练好的的模型的表现效果，其表现效果大致可以分为两类：过拟合、欠拟合。</p><p>在训练过程中，你可能会遇到如下问题：</p><h5 id="训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？"><a href="#训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？" class="headerlink" title="训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？"></a>训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？</h5><p>当算法在某个数据集当中出现这种情况，可能就出现了拟合问题。</p><h3 id="3-1-欠拟合"><a href="#3-1-欠拟合" class="headerlink" title="3.1 欠拟合"></a>3.1 欠拟合</h3><p><img src="https://s1.ax1x.com/2020/03/30/GeXKRU.png" alt="GeXKRU.png"></p><p>因为机器学习到的天鹅特征太少了，导致区分标准太粗糙，不能准确识别出天鹅。</p><p><strong>欠拟合（under-fitting）</strong>：<strong>模型学习的太过粗糙</strong>，连<strong>训练集中的样本数据特征关系都没有学出来</strong>。</p><h3 id="3-2-过拟合"><a href="#3-2-过拟合" class="headerlink" title="3.2 过拟合"></a>3.2 过拟合</h3><p><img src="https://s1.ax1x.com/2020/03/30/GeXYIx.png" alt="GeXYIx.png"></p><p>机器已经基本能区别天鹅和其他动物了。然后，很不巧已有的天鹅图片全是白天鹅的，于是机器经过学习后，会认为天鹅的羽毛都是白的，以后看到羽毛是黑的天鹅就会认为那不是天鹅。</p><p><strong>过拟合</strong>（over-fitting）：所建的机器学习模型或者是深度学习模型在训练样本中<strong>表现得过于优越</strong>，导致在<strong>测试数据集中表现不佳</strong>。</p><ul><li>上问题解答：<ul><li>训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？</li></ul></li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><ul><li>分类模型评估【了解】<ul><li>准确率</li></ul></li><li>回归模型评估【了解】<ul><li>RMSE – 均方根误差</li></ul></li><li>拟合【知道】<ul><li>举例 – 判断是否是人</li><li>欠拟合<ul><li>学习到的东西太少</li><li>模型学习的太过粗糙</li></ul></li><li>过拟合<ul><li>学习到的东西太多</li><li>学习到的特征多，不好泛化</li></ul></li></ul></li></ul><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h1 id="4-1-Numpy优势"><a href="#4-1-Numpy优势" class="headerlink" title="4.1 Numpy优势"></a>4.1 Numpy优势</h1><hr><h2 id="1-Numpy介绍"><a href="#1-Numpy介绍" class="headerlink" title="1 Numpy介绍"></a>1 Numpy介绍</h2><p>Numpy（Numerical Python）是一个开源的Python科学计算库，<strong>用于快速处理任意维度的数组</strong>。</p><p>Numpy<strong>支持常见的数组和矩阵操作</strong>。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。</p><p>Numpy<strong>使用ndarray对象来处理多维数组</strong>，该对象是一个快速而灵活的大数据容器。</p><h2 id="2-ndarray介绍"><a href="#2-ndarray介绍" class="headerlink" title="2 ndarray介绍"></a>2 ndarray介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumPy provides an N-dimensional array type, the ndarray, </span><br><span class="line">which describes a collection of “items” of the same type.</span><br></pre></td></tr></table></figure><p>NumPy提供了一个<strong>N维数组类型ndarray</strong>，它描述了<strong>相同类型</strong>的“items”的集合。</p><p>用ndarray进行存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ndarray</span></span><br><span class="line">score = np.array(</span><br><span class="line">[[<span class="number">80</span>, <span class="number">89</span>, <span class="number">86</span>, <span class="number">67</span>, <span class="number">79</span>],</span><br><span class="line">[<span class="number">78</span>, <span class="number">97</span>, <span class="number">89</span>, <span class="number">67</span>, <span class="number">81</span>],</span><br><span class="line">[<span class="number">90</span>, <span class="number">94</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">74</span>],</span><br><span class="line">[<span class="number">91</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">67</span>, <span class="number">69</span>],</span><br><span class="line">[<span class="number">76</span>, <span class="number">87</span>, <span class="number">75</span>, <span class="number">67</span>, <span class="number">86</span>],</span><br><span class="line">[<span class="number">70</span>, <span class="number">79</span>, <span class="number">84</span>, <span class="number">67</span>, <span class="number">84</span>],</span><br><span class="line">[<span class="number">94</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">67</span>, <span class="number">64</span>],</span><br><span class="line">[<span class="number">86</span>, <span class="number">85</span>, <span class="number">83</span>, <span class="number">67</span>, <span class="number">80</span>]])</span><br><span class="line"></span><br><span class="line">score</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">80</span>, <span class="number">89</span>, <span class="number">86</span>, <span class="number">67</span>, <span class="number">79</span>],</span><br><span class="line">       [<span class="number">78</span>, <span class="number">97</span>, <span class="number">89</span>, <span class="number">67</span>, <span class="number">81</span>],</span><br><span class="line">       [<span class="number">90</span>, <span class="number">94</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">74</span>],</span><br><span class="line">       [<span class="number">91</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">67</span>, <span class="number">69</span>],</span><br><span class="line">       [<span class="number">76</span>, <span class="number">87</span>, <span class="number">75</span>, <span class="number">67</span>, <span class="number">86</span>],</span><br><span class="line">       [<span class="number">70</span>, <span class="number">79</span>, <span class="number">84</span>, <span class="number">67</span>, <span class="number">84</span>],</span><br><span class="line">       [<span class="number">94</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">67</span>, <span class="number">64</span>],</span><br><span class="line">       [<span class="number">86</span>, <span class="number">85</span>, <span class="number">83</span>, <span class="number">67</span>, <span class="number">80</span>]])</span><br></pre></td></tr></table></figure><p><strong>提问:</strong></p><p><strong>使用Python列表可以存储一维数组，通过列表的嵌套可以实现多维数组，那么为什么还需要使用Numpy的ndarray呢？</strong></p><h2 id="3-ndarray与Python原生list运算效率对比"><a href="#3-ndarray与Python原生list运算效率对比" class="headerlink" title="3 ndarray与Python原生list运算效率对比"></a>3 ndarray与Python原生list运算效率对比</h2><p>在这里我们通过一段代码运行来体会到ndarray的好处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):</span><br><span class="line">    a.append(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过%time魔法方法, 查看当前行的代码运行一次所花费的时间</span></span><br><span class="line">%time sum1=sum(a)</span><br><span class="line"></span><br><span class="line">b=np.array(a)</span><br><span class="line"></span><br><span class="line">%time sum2=np.sum(b)</span><br></pre></td></tr></table></figure><p>其中第一个时间显示的是使用原生Python计算时间,第二个内容是使用numpy计算时间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU times: user 852 ms, sys: 262 ms, total: 1.11 s</span><br><span class="line">Wall time: 1.13 s</span><br><span class="line">CPU times: user 133 ms, sys: 653 µs, total: 133 ms</span><br><span class="line">Wall time: 134 ms</span><br></pre></td></tr></table></figure><p>从中我们看到ndarray的计算速度要快很多，节约了时间。</p><p><strong>机器学习的最大特点就是大量的数据运算</strong>，那么如果没有一个快速的解决方案，那可能现在python也在机器学习领域达不到好的效果。</p><p><img src="https://s1.ax1x.com/2020/03/30/Gnka8J.png" alt="Gnka8J.png"></p><p>Numpy专门针对ndarray的操作和运算进行了设计，所以数组的存储效率和输入输出性能远优于Python中的嵌套列表，数组越大，Numpy的优势就越明显。</p><h2 id="4-ndarray的优势"><a href="#4-ndarray的优势" class="headerlink" title="4 ndarray的优势"></a>4 ndarray的优势</h2><h4 id="4-1-内存块风格"><a href="#4-1-内存块风格" class="headerlink" title="4.1 内存块风格"></a>4.1 内存块风格</h4><p>ndarray到底跟原生python列表有什么不同呢，请看一张图：</p><p><img src="https://s1.ax1x.com/2020/03/30/GnAao8.png" alt="GnAao8.png"></p><p>从图中我们可以看出ndarray在存储数据的时候，数据与数据的地址都是连续的，这样就给使得批量操作数组元素时速度更快。</p><p>这是因为ndarray中的所有元素的类型都是相同的，而Python列表中的元素类型是任意的，所以ndarray在存储元素时内存可以连续，而python原生list就只能通过寻址方式找到下一个元素，这虽然也导致了在通用性能方面Numpy的ndarray不及Python原生list，但在科学计算中，Numpy的ndarray就可以省掉很多循环语句，代码使用方面比Python原生list简单的多。</p><h4 id="4-2-ndarray支持并行化运算（向量化运算）"><a href="#4-2-ndarray支持并行化运算（向量化运算）" class="headerlink" title="4.2 ndarray支持并行化运算（向量化运算）"></a>4.2 ndarray支持并行化运算（向量化运算）</h4><p>numpy内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy会自动做并行计算</p><h4 id="4-3-效率远高于纯Python代码"><a href="#4-3-效率远高于纯Python代码" class="headerlink" title="4.3 效率远高于纯Python代码"></a>4.3 效率远高于纯Python代码</h4><p>Numpy底层使用C语言编写，内部解除了GIL（全局解释器锁），其对数组的操作速度不受Python解释器的限制，所以，其效率远高于纯Python代码。</p><h2 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5 小结"></a>5 小结</h2><ul><li>numpy介绍【了解】<ul><li>一个开源的Python科学计算库</li><li>计算起来要比python简洁高效</li><li>Numpy使用ndarray对象来处理多维数组</li></ul></li><li>ndarray介绍【了解】<ul><li>NumPy提供了一个N维数组类型ndarray，它描述了相同类型的“items”的集合。</li><li>生成numpy对象:np.array()</li></ul></li><li>ndarray的优势【掌握】<ul><li>内存块风格<ul><li>list – 分离式存储,存储内容多样化</li><li>ndarray – 一体式存储,存储类型必须一样</li></ul></li><li>ndarray支持并行化运算（向量化运算）</li><li>ndarray底层是用C语言写的,效率更高,释放了GIL</li></ul></li></ul><h1 id="4-2-N维数组-ndarray"><a href="#4-2-N维数组-ndarray" class="headerlink" title="4.2 N维数组-ndarray"></a>4.2 N维数组-ndarray</h1><h2 id="1-ndarray的属性"><a href="#1-ndarray的属性" class="headerlink" title="1 ndarray的属性"></a>1 ndarray的属性</h2><p>数组属性反映了数组本身固有的信息。</p><table><thead><tr><th align="center">属性名字</th><th align="center">属性解释</th></tr></thead><tbody><tr><td align="center">ndarray.shape</td><td align="center">数组维度的元组</td></tr><tr><td align="center">ndarray.ndim</td><td align="center">数组维数</td></tr><tr><td align="center">ndarray.size</td><td align="center">数组中的元素数量</td></tr><tr><td align="center">ndarray.itemsize</td><td align="center">一个数组元素的长度（字节）</td></tr><tr><td align="center">ndarray.dtype</td><td align="center">数组元素的类型</td></tr></tbody></table><h2 id="2-ndarray的形状"><a href="#2-ndarray的形状" class="headerlink" title="2 ndarray的形状"></a>2 ndarray的形状</h2><p>首先创建一些数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建不同形状的数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]])</span><br></pre></td></tr></table></figure><p>分别打印出形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 二维数组</span></span><br><span class="line">(<span class="number">4</span>,)    <span class="comment"># 一维数组</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 三维数组</span></span><br></pre></td></tr></table></figure><h2 id="3-ndarray的类型"><a href="#3-ndarray的类型" class="headerlink" title="3 ndarray的类型"></a>3 ndarray的类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(score.dtype)</span><br><span class="line"></span><br><span class="line">&lt;type <span class="string">'numpy.dtype'</span>&gt;</span><br></pre></td></tr></table></figure><p>dtype是numpy.dtype类型，先看看对于数组来说都有哪些类型</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">简写</th></tr></thead><tbody><tr><td align="center">np.bool</td><td align="center">用一个字节存储的布尔类型（True或False）</td><td align="center">‘b’</td></tr><tr><td align="center">np.int8</td><td align="center">一个字节大小，-128 至 127</td><td align="center">‘i’</td></tr><tr><td align="center">np.int16</td><td align="center">整数，-32768 至 32767</td><td align="center">‘i2’</td></tr><tr><td align="center">np.int32</td><td align="center">整数，-2^31 至 2^32 -1</td><td align="center">‘i4’</td></tr><tr><td align="center">np.int64</td><td align="center">整数，-2^63 至 2^63 - 1</td><td align="center">‘i8’</td></tr><tr><td align="center">np.uint8</td><td align="center">无符号整数，0 至 255</td><td align="center">‘u’</td></tr><tr><td align="center">np.uint16</td><td align="center">无符号整数，0 至 65535</td><td align="center">‘u2’</td></tr><tr><td align="center">np.uint32</td><td align="center">无符号整数，0 至 2^32 - 1</td><td align="center">‘u4’</td></tr><tr><td align="center">np.uint64</td><td align="center">无符号整数，0 至 2^64 - 1</td><td align="center">‘u8’</td></tr><tr><td align="center">np.float16</td><td align="center">半精度浮点数：16位，正负号1位，指数5位，精度10位</td><td align="center">‘f2’</td></tr><tr><td align="center">np.float32</td><td align="center">单精度浮点数：32位，正负号1位，指数8位，精度23位</td><td align="center">‘f4’</td></tr><tr><td align="center">np.float64</td><td align="center">双精度浮点数：64位，正负号1位，指数11位，精度52位</td><td align="center">‘f8’</td></tr><tr><td align="center">np.complex64</td><td align="center">复数，分别用两个32位浮点数表示实部和虚部</td><td align="center">‘c8’</td></tr><tr><td align="center">np.complex128</td><td align="center">复数，分别用两个64位浮点数表示实部和虚部</td><td align="center">‘c16’</td></tr><tr><td align="center">np.object_</td><td align="center">python对象</td><td align="center">‘O’</td></tr><tr><td align="center">np.string_</td><td align="center">字符串</td><td align="center">‘S’</td></tr><tr><td align="center">np.unicode_</td><td align="center">unicode类型</td><td align="center">‘U’</td></tr></tbody></table><p><strong>创建数组的时候指定类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], dtype=np.float32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([<span class="string">'python'</span>, <span class="string">'tensorflow'</span>, <span class="string">'scikit-learn'</span>, <span class="string">'numpy'</span>], dtype = np.string_)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([<span class="string">b'python'</span>, <span class="string">b'tensorflow'</span>, <span class="string">b'scikit-learn'</span>, <span class="string">b'numpy'</span>], dtype=<span class="string">'|S12'</span>)</span><br></pre></td></tr></table></figure><ul><li>注意：若不指定，整数默认int64，小数默认float64</li></ul><h1 id="4-3-基本操作"><a href="#4-3-基本操作" class="headerlink" title="4.3 基本操作"></a>4.3 基本操作</h1><h2 id="1-生成数组的方法"><a href="#1-生成数组的方法" class="headerlink" title="1 生成数组的方法"></a>1 生成数组的方法</h2><h3 id="1-1-生成0和1的数组"><a href="#1-1-生成0和1的数组" class="headerlink" title="1.1 生成0和1的数组"></a>1.1 生成0和1的数组</h3><ul><li><strong>np.ones(shape, dtype)</strong></li><li>np.ones_like(a, dtype) （a是一个array，按照a的样式生成）</li><li><strong>np.zeros(shape, dtype)</strong></li><li>np.zeros_like(a, dtype)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ones = np.ones([<span class="number">4</span>,<span class="number">8</span>])</span><br><span class="line">ones</span><br></pre></td></tr></table></figure><p>返回结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line">np.zeros_like(ones)</span><br></pre></td></tr></table></figure><p>返回结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><h3 id="1-2-从现有数组生成"><a href="#1-2-从现有数组生成" class="headerlink" title="1.2 从现有数组生成"></a>1.2 从现有数组生成</h3><h4 id="1-2-1-生成方式"><a href="#1-2-1-生成方式" class="headerlink" title="1.2.1 生成方式"></a>1.2.1 生成方式</h4><ul><li><strong>np.array(object, dtype)</strong></li><li><strong>np.asarray(a, dtype)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 从现有的数组当中创建</span></span><br><span class="line">a1 = np.array(a)</span><br><span class="line"><span class="comment"># 相当于索引的形式，并没有真正的创建一个新的</span></span><br><span class="line">a2 = np.asarray(a)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-关于array和asarray的不同"><a href="#1-2-2-关于array和asarray的不同" class="headerlink" title="1.2.2 关于array和asarray的不同"></a>1.2.2 关于array和asarray的不同</h4><p>array是深拷贝 – 相当于复制了一份</p><p>asarray是浅拷贝 – 相当于创建了一个快捷方式</p><h3 id="1-3-生成固定范围的数组"><a href="#1-3-生成固定范围的数组" class="headerlink" title="1.3 生成固定范围的数组"></a>1.3 生成固定范围的数组</h3><h4 id="1-3-1-np-linspace-start-stop-num-endpoint"><a href="#1-3-1-np-linspace-start-stop-num-endpoint" class="headerlink" title="1.3.1 np.linspace (start, stop, num, endpoint)"></a>1.3.1 np.linspace (start, stop, num, endpoint)</h4><ul><li>创建等差数组 — 指定数量</li><li>参数:<ul><li>start:序列的起始值</li><li>stop:序列的终止值</li><li>num:要生成的等间隔样例数量，默认为50</li><li>endpoint:序列中是否包含stop值，默认为ture</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成等间隔的数组</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([  <span class="number">0.</span>,  <span class="number">10.</span>,  <span class="number">20.</span>,  <span class="number">30.</span>,  <span class="number">40.</span>,  <span class="number">50.</span>,  <span class="number">60.</span>,  <span class="number">70.</span>,  <span class="number">80.</span>,  <span class="number">90.</span>, <span class="number">100.</span>])</span><br></pre></td></tr></table></figure><h4 id="1-3-2-np-arange-start-stop-step-dtype"><a href="#1-3-2-np-arange-start-stop-step-dtype" class="headerlink" title="1.3.2 np.arange(start,stop, step, dtype)"></a>1.3.2 np.arange(start,stop, step, dtype)</h4><ul><li>创建等差数组 — 指定步长</li><li>参数<ul><li>step:步长,默认值为1</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">50</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">42</span>,</span><br><span class="line">       <span class="number">44</span>, <span class="number">46</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure><h4 id="1-3-3-np-logspace-start-stop-num"><a href="#1-3-3-np-logspace-start-stop-num" class="headerlink" title="1.3.3 np.logspace(start,stop, num)"></a>1.3.3 np.logspace(start,stop, num)</h4><ul><li>创建等比数列</li><li>参数:<ul><li>num:要生成的等比数列数量，默认为50</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成10^x</span></span><br><span class="line">np.logspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>返回结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([  1.,  10., 100.])</span><br></pre></td></tr></table></figure><h3 id="1-4-生成随机数组"><a href="#1-4-生成随机数组" class="headerlink" title="1.4 生成随机数组"></a>1.4 生成随机数组</h3><h4 id="1-4-1-使用模块介绍"><a href="#1-4-1-使用模块介绍" class="headerlink" title="1.4.1 使用模块介绍"></a>1.4.1 使用模块介绍</h4><ul><li>np.random模块</li></ul><h4 id="1-4-2-正态分布"><a href="#1-4-2-正态分布" class="headerlink" title="1.4.2 正态分布"></a>1.4.2 正态分布</h4><h5 id="一、基础概念复习：正态分布（理解）"><a href="#一、基础概念复习：正态分布（理解）" class="headerlink" title="一、基础概念复习：正态分布（理解）"></a>一、基础概念复习：正态分布（理解）</h5><h5 id="a-什么是正态分布"><a href="#a-什么是正态分布" class="headerlink" title="a. 什么是正态分布"></a>a. 什么是正态分布</h5><p>正态分布是一种概率分布。正态分布是具有两个参数μ和σ的连续型随机变量的分布，第一参数μ是服从正态分布的随机变量的均值，第二个参数σ是此随机变量的方差，所以正态分布记作<strong>N(μ，σ )</strong>。</p><p><img src="images/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="img"></p><h5 id="b-正态分布的应用"><a href="#b-正态分布的应用" class="headerlink" title="b. 正态分布的应用"></a>b. 正态分布的应用</h5><p>生活、生产与科学实验中很多随机变量的概率分布都可以近似地用正态分布来描述。</p><h5 id="c-正态分布特点"><a href="#c-正态分布特点" class="headerlink" title="c. 正态分布特点"></a>c. 正态分布特点</h5><p><strong>μ决定了其位置，其标准差σ</strong>决定了分布的幅度。当μ = 0,σ = 1时的正态分布是标准正态分布。</p><p>标准差如何来？</p><ul><li><h6 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h6></li></ul><p>是在概率论和统计方差衡量一组数据时离散程度的度量</p><p><img src="image/image-20190620081842007.png" alt="image-20190620081842007"></p><p>其中M为平均值，n为数据总个数，σ 为标准差，σ ^2可以理解一个整体为方差</p><p><img src="images/%E6%A0%87%E5%87%86%E5%B7%AE%E5%85%AC%E5%BC%8F.png" alt="标准差公式"></p><ul><li><h6 id="标准差与方差的意义"><a href="#标准差与方差的意义" class="headerlink" title="标准差与方差的意义"></a><strong>标准差与方差的意义</strong></h6></li></ul><p>可以理解成数据的一个离散程度的衡量</p><p><img src="images/%E7%A6%BB%E6%95%A3%E7%A8%8B%E5%BA%A6.png" alt="离散程度"></p><h5 id="二、正态分布创建方式"><a href="#二、正态分布创建方式" class="headerlink" title="二、正态分布创建方式"></a>二、正态分布创建方式</h5><ul><li><p>np.random.randn(<em>d0, d1, …, dn</em>)</p><p>功能：从标准正态分布中返回一个或多个样本值</p></li><li><p><strong>np.random.normal(*loc=0.0*, *scale=1.0*, *size=None*)</strong></p><p>loc：float</p><p> 此概率分布的均值（对应着整个分布的中心centre）</p><p>scale：float</p><p> 此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）</p><p>size：int or tuple of ints</p><p> 输出的shape，默认为None，只输出一个值</p></li><li><p>np.random.standard_normal(<em>size=None</em>)</p><p>返回指定形状的标准正态分布的数组。</p></li></ul><h5 id="举例1：生成均值为1-75，标准差为1的正态分布数据，100000000个"><a href="#举例1：生成均值为1-75，标准差为1的正态分布数据，100000000个" class="headerlink" title="举例1：生成均值为1.75，标准差为1的正态分布数据，100000000个"></a>举例1：生成均值为1.75，标准差为1的正态分布数据，100000000个</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">2.90646763</span>, <span class="number">1.46737886</span>, <span class="number">2.21799024</span>, ..., <span class="number">1.56047411</span>, <span class="number">1.87969135</span>,</span><br><span class="line">       <span class="number">0.9028096</span> ])</span><br><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x1 = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x1, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="images/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="img"></p><p>例如：我们可以模拟生成一组股票的涨跌幅的数据</p><h5 id="举例2：随机生成4支股票1周的交易日涨幅数据"><a href="#举例2：随机生成4支股票1周的交易日涨幅数据" class="headerlink" title="举例2：随机生成4支股票1周的交易日涨幅数据"></a>举例2：随机生成4支股票1周的交易日涨幅数据</h5><p>4支股票，<strong>一周(5天)</strong>的涨跌幅数据，如何获取？</p><ul><li>随机生成涨跌幅在某个正态分布内，比如均值0，方差1</li></ul><h5 id="股票涨跌幅数据的创建"><a href="#股票涨跌幅数据的创建" class="headerlink" title="股票涨跌幅数据的创建"></a>股票涨跌幅数据的创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符合正态分布的4只股票5天的涨跌幅数据</span></span><br><span class="line">stock_change = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">stock_change</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[ <span class="number">0.0476585</span> ,  <span class="number">0.32421568</span>,  <span class="number">1.50062162</span>,  <span class="number">0.48230497</span>, <span class="number">-0.59998822</span>],</span><br><span class="line">       [<span class="number">-1.92160851</span>,  <span class="number">2.20430374</span>, <span class="number">-0.56996263</span>, <span class="number">-1.44236548</span>,  <span class="number">0.0165062</span> ],</span><br><span class="line">       [<span class="number">-0.55710486</span>, <span class="number">-0.18726488</span>, <span class="number">-0.39972172</span>,  <span class="number">0.08580347</span>, <span class="number">-1.82842225</span>],</span><br><span class="line">       [<span class="number">-1.22384505</span>, <span class="number">-0.33199305</span>,  <span class="number">0.23308845</span>, <span class="number">-1.20473702</span>, <span class="number">-0.31753223</span>]])</span><br></pre></td></tr></table></figure><h4 id="1-4-2-均匀分布"><a href="#1-4-2-均匀分布" class="headerlink" title="1.4.2 均匀分布"></a>1.4.2 均匀分布</h4><ul><li><p>np.random.rand(</p><p>d0</p><p>,</p></li></ul><p>  d1</p><p>  ,</p><p>  …</p><p>  ,</p><p>  dn</p><p>  )</p><ul><li>返回<strong>[0.0，1.0)</strong>内的一组均匀分布的数。</li></ul><ul><li><p>np.random.uniform(<em>low=0.0</em>, <em>high=1.0</em>, <em>size=None</em>)</p><ul><li>功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.</li><li>参数介绍:<ul><li>low: 采样下界，float类型，默认值为0；</li><li>high: 采样上界，float类型，默认值为1；</li><li>size: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出m<em>n</em>k个样本，缺省时输出1个值。</li></ul></li><li>返回值：ndarray类型，其形状和参数size中描述一致。</li></ul></li><li><p>np.random.randint(</p><p>low</p><p>,</p></li></ul><p>  high=None</p><p>  ,</p><p>  size=None</p><p>  ,</p><p>  dtype=’l’</p><p>  )</p><ul><li>从一个均匀分布中随机采样，生成一个整数或N维整数数组，</li><li>取数范围：若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x2 = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([ <span class="number">0.22411206</span>,  <span class="number">0.31414671</span>,  <span class="number">0.85655613</span>, ..., <span class="number">-0.92972446</span>,</span><br><span class="line"><span class="number">0.95985223</span>,  <span class="number">0.23197723</span>])</span><br></pre></td></tr></table></figure><p>画图看分布状况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x2 = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x=x2, bins=<span class="number">1000</span>)  <span class="comment"># x代表要使用的数据，bins表示要划分区间数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="images/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83.png" alt="img"></p><h2 id="2-数组的索引、切片"><a href="#2-数组的索引、切片" class="headerlink" title="2 数组的索引、切片"></a>2 数组的索引、切片</h2><p>一维、二维、三维的数组如何索引？</p><ul><li>直接进行索引,切片</li><li>对象[:, :] – 先行后列</li></ul><p>二维数组索引方式：</p><ul><li>举例：获取第一个股票的前3个交易日的涨跌幅数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维的数组，两个维度 </span></span><br><span class="line">stock_change[<span class="number">0</span>, <span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">-0.03862668</span>, <span class="number">-1.46128096</span>, <span class="number">-0.75596237</span>])</span><br></pre></td></tr></table></figure><ul><li>三维数组索引方式：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三维</span></span><br><span class="line">a1 = np.array([ [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">34</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]])</span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>,  <span class="number">3</span>, <span class="number">34</span>],</span><br><span class="line">        [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]]])</span><br><span class="line"><span class="comment"># 索引、切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]   <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><h2 id="3-形状修改"><a href="#3-形状修改" class="headerlink" title="3 形状修改"></a>3 形状修改</h2><h3 id="3-1-ndarray-reshape-shape-order"><a href="#3-1-ndarray-reshape-shape-order" class="headerlink" title="3.1 ndarray.reshape(shape, order)"></a>3.1 ndarray.reshape(shape, order)</h3><ul><li>返回一个具有相同数据域，但shape不一样的<strong>视图</strong></li><li>行、列不进行互换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在转换形状的时候，一定要注意数组的元素匹配</span></span><br><span class="line">stock_change.reshape([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">stock_change.reshape([<span class="number">-1</span>,<span class="number">10</span>])  <span class="comment"># 数组的形状被修改为: (2, 10), -1: 表示通过待计算</span></span><br></pre></td></tr></table></figure><h3 id="3-2-ndarray-resize-new-shape"><a href="#3-2-ndarray-resize-new-shape" class="headerlink" title="3.2 ndarray.resize(new_shape)"></a>3.2 ndarray.resize(new_shape)</h3><ul><li>修改数组本身的形状（需要保持元素个数前后相同）</li><li>行、列不进行互换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stock_change.resize([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看修改后结果</span></span><br><span class="line">stock_change.shape</span><br><span class="line">(<span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-ndarray-T"><a href="#3-3-ndarray-T" class="headerlink" title="3.3 ndarray.T"></a>3.3 ndarray.T</h3><ul><li>数组的转置</li><li>将数组的行、列进行互换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_change.T.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="4-类型修改"><a href="#4-类型修改" class="headerlink" title="4 类型修改"></a>4 类型修改</h2><h3 id="4-1-ndarray-astype-type"><a href="#4-1-ndarray-astype-type" class="headerlink" title="4.1 ndarray.astype(type)"></a>4.1 ndarray.astype(type)</h3><ul><li>返回修改了类型之后的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_change.astype(np.int32)</span><br></pre></td></tr></table></figure><h3 id="4-2-ndarray-tostring-order-或者ndarray-tobytes-order"><a href="#4-2-ndarray-tostring-order-或者ndarray-tobytes-order" class="headerlink" title="4.2 ndarray.tostring([order])或者ndarray.tobytes([order])"></a>4.2 ndarray.tostring([order])或者ndarray.tobytes([order])</h3><ul><li>构造包含数组中原始数据字节的Python字节</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]])</span><br><span class="line">arr.tostring()</span><br></pre></td></tr></table></figure><h3 id="4-3-jupyter输出太大可能导致崩溃问题【了解】"><a href="#4-3-jupyter输出太大可能导致崩溃问题【了解】" class="headerlink" title="4.3 jupyter输出太大可能导致崩溃问题【了解】"></a>4.3 jupyter输出太大可能导致崩溃问题【了解】</h3><p>如果遇到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOPub data rate exceeded.</span><br><span class="line">    The notebook server will temporarily stop sending output</span><br><span class="line">    to the client in order to avoid crashing it.</span><br><span class="line">    To change this limit, set the config variable</span><br><span class="line">    `--NotebookApp.iopub_data_rate_limit`.</span><br></pre></td></tr></table></figure><p>这个问题是在jupyer当中对输出的字节数有限制，需要去修改配置文件</p><p>创建配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line">vi ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>取消注释,多增加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## (bytes/sec) Maximum rate at which messages can be sent on iopub before they</span></span><br><span class="line"><span class="comment">#  are limited.</span></span><br><span class="line">c.NotebookApp.iopub_data_rate_limit = <span class="number">10000000</span></span><br></pre></td></tr></table></figure><p><strong>但是不建议这样去修改，jupyter输出太大会崩溃</strong></p><h2 id="5-数组的去重"><a href="#5-数组的去重" class="headerlink" title="5 数组的去重"></a>5 数组的去重</h2><h3 id="5-1-np-unique"><a href="#5-1-np-unique" class="headerlink" title="5.1 np.unique()"></a>5.1 np.unique()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.unique(temp)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h2><ul><li>创建数组【掌握】<ul><li>生成0和1的数组<ul><li>np.ones()</li><li>np.ones_like()</li></ul></li><li>从现有数组中生成<ul><li>np.array – 深拷贝</li><li>np.asarray – 浅拷贝</li></ul></li><li>生成固定范围数组<ul><li>np.linspace()<ul><li>nun – 生成等间隔的多少个</li></ul></li><li>np.arange()<ul><li>step – 每间隔多少生成数据</li></ul></li><li>np.logspace()<ul><li>生成以10的N次幂的数据</li></ul></li></ul></li><li>生层随机数组<ul><li>正态分布<ul><li>里面需要关注的参数:均值:u, 标准差:σ<ul><li>u – 决定了这个图形的左右位置</li><li>σ – 决定了这个图形是瘦高还是矮胖</li></ul></li><li>np.random.randn()</li><li>np.random.normal(0, 1, 100)</li></ul></li><li>均匀<ul><li>np.random.rand()</li><li>np.random.uniform(0, 1, 100)</li><li>np.random.randint(0, 10, 10)</li></ul></li></ul></li></ul></li><li>数组索引【知道】<ul><li>直接进行索引,切片</li><li>对象[:, :] – 先行后列</li></ul></li><li>数组形状改变【掌握】<ul><li>对象.reshape()<ul><li>没有进行行列互换,新产生一个ndarray</li></ul></li><li>对象.resize()<ul><li>没有进行行列互换,修改原来的ndarray</li></ul></li><li>对象.T<ul><li>进行了行列互换</li></ul></li></ul></li><li>数组去重【知道】<ul><li>np.unique(对象)</li></ul></li></ul><h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><h3 id="1-1-K-近邻算法-KNN-概念"><a href="#1-1-K-近邻算法-KNN-概念" class="headerlink" title="1.1 K-近邻算法(KNN)概念"></a>1.1 K-近邻算法(KNN)概念</h3><p>K Nearest Neighbor算法又叫KNN算法，这个算法是机器学习里面一个比较经典的算法， 总体来说KNN算法是相对比较容易理解的算法</p><ul><li>定义</li></ul><p>如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</p><blockquote><p>来源：KNN算法最早是由Cover和Hart提出的一种分类算法</p></blockquote><ul><li>距离公式</li></ul><p>两个样本的距离可以通过如下公式计算，又叫欧式距离</p><h1 id="1-2-k近邻算法api-scikit-learn-初步使用"><a href="#1-2-k近邻算法api-scikit-learn-初步使用" class="headerlink" title="1.2 k近邻算法api(scikit-learn)初步使用"></a>1.2 k近邻算法api(scikit-learn)初步使用</h1><h3 id="机器学习流程复习："><a href="#机器学习流程复习：" class="headerlink" title="机器学习流程复习："></a>机器学习流程复习：</h3><ul><li>1.获取数据集</li><li>2.数据基本处理</li><li>3.特征工程</li><li>4.机器学习</li><li>5.模型评估</li></ul><p><strong>一个简单的例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据（y代表类别）</span></span><br><span class="line">x = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器学习</span></span><br><span class="line"><span class="comment"># 1.实例化一个训练模型</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 2.调用fit方法进行训练</span></span><br><span class="line">estimator.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测其他值</span></span><br><span class="line">ret = estimator.predict([[<span class="number">-1</span>]])</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h1 id="1-3-距离度量"><a href="#1-3-距离度量" class="headerlink" title="1.3 距离度量"></a>1.3 距离度量</h1><h2 id="1-欧式距离-Euclidean-Distance-："><a href="#1-欧式距离-Euclidean-Distance-：" class="headerlink" title="1 欧式距离(Euclidean Distance)："></a>1 欧式距离<strong>(Euclidean Distance)：</strong></h2><p><img src="https://s1.ax1x.com/2020/03/19/8sQ7jO.png" alt="8sQ7jO.png"></p><h2 id="2-曼哈顿距离-Manhattan-Distance-："><a href="#2-曼哈顿距离-Manhattan-Distance-：" class="headerlink" title="2 曼哈顿距离(Manhattan Distance)："></a>2 <strong>曼哈顿距离(Manhattan Distance)：</strong></h2><p>在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是“曼哈顿距离”。曼哈顿距离也称为“城市街区距离”(City Block distance)。</p><p><img src="https://s1.ax1x.com/2020/03/19/8s0ewq.png" alt="8s0ewq.png"></p><p><img src="https://s1.ax1x.com/2020/03/19/8s0MfU.png" alt="8s0MfU.png"></p><h2 id="3-切比雪夫距离-Chebyshev-Distance-："><a href="#3-切比雪夫距离-Chebyshev-Distance-：" class="headerlink" title="3 切比雪夫距离 (Chebyshev Distance)："></a>3 切比雪夫距离 (Chebyshev Distance)：</h2><p>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻8个方格中的任意一个。国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？这个距离就叫切比雪夫距离。</p><p><img src="https://s1.ax1x.com/2020/03/19/8sBpu9.png" alt="8sBpu9.png"></p><p><img src="https://s1.ax1x.com/2020/03/19/8sBCH1.png" alt="8sBCH1.png"></p><p>XY轴的最大值</p><h2 id="4-闵可夫斯基距离-Minkowski-Distance-："><a href="#4-闵可夫斯基距离-Minkowski-Distance-：" class="headerlink" title="4 闵可夫斯基距离(Minkowski Distance)："></a>4 闵可夫斯基距离(Minkowski Distance)：</h2><p>闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。</p><p>两个n维变量a(x11,x12,…,x1n)与b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：</p><p><img src="https://s1.ax1x.com/2020/03/19/8sBwEq.png" alt="8sBwEq.png"></p><p>其中p是一个变参数：</p><p>当p=1时，就是曼哈顿距离；</p><p>当p=2时，就是欧氏距离；</p><p>当p→∞时，就是切比雪夫距离。(相当于p次方的时候把小的值都忽略了)</p><p>根据p的不同，闵氏距离可以表示某一类/种的距离。</p><p><strong>小结：</strong></p><p>1 闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点:</p><p>e.g. 二维样本(身高[单位:cm],体重[单位:kg]),现有三个样本：a(180,50)，b(190,50)，c(180,60)。</p><p>a与b的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c的闵氏距离。但实际上身高的10cm并不能和体重的10kg划等号。</p><p><strong>2 闵氏距离的缺点：</strong></p><p> <strong>(1)将各个分量的量纲(scale)，也就是“单位”相同的看待了;</strong></p><p> <strong>(2)未考虑各个分量的分布（期望，方差等）可能是不同的。</strong></p><h2 id="5-标准化欧氏距离-Standardized-EuclideanDistance-："><a href="#5-标准化欧氏距离-Standardized-EuclideanDistance-：" class="headerlink" title="5 标准化欧氏距离 (Standardized EuclideanDistance)："></a>5 标准化欧氏距离 (Standardized EuclideanDistance)：</h2><p>标准化欧氏距离是针对欧氏距离的缺点而作的一种改进。</p><p>思路：既然数据各维分量的分布不一样，那先将各个分量都“标准化”到均值、方差相等。假设样本集X的均值(mean)为m，标准差(standard deviation)为s，X的“标准化变量”表示为：</p><p><img src="https://s1.ax1x.com/2020/03/19/8sDMM4.png" alt="8sDMM4.png"></p><p>如果将方差的倒数看成一个权重，也可称之为加权欧氏距离(Weighted Euclidean distance)。</p><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X=[[1,1],[2,2],[3,3],[4,4]];（假设两个分量的标准差分别为0.5和1）</span><br><span class="line">经计算得:</span><br><span class="line">d =   2.2361    4.4721    6.7082    2.2361    4.4721    2.2361</span><br></pre></td></tr></table></figure><h2 id="6-余弦距离-Cosine-Distance"><a href="#6-余弦距离-Cosine-Distance" class="headerlink" title="6 余弦距离(Cosine Distance)"></a>6 余弦距离(Cosine Distance)</h2><p>几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异。</p><ul><li>二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：</li></ul><p><img src="https://s1.ax1x.com/2020/03/19/8srTnH.png" alt="8srTnH.png"></p><ul><li>两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦为：</li></ul><p><img src="https://s1.ax1x.com/2020/03/19/8srIje.png" alt="8srIje.png"></p><p>即：</p><p><img src="https://s1.ax1x.com/2020/03/19/8sr5cD.png" alt="8sr5cD.png"></p><p>夹角余弦取值范围为[-1,1]。余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大。当两个向量的方向重合时余弦取最大值1，当两个向量的方向完全相反余弦取最小值-1。</p><p>举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X=[[1,1],[1,2],[2,5],[1,-4]]</span><br><span class="line">经计算得:</span><br><span class="line">d =   0.9487    0.9191   -0.5145    0.9965   -0.7593   -0.8107</span><br></pre></td></tr></table></figure><h2 id="7-杰卡德距离-Jaccard-Distance-："><a href="#7-杰卡德距离-Jaccard-Distance-：" class="headerlink" title="7 杰卡德距离(Jaccard Distance)："></a><strong>7 杰卡德距离(Jaccard Distance)：</strong></h2><p>杰卡德相似系数(Jaccard similarity coefficient)：两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示：<br><img src="https://s1.ax1x.com/2020/03/19/8sslU1.png" alt="8sslU1.png"></p><p>杰卡德距离(Jaccard Distance)：与杰卡德相似系数相反，用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度：</p><p><img src="https://s1.ax1x.com/2020/03/19/8ss8C6.png" alt="8ss8C6.png">举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=[[1,1,0][1,-1,0],[-1,1,0]]</span><br><span class="line">注：以下计算中，把杰卡德距离定义为不同的维度的个数占“非全零维度”的**比例**</span><br><span class="line">经计算得:</span><br><span class="line">d =   0.5000    0.5000    1.0000</span><br></pre></td></tr></table></figure><h1 id="1-4-k值的选择"><a href="#1-4-k值的选择" class="headerlink" title="1.4 k值的选择"></a>1.4 k值的选择</h1><p><strong>K值过小</strong>：</p><p> 容易受到异常点的影响</p><p><strong>k值过大：</strong></p><p> 受到样本均衡的问题</p><hr><p><strong>K值选择问题，李航博士的一书「统计学习方法」上所说：</strong></p><p>1) 选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，<strong>K值的减小就意味着整体模型变得复杂，容易发生过拟合；</strong></p><p>2) 选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，<strong>与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</strong></p><p>3) K=N（N为训练样本个数），则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。</p><p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是把训练数据在分成两组:训练集和验证集）来选择最优的K值。对这个简单的分类器进行泛化，用核方法把这个线性模型扩展到非线性的情况，具体方法是把低维数据集映射到高维特征空间。</p><hr><p><strong>近似误差</strong>：对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。</p><p><strong>估计误差</strong>：可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。</p><h1 id="1-5-kd树"><a href="#1-5-kd树" class="headerlink" title="1.5 kd树"></a>1.5 kd树</h1><p><strong>问题导入：</strong></p><p>实现k近邻法时，<strong>主要考虑的问题是如何对训练数据进行快速k近邻搜索。</strong></p><p>这在特征空间的维数大及训练数据容量大时尤其必要。</p><p><strong>k近邻法最简单的实现是线性扫描（穷举搜索），即要计算输入实例与每一个训练实例的距离。计算并存储好以后，再查找K近邻。</strong>当训练集很大时，计算非常耗时。</p><p>为了提高kNN搜索的效率，可以考虑使用特殊的结构存储训练数据，以减小计算距离的次数。</p><hr><h2 id="1-kd树简介"><a href="#1-kd树简介" class="headerlink" title="1 kd树简介"></a>1 kd树简介</h2><h3 id="1-1-什么是kd树"><a href="#1-1-什么是kd树" class="headerlink" title="1.1 什么是kd树"></a>1.1 什么是kd树</h3><p>根据<strong>KNN</strong>每次需要预测一个点时，我们都需要计算训练数据集里每个点到这个点的距离，然后选出距离最近的k个点进行投票。<strong>当数据集很大时，这个计算成本非常高，针对N个样本，D个特征的数据集，其算法复杂度为O（DN^2）</strong>。</p><p><strong>kd树</strong>：为了避免每次都重新计算一遍距离，算法会把距离信息保存在一棵树里，这样在计算之前从树里查询距离信息，尽量避免重新计算。其基本原理是，<strong>如果A和B距离很远，B和C距离很近，那么A和C的距离也很远</strong>。有了这个信息，就可以在合适的时候跳过距离远的点。</p><p>这样优化后的算法复杂度可降低到<strong>O（DNlog（N））</strong>。感兴趣的读者可参阅论文：Bentley，J.L.，Communications of the ACM（1975）。</p><p>1989年，另外一种称为<strong>Ball Tree</strong>的算法，在kd Tree的基础上对性能进一步进行了优化。感兴趣的读者可以搜索<strong>Five balltree construction algorithms</strong>来了解详细的算法信息。</p><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><p><img src="https://s1.ax1x.com/2020/03/19/8yJjkF.png" alt="8yJjkF.png"></p><p>黄色的点作为根节点，上面的点归左子树，下面的点归右子树，接下来再不断地划分，分割的那条线叫做分割超平面（splitting hyperplane），在一维中是一个点，二维中是线，三维的是面。</p><p><img src="https://s1.ax1x.com/2020/03/19/8yYQnP.png" alt="8yYQnP.png"></p><p>黄色节点就是Root节点，下一层是红色，再下一层是绿色，再下一层是蓝色。<img src="https://s1.ax1x.com/2020/03/19/8yYl0f.png" alt="8yYl0f.png"></p><p><strong>1.树的建立；</strong></p><p><strong>2.最近邻域搜索（Nearest-Neighbor Lookup）</strong></p><p>kd树(K-dimension tree)是<strong>一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</strong>kd树是一种二叉树，表示对k维空间的一个划分，<strong>构造kd树相当于不断地用垂直于坐标轴的超平面将K维空间切分，构成一系列的K维超矩形区域</strong>。kd树的每个结点对应于一个k维超矩形区域。<strong>利用kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。</strong></p><p>类比“二分查找”：给出一组数据：[9 1 4 7 2 5 0 3 8]，要查找8。如果挨个查找（线性扫描），那么将会把数据集都遍历一遍。而如果排一下序那数据集就变成了：[0 1 2 3 4 5 6 7 8 9]，按前一种方式我们进行了很多没有必要的查找，现在如果我们以5为分界点，那么数据集就被划分为了左右两个“簇” [0 1 2 3 4]和[6 7 8 9]。</p><p>因此，根本就没有必要进入第一个簇，可以直接进入第二个簇进行查找。把二分查找中的数据点换成k维数据点，这样的划分就变成了用超平面对k维空间的划分。空间划分就是对数据点进行分类，“挨得近”的数据点就在一个空间里面。</p><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><p>（1）构造根结点，使根结点对应于K维空间中包含所有实例点的超矩形区域；</p><p>（2）通过递归的方法，不断地对k维空间进行切分，生成子结点。在超矩形区域上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。</p><p>（3）上述过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</p><p>（4）通常，循环的选择坐标轴对空间切分，选择训练实例点在坐标轴上的中位数为切分点，这样得到的kd树是平衡的（平衡二叉树：它是一棵空树，或其左子树和右子树的深度之差的绝对值不超过1，且它的左子树和右子树都是平衡二叉树）。</p><p>KD树中每个节点是一个向量，和二叉树按照数的大小划分不同的是，KD树每层需要选定向量中的某一维，然后根据这一维按左小右大的方式划分数据。在构建KD树时，关键需要解决2个问题：</p><p><strong>（1）选择向量的哪一维进行划分；</strong></p><p><strong>（2）如何划分数据；</strong></p><p>第一个问题简单的解决方法可以是随机选择某一维或按顺序选择，但是<strong>更好的方法应该是在数据比较分散的那一维进行划分（分散的程度可以根据方差来衡量）</strong>。好的划分方法可以使构建的树比较平衡，可以每次选择中位数来进行划分，这样问题2也得到了解决。</p><h4 id="2-2-1-查找点-2-4-5"><a href="#2-2-1-查找点-2-4-5" class="headerlink" title="2.2.1 查找点(2,4.5)"></a>2.2.1 查找点(2,4.5)</h4><ul><li><p>1.先构建出树(按照x–&gt;y–&gt;x–&gt;y…的顺序构造平衡二叉树)</p></li><li><p>2.对查找点在树上进行判断，并记录下经过的点(search_path)，最后一个点称之为 <strong>当前最佳节点</strong></p></li><li><p>3.以当前最佳节点到查找点之间的距离为半径画圆，把圆内节点的子树加入到search_path中，—–<strong>回溯</strong></p></li><li><p>4.直到search_path内的点为空时，找到最小的dist</p></li></ul><p><img src="https://s1.ax1x.com/2020/03/19/8ydSLn.png" alt="8ydSLn.png"></p><p>在(7,2)处测试到达(5,4)，在(5,4)处测试到达(4,7)【优先选择在本域搜索】，然后search_path中的结点为&lt;(7,2),(5,4), (4,7)&gt;，从search_path中取出(4,7)作为当前最佳结点nearest, dist为3.202；</p><p>然后回溯至(5,4)，以(2,4.5)为圆心，以dist=3.202为半径画一个圆与超平面y=4相交，所以需要跳到(5,4)的左子空间去搜索。所以要将(2,3)加入到search_path中，现在search_path中的结点为&lt;(7,2),(2, 3)&gt;；另外，(5,4)与(2,4.5)的距离为3.04 &lt; dist = 3.202，所以将(5,4)赋给nearest，并且dist=3.04。</p><p>回溯至(2,3)，(2,3)是叶子节点，直接平判断(2,3)是否离(2,4.5)更近，计算得到距离为1.5，所以nearest更新为(2,3)，dist更新为(1.5)</p><p>回溯至(7,2)，同理，以(2,4.5)为圆心，以dist=1.5为半径画一个圆并不和超平面x=7相交, 所以不用跳到结点(7,2)的右子空间去搜索。</p><p>至此，search_path为空，结束整个搜索，返回nearest(2,3)作为(2,4.5)的最近邻点，最近距离为1.5。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>首先<strong>通过二叉树搜索</strong>（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，大于就进入右子树分支直到叶子结点），<strong>顺着“搜索路径”很快能找到最近邻的近似点</strong>，也就是与待查询点处于同一个子空间的叶子结点；</p><p>然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。</p><p>重复这个过程直到搜索路径为空。</p><h1 id="1-6-案例：鸢尾花种类预测–数据集介绍"><a href="#1-6-案例：鸢尾花种类预测–数据集介绍" class="headerlink" title="1.6 案例：鸢尾花种类预测–数据集介绍"></a>1.6 案例：鸢尾花种类预测–数据集介绍</h1><p>本实验介绍了使用Python进行机器学习的一些基本概念。 在本案例中，将使用K-Nearest Neighbor（KNN）算法对鸢尾花的种类进行分类，并测量花的特征。</p><p>本案例目的：</p><ol><li>遵循并理解完整的机器学习过程</li><li>对机器学习原理和相关术语有基本的了解。</li><li>了解评估机器学习模型的基本过程。</li></ol><h2 id="1-案例：鸢尾花种类预测"><a href="#1-案例：鸢尾花种类预测" class="headerlink" title="1 案例：鸢尾花种类预测"></a>1 案例：鸢尾花种类预测</h2><p>Iris数据集是常用的分类实验数据集，由Fisher, 1936收集整理。Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。关于数据集的具体介绍：</p><p><img src="https://s1.ax1x.com/2020/03/19/8yBawR.png" alt="8yBawR.png"></p><h2 id="2-scikit-learn中数据集介绍"><a href="#2-scikit-learn中数据集介绍" class="headerlink" title="2 scikit-learn中数据集介绍"></a>2 scikit-learn中数据集介绍</h2><h3 id="2-1-scikit-learn数据集API介绍"><a href="#2-1-scikit-learn数据集API介绍" class="headerlink" title="2.1 scikit-learn数据集API介绍"></a>2.1 scikit-learn数据集API介绍</h3><ul><li>sklearn.datasets<ul><li>加载获取流行数据集</li><li>datasets.load_*()<ul><li>获取小规模数据集，数据包含在datasets里</li></ul></li><li>datasets.fetch_*(data_home=None)<ul><li>获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~/scikit_learn_data/</li></ul></li></ul></li></ul><h4 id="2-1-1-sklearn小数据集"><a href="#2-1-1-sklearn小数据集" class="headerlink" title="2.1.1 sklearn小数据集"></a>2.1.1 sklearn小数据集</h4><ul><li><p>sklearn.datasets.load_iris()</p><p>加载并返回鸢尾花数据集</p></li></ul><h4 id="2-1-2-sklearn大数据集"><a href="#2-1-2-sklearn大数据集" class="headerlink" title="2.1.2 sklearn大数据集"></a>2.1.2 sklearn大数据集</h4><ul><li>sklearn.datasets.fetch_20newsgroups(data_home=None,subset=‘train’)<ul><li>subset：’train’或者’test’，’all’，可选，选择要加载的数据集。</li><li>训练集的“训练”，测试集的“测试”，两者的“全部”</li></ul></li></ul><h3 id="2-2-sklearn数据集返回值介绍"><a href="#2-2-sklearn数据集返回值介绍" class="headerlink" title="2.2 sklearn数据集返回值介绍"></a>2.2 sklearn数据集返回值介绍</h3><ul><li>load和fetch返回的数据类型datasets.base.Bunch(字典格式)<ul><li>data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组</li><li>target：标签数组，是 n_samples 的一维 numpy.ndarray 数组</li><li>DESCR：数据描述</li><li>feature_names：特征名,新闻数据，手写数字、回归数据集没有</li><li>target_names：标签名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># 获取鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">print(<span class="string">"鸢尾花数据集的返回值：\n"</span>, iris)</span><br><span class="line"><span class="comment"># 返回值是一个继承自字典的Bench</span></span><br><span class="line">print(<span class="string">"鸢尾花的特征值:\n"</span>, iris[<span class="string">"data"</span>])</span><br><span class="line">print(<span class="string">"鸢尾花的目标值：\n"</span>, iris.target)</span><br><span class="line">print(<span class="string">"鸢尾花特征的名字：\n"</span>, iris.feature_names)</span><br><span class="line">print(<span class="string">"鸢尾花目标值的名字：\n"</span>, iris.target_names)</span><br><span class="line">print(<span class="string">"鸢尾花的描述：\n"</span>, iris.DESCR)</span><br></pre></td></tr></table></figure><h3 id="2-3-查看数据分布"><a href="#2-3-查看数据分布" class="headerlink" title="2.3 查看数据分布"></a>2.3 查看数据分布</h3><p>通过创建一些图，以查看不同类别是如何通过特征来区分的。 在理想情况下，标签类将由一个或多个特征对完美分隔。 在现实世界中，这种理想情况很少会发生。</p><ul><li>seaborn介绍<ul><li>Seaborn 是基于 Matplotlib 核心库进行了更高级的 API 封装，可以让你轻松地画出更漂亮的图形。而 Seaborn 的漂亮主要体现在配色更加舒服、以及图形元素的样式更加细腻。</li><li>安装 pip3 install seaborn</li><li>seaborn.lmplot() 是一个非常有用的方法，它会在绘制二维散点图时，自动完成回归拟合<ul><li>sns.lmplot() 里的 x, y 分别代表横纵坐标的列名,</li><li>data= 是关联到数据集,</li><li>hue=*代表按照 species即花的类别分类显示,</li><li>fit_reg=是否进行线性拟合。</li></ul></li><li><a href="http://seaborn.pydata.org/" target="_blank" rel="noopener">参考链接: api链接</a></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline  </span><br><span class="line"><span class="comment"># 内嵌绘图</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把数据转换成dataframe的格式</span></span><br><span class="line">iris_d = pd.DataFrame(iris[<span class="string">'data'</span>], columns = [<span class="string">'Sepal_Length'</span>, <span class="string">'Sepal_Width'</span>, <span class="string">'Petal_Length'</span>, <span class="string">'Petal_Width'</span>])</span><br><span class="line">iris_d[<span class="string">'Species'</span>] = iris.target</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_iris</span><span class="params">(iris, col1, col2)</span>:</span></span><br><span class="line">    sns.lmplot(x = col1, y = col2, data = iris, hue = <span class="string">"Species"</span>, fit_reg = <span class="literal">False</span>)</span><br><span class="line">    plt.xlabel(col1)</span><br><span class="line">    plt.ylabel(col2)</span><br><span class="line">    plt.title(<span class="string">'鸢尾花种类分布图'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">plot_iris(iris_d, <span class="string">'Petal_Width'</span>, <span class="string">'Sepal_Length'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-数据集的划分"><a href="#2-4-数据集的划分" class="headerlink" title="2.4 数据集的划分"></a>2.4 数据集的划分</h3><p>机器学习一般的数据集会划分为两个部分：</p><ul><li>训练数据：用于训练，<strong>构建模型</strong></li><li>测试数据：在模型检验时使用，用于<strong>评估模型是否有效</strong></li></ul><p>划分比例：</p><ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 25%</li></ul><p><strong>数据集划分api</strong></p><ul><li>sklearn.model_selection.train_test_split(arrays, *options)<ul><li>x 数据集的特征值–对应于表示这个花的一些数据参数</li><li>y 数据集的标签值–对应于表示这个是什么种类的花</li><li>test_size 测试集的大小，一般为float</li><li>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。(这是一个可以保证你在random_state设置相同参数，得到一样的结果，至于设置的值不同，只是代表随机选取的数不一样)</li><li>return 测试集特征训练集特征值值，训练标签，测试标签(默认随机取)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 1、获取鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="comment"># 对鸢尾花数据集进行分割</span></span><br><span class="line"><span class="comment"># 训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">22</span>)</span><br><span class="line">print(<span class="string">"x_train:\n"</span>, x_train.shape)</span><br><span class="line"><span class="comment"># 随机数种子</span></span><br><span class="line">x_train1, x_test1, y_train1, y_test1 = train_test_split(iris.data, iris.target, random_state=<span class="number">6</span>)</span><br><span class="line">x_train2, x_test2, y_train2, y_test2 = train_test_split(iris.data, iris.target, random_state=<span class="number">6</span>)</span><br><span class="line">print(<span class="string">"如果随机数种子不一致：\n"</span>, x_train == x_train1)</span><br><span class="line">print(<span class="string">"如果随机数种子一致：\n"</span>, x_train1 == x_train2)</span><br></pre></td></tr></table></figure><h1 id="1-7-特征工程-特征预处理"><a href="#1-7-特征工程-特征预处理" class="headerlink" title="1.7 特征工程-特征预处理"></a>1.7 特征工程-特征预处理</h1><h2 id="1-什么是特征预处理-类似于标准化-归一化，保证数据的量纲"><a href="#1-什么是特征预处理-类似于标准化-归一化，保证数据的量纲" class="headerlink" title="1 什么是特征预处理(类似于标准化/归一化，保证数据的量纲)"></a>1 什么是特征预处理(类似于标准化/归一化，保证数据的量纲)</h2><h3 id="1-1-特征预处理定义"><a href="#1-1-特征预处理定义" class="headerlink" title="1.1 特征预处理定义"></a>1.1 特征预处理定义</h3><blockquote><h5 id="scikit-learn的解释"><a href="#scikit-learn的解释" class="headerlink" title="scikit-learn的解释"></a>scikit-learn的解释</h5><p>provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.</p></blockquote><p>翻译过来：通过<strong>一些转换函数</strong>将特征数据<strong>转换成更加适合算法模型</strong>的特征数据过程</p><h4 id="为什么我们要进行归一化-标准化？"><a href="#为什么我们要进行归一化-标准化？" class="headerlink" title="为什么我们要进行归一化/标准化？"></a>为什么我们要进行归一化/标准化？</h4><ul><li><p>特征的<strong>单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级</strong>，<strong>容易影响（支配）目标结果</strong>，使得一些算法无法学习到其它的特征</p></li><li><p>归一化</p></li><li><p>标准化</p></li></ul><h3 id="1-3-特征预处理API"><a href="#1-3-特征预处理API" class="headerlink" title="1.3 特征预处理API"></a>1.3 特征预处理API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing</span><br></pre></td></tr></table></figure><p>#### </p><h2 id="2-归一化–特别容易受到异常点的影响xxxx"><a href="#2-归一化–特别容易受到异常点的影响xxxx" class="headerlink" title="2 归一化–特别容易受到异常点的影响xxxx"></a>2 归一化–特别容易受到异常点的影响xxxx</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>通过对原始数据进行变换把数据映射到(默认为[0,1])之间</p><h3 id="2-2-公式"><a href="#2-2-公式" class="headerlink" title="2.2 公式"></a>2.2 公式</h3><p><img src="https://s1.ax1x.com/2020/03/20/86L0ne.png" alt="86L0ne.png"></p><blockquote><p>作用于每一列，max为一列的最大值，min为一列的最小值,那么X’’为最终结果，mx，mi分别为指定区间值默认mx为1,mi为0</p></blockquote><p>那么怎么理解这个过程呢？我们通过一个例子</p><h3 id><a href="#" class="headerlink" title></a><img src="https://s1.ax1x.com/2020/03/20/86L4BQ.png" alt="86L4BQ.png"></h3><h3 id="2-3-API–一步帮你完成"><a href="#2-3-API–一步帮你完成" class="headerlink" title="2.3 API–一步帮你完成"></a>2.3 API–一步帮你完成</h3><ul><li>sklearn.preprocessing.MinMaxScaler (feature_range=(0,1)… )<ul><li>MinMaxScalar.fit_transform(X)<ul><li>X:numpy array格式的数据[n_samples,n_features]</li></ul></li><li>返回值：转换后的形状相同的array</li></ul></li></ul><h3 id="2-4-数据计算"><a href="#2-4-数据计算" class="headerlink" title="2.4 数据计算"></a>2.4 数据计算</h3><p>我们对以下数据进行运算，在dating.txt中。保存的就是之前的约会对象数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">milage,Liters,Consumtime,target</span><br><span class="line"><span class="number">40920</span>,<span class="number">8.326976</span>,<span class="number">0.953952</span>,<span class="number">3</span></span><br><span class="line"><span class="number">14488</span>,<span class="number">7.153469</span>,<span class="number">1.673904</span>,<span class="number">2</span></span><br><span class="line"><span class="number">26052</span>,<span class="number">1.441871</span>,<span class="number">0.805124</span>,<span class="number">1</span></span><br><span class="line"><span class="number">75136</span>,<span class="number">13.147394</span>,<span class="number">0.428964</span>,<span class="number">1</span></span><br><span class="line"><span class="number">38344</span>,<span class="number">1.669788</span>,<span class="number">0.134296</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>分析</p><ul><li><p>1、实例化MinMaxScalar</p></li><li><p>2、通过fit_transform转换</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minmax_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归一化演示</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = pd.read_csv(<span class="string">"dating.txt"</span>)</span><br><span class="line">    print(data)</span><br><span class="line">    <span class="comment"># 1、实例化一个转换器类</span></span><br><span class="line">    transfer = MinMaxScaler(feature_range=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># 2、调用fit_transform</span></span><br><span class="line">    data = transfer.fit_transform(data[[<span class="string">'milage'</span>,<span class="string">'Liters'</span>,<span class="string">'Consumtime'</span>]])</span><br><span class="line">    print(<span class="string">"最小值最大值归一化处理的结果：\n"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     milage     Liters  Consumtime  target</span><br><span class="line"><span class="number">0</span>     <span class="number">40920</span>   <span class="number">8.326976</span>    <span class="number">0.953952</span>       <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">14488</span>   <span class="number">7.153469</span>    <span class="number">1.673904</span>       <span class="number">2</span></span><br><span class="line"><span class="number">2</span>     <span class="number">26052</span>   <span class="number">1.441871</span>    <span class="number">0.805124</span>       <span class="number">1</span></span><br><span class="line"><span class="number">3</span>     <span class="number">75136</span>  <span class="number">13.147394</span>    <span class="number">0.428964</span>       <span class="number">1</span></span><br><span class="line">..      ...        ...         ...     ...</span><br><span class="line"><span class="number">998</span>   <span class="number">48111</span>   <span class="number">9.134528</span>    <span class="number">0.728045</span>       <span class="number">3</span></span><br><span class="line"><span class="number">999</span>   <span class="number">43757</span>   <span class="number">7.882601</span>    <span class="number">1.332446</span>       <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1000</span> rows x <span class="number">4</span> columns]</span><br><span class="line">最小值最大值归一化处理的结果：</span><br><span class="line"> [[ <span class="number">2.44832535</span>  <span class="number">2.39805139</span>  <span class="number">2.56233353</span>]</span><br><span class="line"> [ <span class="number">2.15873259</span>  <span class="number">2.34195467</span>  <span class="number">2.98724416</span>]</span><br><span class="line"> [ <span class="number">2.28542943</span>  <span class="number">2.06892523</span>  <span class="number">2.47449629</span>]</span><br><span class="line"> ..., </span><br><span class="line"> [ <span class="number">2.29115949</span>  <span class="number">2.50910294</span>  <span class="number">2.51079493</span>]</span><br><span class="line"> [ <span class="number">2.52711097</span>  <span class="number">2.43665451</span>  <span class="number">2.4290048</span> ]</span><br><span class="line"> [ <span class="number">2.47940793</span>  <span class="number">2.3768091</span>   <span class="number">2.78571804</span>]]</span><br></pre></td></tr></table></figure><h3 id="2-5-归一化总结"><a href="#2-5-归一化总结" class="headerlink" title="2.5 归一化总结"></a>2.5 归一化总结</h3><p>注意最大值最小值是变化的，另外，最大值与最小值非常容易受异常点影响，<strong>所以这种方法鲁棒性较差，只适合传统精确小数据场景。</strong></p><p>怎么办？</p><h2 id="3-标准化"><a href="#3-标准化" class="headerlink" title="3 标准化"></a>3 标准化</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内</p><h3 id="3-2-公式"><a href="#3-2-公式" class="headerlink" title="3.2 公式"></a>3.2 公式</h3><p><img src="https://s1.ax1x.com/2020/03/20/86xGzq.png" alt="86xGzq.png"></p><blockquote><p>作用于每一列，mean为平均值，σ为标准差</p></blockquote><p>所以回到刚才异常点的地方，我们再来看看标准化</p><ul><li>对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变</li><li>对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。</li></ul><h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><ul><li>sklearn.preprocessing.StandardScaler( )<ul><li>处理之后每列来说所有数据都聚集在均值0附近标准差差为1</li><li>StandardScaler.fit_transform(X)<ul><li>X:numpy array格式的数据[n_samples,n_features]</li></ul></li><li>返回值：转换后的形状相同的array</li></ul></li></ul><h3 id="3-4-数据计算"><a href="#3-4-数据计算" class="headerlink" title="3.4 数据计算"></a>3.4 数据计算</h3><p>同样对上面的数据进行处理</p><ul><li>分析</li></ul><p>1、实例化StandardScaler</p><p>2、通过fit_transform转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stand_demo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    标准化演示</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = pd.read_csv(<span class="string">"dating.txt"</span>)</span><br><span class="line">    print(data)</span><br><span class="line">    <span class="comment"># 1、实例化一个转换器类</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    <span class="comment"># 2、调用fit_transform</span></span><br><span class="line">    data = transfer.fit_transform(data[[<span class="string">'milage'</span>,<span class="string">'Liters'</span>,<span class="string">'Consumtime'</span>]])</span><br><span class="line">    print(<span class="string">"标准化的结果:\n"</span>, data)</span><br><span class="line">    print(<span class="string">"每一列特征的平均值：\n"</span>, transfer.mean_)</span><br><span class="line">    print(<span class="string">"每一列特征的方差：\n"</span>, transfer.var_)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     milage     Liters  Consumtime  target</span><br><span class="line"><span class="number">0</span>     <span class="number">40920</span>   <span class="number">8.326976</span>    <span class="number">0.953952</span>       <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">14488</span>   <span class="number">7.153469</span>    <span class="number">1.673904</span>       <span class="number">2</span></span><br><span class="line"><span class="number">2</span>     <span class="number">26052</span>   <span class="number">1.441871</span>    <span class="number">0.805124</span>       <span class="number">1</span></span><br><span class="line">..      ...        ...         ...     ...</span><br><span class="line"><span class="number">997</span>   <span class="number">26575</span>  <span class="number">10.650102</span>    <span class="number">0.866627</span>       <span class="number">3</span></span><br><span class="line"><span class="number">998</span>   <span class="number">48111</span>   <span class="number">9.134528</span>    <span class="number">0.728045</span>       <span class="number">3</span></span><br><span class="line"><span class="number">999</span>   <span class="number">43757</span>   <span class="number">7.882601</span>    <span class="number">1.332446</span>       <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1000</span> rows x <span class="number">4</span> columns]</span><br><span class="line">标准化的结果:</span><br><span class="line"> [[ <span class="number">0.33193158</span>  <span class="number">0.41660188</span>  <span class="number">0.24523407</span>]</span><br><span class="line"> [<span class="number">-0.87247784</span>  <span class="number">0.13992897</span>  <span class="number">1.69385734</span>]</span><br><span class="line"> [<span class="number">-0.34554872</span> <span class="number">-1.20667094</span> <span class="number">-0.05422437</span>]</span><br><span class="line"> ..., </span><br><span class="line"> [<span class="number">-0.32171752</span>  <span class="number">0.96431572</span>  <span class="number">0.06952649</span>]</span><br><span class="line"> [ <span class="number">0.65959911</span>  <span class="number">0.60699509</span> <span class="number">-0.20931587</span>]</span><br><span class="line"> [ <span class="number">0.46120328</span>  <span class="number">0.31183342</span>  <span class="number">1.00680598</span>]]</span><br><span class="line">每一列特征的平均值：</span><br><span class="line"> [  <span class="number">3.36354210e+04</span>   <span class="number">6.55996083e+00</span>   <span class="number">8.32072997e-01</span>]</span><br><span class="line">每一列特征的方差：</span><br><span class="line"> [  <span class="number">4.81628039e+08</span>   <span class="number">1.79902874e+01</span>   <span class="number">2.46999554e-01</span>]</span><br></pre></td></tr></table></figure><h3 id="3-5-标准化总结"><a href="#3-5-标准化总结" class="headerlink" title="3.5 标准化总结"></a>3.5 标准化总结</h3><p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。</p><h1 id="1-8-案例：鸢尾花种类预测—流程实现"><a href="#1-8-案例：鸢尾花种类预测—流程实现" class="headerlink" title="1.8 案例：鸢尾花种类预测—流程实现"></a>1.8 案例：鸢尾花种类预测—流程实现</h1><h2 id="1-再识K-近邻算法API"><a href="#1-再识K-近邻算法API" class="headerlink" title="1 再识K-近邻算法API"></a>1 再识K-近邻算法API</h2><ul><li>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)<ul><li>n_neighbors：<ul><li>int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li></ul></li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}<ul><li>快速k近邻搜索算法，默认参数为auto，可以理解为算法自己决定合适的搜索算法。除此之外，用户也可以自己指定搜索算法ball_tree、kd_tree、brute方法进行搜索，<ul><li>brute是蛮力搜索，也就是线性扫描，当训练集很大时，计算非常耗时。</li><li>kd_tree，构造kd树存储数据以便对其进行快速检索的树形数据结构，kd树也就是数据结构中的二叉树。以中值切分构造的树，每个结点是一个超矩形，在维数小于20时效率高。</li><li>ball tree是为了克服kd树高纬失效而发明的，其构造过程是以质心C和半径r分割样本空间，每个节点是一个超球体。</li></ul></li></ul></li></ul></li></ul><h2 id="2-案例：鸢尾花种类预测"><a href="#2-案例：鸢尾花种类预测" class="headerlink" title="2 案例：鸢尾花种类预测"></a>2 案例：鸢尾花种类预测</h2><h3 id="2-1-数据集介绍"><a href="#2-1-数据集介绍" class="headerlink" title="2.1 数据集介绍"></a>2.1 数据集介绍</h3><p>Iris数据集是常用的分类实验数据集，由Fisher, 1936收集整理。Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。关于数据集的具体介绍：</p><p><img src="https://s1.ax1x.com/2020/03/20/86z6hj.png" alt="86z6hj.png"></p><h3 id="2-2-步骤分析"><a href="#2-2-步骤分析" class="headerlink" title="2.2 步骤分析"></a>2.2 步骤分析</h3><ul><li>1.获取数据集</li><li>2.数据基本处理</li><li>3.特征工程</li><li>4.机器学习(模型训练)</li><li>5.模型评估</li></ul><h3 id="2-3-代码过程"><a href="#2-3-代码过程" class="headerlink" title="2.3 代码过程"></a>2.3 代码过程</h3><ul><li>导入模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br></pre></td></tr></table></figure><ul><li>先从sklearn当中获取数据集，然后进行数据集的分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.数据基本处理</span></span><br><span class="line"><span class="comment"># x_train,x_test,y_train,y_test为训练集特征值、测试集特征值、训练集目标值、测试集目标值</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="number">0.2</span>, random_state=<span class="number">22</span>)</span><br></pre></td></tr></table></figure><ul><li>进行数据标准化<ul><li>特征值的标准化</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3、特征工程：标准化</span></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br></pre></td></tr></table></figure><ul><li>模型进行训练预测</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4、机器学习(模型训练)</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">9</span>)</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"><span class="comment"># 5、模型评估</span></span><br><span class="line"><span class="comment"># 方法1：比对真实值和预测值</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line">print(<span class="string">"预测结果为:\n"</span>, y_predict)</span><br><span class="line">print(<span class="string">"比对真实值和预测值：\n"</span>, y_predict == y_test)</span><br><span class="line"><span class="comment"># 方法2：直接计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line">print(<span class="string">"准确率为：\n"</span>, score)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos硬盘扩容到根目录</title>
      <link href="/2020/03/14/centos%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9%E5%88%B0%E6%A0%B9%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/03/14/centos%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9%E5%88%B0%E6%A0%B9%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>centos6.4根目录扩容</p><h2 id="几个查询磁盘-分区的命令"><a href="#几个查询磁盘-分区的命令" class="headerlink" title="几个查询磁盘/分区的命令"></a>几个查询磁盘/分区的命令</h2><p>以下均在root用户中进行</p><p>df -Th</p><p>fdisk -l</p><h2 id="1-先把根目录的分区变成最后一个"><a href="#1-先把根目录的分区变成最后一个" class="headerlink" title="1.先把根目录的分区变成最后一个"></a>1.先把根目录的分区变成最后一个</h2><p>如果有交换空间就<code>swapoff  /dev/sda3(交换空间)</code></p><h2 id="2-删除所有的分区，并重新创建分区"><a href="#2-删除所有的分区，并重新创建分区" class="headerlink" title="2.删除所有的分区，并重新创建分区"></a>2.删除所有的分区，并重新创建分区</h2><p><code>fdisk /dev/sda</code></p><p>按照提示进行操作</p><h2 id="3-reboot"><a href="#3-reboot" class="headerlink" title="3.reboot"></a>3.reboot</h2><h2 id="4-resize2fs-dev-sda2"><a href="#4-resize2fs-dev-sda2" class="headerlink" title="4.resize2fs /dev/sda2"></a>4.resize2fs /dev/sda2</h2><p>完结！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用PySpark分析空气质量</title>
      <link href="/2020/03/12/%E4%BD%BF%E7%94%A8pyspark%E5%88%86%E6%9E%90%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/"/>
      <url>/2020/03/12/%E4%BD%BF%E7%94%A8pyspark%E5%88%86%E6%9E%90%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="1-数据来源-http-stateair-net-web-historical-1-1-html"><a href="#1-数据来源-http-stateair-net-web-historical-1-1-html" class="headerlink" title="1. 数据来源: http://stateair.net/web/historical/1/1.html"></a>1. 数据来源: <a href="http://stateair.net/web/historical/1/1.html" target="_blank" rel="noopener">http://stateair.net/web/historical/1/1.html</a></h3><h3 id="2-根据北京的数据进行统计分析"><a href="#2-根据北京的数据进行统计分析" class="headerlink" title="2. 根据北京的数据进行统计分析"></a>2. 根据北京的数据进行统计分析</h3><table><thead><tr><th align="right">空气质量指数(PM2.5)</th><th align="left">健康建议</th></tr></thead><tbody><tr><td align="right">0-50</td><td align="left">健康</td></tr><tr><td align="right">51-100</td><td align="left">中等</td></tr><tr><td align="right">101-150</td><td align="left">对敏感人群不健康</td></tr><tr><td align="right">151-200</td><td align="left">危险</td></tr><tr><td align="right">201-300</td><td align="left">非常不健康</td></tr><tr><td align="right">301-500</td><td align="left">危险</td></tr><tr><td align="right">501-~</td><td align="left">报表</td></tr></tbody></table><h3 id="3-数据分析–-gt-es–-gt-kibana"><a href="#3-数据分析–-gt-es–-gt-kibana" class="headerlink" title="3.  数据分析–&gt;es–&gt;kibana"></a>3.  数据分析–&gt;es–&gt;kibana</h3><p>先进行数据分析:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> udf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">50</span> <span class="keyword">and</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"中等"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">150</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"对敏感人群不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">300</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"非常不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"危险"</span></span><br><span class="line">    <span class="keyword">elif</span> value &gt; <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"爆表"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spark = SparkSession.builder.appName(<span class="string">"project"</span>).getOrCreate()</span><br><span class="line">    data2017 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"file:///home/hadoop/data/Beijing_2017_HourlyPM25_created20170803.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line">    data2016 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"file:///home/hadoop/data/Beijing_2016_HourlyPM25_created20170201.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line">    data2015 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"file:///home/hadoop/data/Beijing_2015_HourlyPM25_created20160201.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line"></span><br><span class="line">    data2017.show()</span><br><span class="line">    data2016.show()</span><br><span class="line">    data2015.show()</span><br><span class="line"></span><br><span class="line">    grade_function_udf = udf(get_grade,StringType())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进来一个Value，出去一个Grade</span></span><br><span class="line">    group2017 = data2017.withColumn(<span class="string">"Grade"</span>,grade_function_udf(data2017[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line">    group2016 = data2016.withColumn(<span class="string">"Grade"</span>,grade_function_udf(data2016[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line">    group2015 = data2015.withColumn(<span class="string">"Grade"</span>,grade_function_udf(data2015[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line"></span><br><span class="line">    group2015.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>, group2015[<span class="string">'count'</span>] / data2015.count()).show()</span><br><span class="line">    group2016.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>, group2016[<span class="string">'count'</span>] / data2016.count()).show()</span><br><span class="line">    group2017.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>, group2017[<span class="string">'count'</span>] / data2017.count()).show()</span><br><span class="line"></span><br><span class="line">    group2017.show()</span><br><span class="line">    group2016.show()</span><br><span class="line">    group2015.show()</span><br><span class="line">    spark.stop()</span><br></pre></td></tr></table></figure><p>得到:</p><p><img src="https://s1.ax1x.com/2020/03/15/88Vb1H.png" alt="88Vb1H.png"></p><p>并在yarn上运行</p><ol><li>先在hadoop集群中创建新文件夹</li></ol><p><code>hadoop fs -mkdir -p /data/</code>（若已经有请删除<code>hadoop fs -rmr /data</code>）</p><ol start="2"><li>把2017、16、15 年的数据上传至hadoop</li></ol><p><code>hadoop fs -put Beijing* /data/</code>（参看是否上传成功<code>hadoop fs -ls /data</code>）</p><ol start="3"><li>把pycharm中的程序改成yarn中的程序</li></ol><p>再执行 <code>./spark-submit --master yarn ~/script/sparky.py</code></p><p>得到和上面一样的结果:</p><p><img src="https://s1.ax1x.com/2020/03/15/88VzAf.png" alt="88VzAf.png"></p><h3 id="es使用举例"><a href="#es使用举例" class="headerlink" title="es使用举例"></a>es使用举例</h3><p>先es中创建目录</p><p><code>curl -XPUT &#39;http://192.168.211.4:9200/imooc_es&#39;</code></p><p>查看数据</p><p><code>curl -XGET &#39;http://192.168.211.4:9200/_search&#39;</code></p><p>创建一个索引</p><p><code>curl -XPOST &#39;http://hadoop000:9200/imooc_es/student/1&#39; -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;name&quot;:&quot;imooc&quot;,&quot;age&quot;:5,&quot;interests&quot;:[&quot;Spark&quot;,&quot;Hadoop&quot;]    }&#39;</code></p><h3 id="es–-gt-kibana-注意这两个启动都在bin目录下"><a href="#es–-gt-kibana-注意这两个启动都在bin目录下" class="headerlink" title="es–&gt;kibana(注意这两个启动都在bin目录下)"></a>es–&gt;kibana(注意这两个启动都在bin目录下)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"中等"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">150</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"对敏感人群不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">300</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"非常不健康"</span></span><br><span class="line">    <span class="keyword">elif</span> value &lt;= <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"危险"</span></span><br><span class="line">    <span class="keyword">elif</span> value &gt; <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"爆表"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spark = SparkSession.builder.appName(<span class="string">"project"</span>).getOrCreate()</span><br><span class="line"></span><br><span class="line">    data2017 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"/data/Beijing_2017_HourlyPM25_created20170803.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line">    data2016 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"/data/Beijing_2016_HourlyPM25_created20170201.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line">    data2015 = spark.read.format(<span class="string">"csv"</span>).option(<span class="string">"header"</span>,<span class="string">"true"</span>).option(<span class="string">"inferSchema"</span>,<span class="string">"true"</span>).load(<span class="string">"/data/Beijing_2015_HourlyPM25_created20160201.csv"</span>).select(<span class="string">"Year"</span>,<span class="string">"Month"</span>,<span class="string">"Day"</span>,<span class="string">"Hour"</span>,<span class="string">"Value"</span>,<span class="string">"QC Name"</span>)</span><br><span class="line"></span><br><span class="line">    grade_function_udf = udf(get_grade, StringType())</span><br><span class="line"></span><br><span class="line">    group2017 = data2017.withColumn(<span class="string">"Grade"</span>, grade_function_udf(data2017[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line">    group2016 = data2016.withColumn(<span class="string">"Grade"</span>, grade_function_udf(data2016[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line">    group2015 = data2015.withColumn(<span class="string">"Grade"</span>, grade_function_udf(data2015[<span class="string">'Value'</span>])).groupBy(<span class="string">"Grade"</span>).count()</span><br><span class="line"></span><br><span class="line">    result2017 = group2017.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>).withColumn(<span class="string">"precent"</span>,group2017[<span class="string">'count'</span>] / data2017.count()*<span class="number">100</span>)</span><br><span class="line">    result2016 = group2016.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>).withColumn(<span class="string">"precent"</span>,group2016[<span class="string">'count'</span>] / data2016.count()*<span class="number">100</span>)</span><br><span class="line">    result2015 = group2015.select(<span class="string">"Grade"</span>, <span class="string">"count"</span>).withColumn(<span class="string">"precent"</span>,group2015[<span class="string">'count'</span>] / data2015.count()*<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 将数据写入到es中</span></span><br><span class="line">    result2017.selectExpr(<span class="string">"Grade"</span>, <span class="string">"count"</span>, <span class="string">"precent"</span>).write.format(<span class="string">"org.elasticsearch.spark.sql"</span>).option(<span class="string">"es.nodes"</span>,<span class="string">"192.168.211.4:9200"</span>).mode(<span class="string">"overwrite"</span>).save(<span class="string">"weather2017/pm"</span>)</span><br><span class="line">    result2016.selectExpr(<span class="string">"Grade"</span>, <span class="string">"count"</span>, <span class="string">"precent"</span>).write.format(<span class="string">"org.elasticsearch.spark.sql"</span>).option(<span class="string">"es.nodes"</span>,<span class="string">"192.168.211.4:9200"</span>).mode(<span class="string">"overwrite"</span>).save(<span class="string">"weather2016/pm"</span>)</span><br><span class="line">    result2015.selectExpr(<span class="string">"Grade"</span>, <span class="string">"count"</span>, <span class="string">"precent"</span>).write.format(<span class="string">"org.elasticsearch.spark.sql"</span>).option(<span class="string">"es.nodes"</span>,<span class="string">"192.168.211.4:9200"</span>).mode(<span class="string">"overwrite"</span>).save(<span class="string">"weather2015/pm"</span>)</span><br><span class="line"></span><br><span class="line">    spark.stop()</span><br></pre></td></tr></table></figure><p>然后再到192.168.211.4:5601里面查看es的数据是否导进来，再利用kibanna进行可视化</p><p><img src="https://s1.ax1x.com/2020/03/15/88QFit.png" alt="88QFit.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo新电脑的设置</title>
      <link href="/2020/03/08/hexo%E6%96%B0%E7%94%B5%E8%84%91%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/03/08/hexo%E6%96%B0%E7%94%B5%E8%84%91%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装hexo博客必要的软件"><a href="#安装hexo博客必要的软件" class="headerlink" title="安装hexo博客必要的软件"></a>安装hexo博客必要的软件</h2><p>下载安装Git客户端<br>安装node.js</p><h2 id="Github添加新电脑生成的密钥"><a href="#Github添加新电脑生成的密钥" class="headerlink" title="Github添加新电脑生成的密钥"></a>Github添加新电脑生成的密钥</h2><p>打开git bash输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@163.com&quot;</span><br></pre></td></tr></table></figure><p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。<br>使用<code>ssh -T git@github.com</code>测试公钥是否添加成功<br><img src="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/%E5%85%AC%E9%92%A5%E6%B5%8B%E8%AF%95.png" alt="img"></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在cmd或者创建博客主文件夹，右键git bash内输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h2><p>进入博客目录，如D:\blog\，Hexo init，这一步有可能在windows上特别慢，看了网上说先退出，再hexo init，结果秒完成，玄学。然后把之前复制的文件全部粘贴过来，选择全部覆盖。这个时候，这个本地环境的文件已经是要发布的文件了，接着安装一些模块插件，否则看不到你的一些功能（比如字数统计，访问量统计等）。</p><h2 id="That-s-all"><a href="#That-s-all" class="headerlink" title="That`s all"></a>That`s all</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean # 如果配置文件没有更改，忽略该命令</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://fl4g.cn/2018/08/03/Hexo博客迁移到其他电脑/" target="_blank" rel="noopener">https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</a></p><p>[2] <a href="https://blog.csdn.net/m0_37286282/article/details/89496837?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/m0_37286282/article/details/89496837?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-BigData题目</title>
      <link href="/2020/01/25/HCIA-BigData%E9%A2%98%E7%9B%AE/"/>
      <url>/2020/01/25/HCIA-BigData%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>HDFS：</p><p>QUESTION 10-m</p><p>Hadoop 的 HDFS 是一种分布式文件系统，适合以下哪种应用场景的数据存储和管理？</p><p>A. 大量小文件存储</p><p>B. 高容错、高吞吐量</p><p>C. 低延迟读取</p><p>D. 流式数据访问</p><p>QUESTION 15</p><p>华为 FusionInsight HD 系统中关于 HDFS 的 DataNode 的说法正确的是？</p><p>A. 不会检查数据的有效性</p><p>B. 周期性地将本节点的 Block 相关信息发送给 NameNode</p><p>C. 不同的 DataNode 存储的 Block 一定是不同的</p><p>D. 一个 DataNode 上的 Block 可以是相同的</p><p>QUESTION 39<br>HDFS 机制中 NameNode 负责管理元数据， Client 端每次读请求都需要从 NameNode 的元数<br>据磁盘中读取元数据信息，以此获取所读文件在 DataNode 中的位置。<br>A. 对<br>B. 错 </p><p>QUESTION 47<br>HDFS 的 Client 写入文件时，数据的第一副本写入位置由 NameNode 确定，其他副本的写<br>入位置由 DataNode 确定。<br>A. 对<br>B. 错</p><p>QUESTION 53<br>下列哪条 HDFS 命令可用于检测数据块的完整性？<br>A. hdfs fsck /<br>B. hdfs fsck – delete<br>C. hdfs dfsadmin – report<br>D. hdfs balancer – threshold 1 </p><p>QUESTION 65-m<br>HDFS 系统中对备用 NameNode 的作用的描述正确的有？<br>A. 主 NameNode 的热备<br>B. 备 NameNode 对内存没有要求<br>C. 帮助主 NameNode 合并 编辑日志，减少主 NameNode 的启动时间<br>D. 备 NameNode 应与主 NameNode 部署到一个节点 </p><p>QUESTION 76<br>FusionInsight HD 系统中 HDFS 默认 Block Size 是多少？<br>A. 32M<br>B. 64M<br>C. 128M </p><p>QUESTION 84-m<br>FusionInsight HD 集群中包含多种服务，每种服务又由若干角色组成，下面哪些是服务<br>的角色？<br>A. HDFS<br>B. NameNode<br>C. DataNode<br>D. HBase </p><p>QUESTION 96<br>HDFS 的 NameNode 节点主备状态管理及元数据文件合并分别由哪两个角色负责?<br>A. ZKFC 和备 NameNode<br>B. 主 NameNode 和备 NameNode<br>C. ZKFC 和主 NameNode<br>D. 主 NameNode 和 JournalNode </p><p>QUESTION 100<br>Hadoop 系统中关于客户端向 HDFS 文件系统上传文件说法正确的是？<br>A. 客户端的文件数据经过 NameNode 传递给 DataNode<br>B. 客户端将文件划分为多个 Block,根据 DataNode 的地址信息，按顺序写入每一个<br>DataNode 中<br>C. 客户端根据 DataNode 的地址信息，按顺序将整个文件写入每一个 DataNode 中，然<br>后由 DataNode 将文件划分为多个 Block<br>D. 客户端只上传数据到一个 DataNode ，然后由 NameNode 负责 Block 复制 </p><p>QUESTION 106<br>HDFS 支持大文件存储，同时支持多个用户对同一文件的写操作，以及在文件任意位置进<br>行修改。<br>A. 正确<br>B. 错误 </p><p>QUESTION 117<br>Fusionlnsight HD 系统中 HDFS 的 Block 默认保存几份？<br>A. 3 份<br>B. 2 份<br>C. 1 份<br>D. 不确定 </p><p>QUESTION 128<br>华为 Fusionlnsight HD 系统中关于 HDFS 的 DataNode 说法正确的是？<br>A. 不会检查数据的有效性<br>B. 周期性的将本节点的 Block 发送给 NameNode<br>C. 不同的 DataNode 存储的 Block 一定是不同的<br>D. 一个 DataNode 上的的 Block 可以是相同的 </p><p>QUESTION 151<br>HDFS 的 Client 写入文件时，数据的第一副本写入位置是由 NameNode 确定，其他副<br>本的写入位置由 DataNode 确定<br>A. 正确<br>B. 错误 </p><p>QUESTION 156<br>Hadoop 中哪个模块负责 HDFS 的数据存储？<br>A. NameNode<br>B. DataNode<br>C. ZooKeeper<br>D. JobTraoker </p><p>QUESTION 186-m<br>安全模式下安装 Fusionlnsight HD 集群时，哪些组件是必须安装的？<br>A. Zookeeper<br>B. LDAPServer<br>C. KrbServer<br>D. HDFS </p><p>QUESTION 223<br>HDFS 机制中， NameNode 负责管理元数据， Client 端每次请求都需要从 NameNode 的元数<br>据盘中读取元数据信息以此获取所读文件在 DataNode 的位置<br>A. 正确<br>B. 错误 </p><p>QUESTION 224-m<br>以下关于 Hadoop 分布式文件系统 HDFS 联邦描述正确的有？<br>A. 一个 Namespace 使用一个 block pool 管理数据块<br>B. 一个 Namespace 可使用多个 block pool 管理数据库<br>C. 每个 block pool 的磁盘空间是物理共享的，逻辑空间是隔离的<br>D. 支持 NameNode/NameSpace 水平扩展 </p><p>QUESTION 259-m<br>Fusionlnsight HD 系统中，关于 Solt 索引的存储部署策略，以下说正确的有？（多选）<br>A. 利用 HDFS 数据存储可靠性和易于扩容的特点优先选择索引存储于 HDFS<br>B. 不论 Solt 索引存储在 HDFS 上还是存储在本地磁盘，在同一节点上部署 5 个 Solt 实<br>例，根据 IP 和不同的端口号来区分不同的 Solt 实例<br>C. 当对实时索引录入速度要求较高时，可选择索引存放于本地磁盘<br>D. 当索引数据存放在 HDFS 上时， SolrServer 实例与 DataNode 实例部署在同一节点上。 </p><p>QUESTION 279<br>Fusionlnsight HD 系统部署时，如果 Solr 索引默认存放在 HDFS 上时，以下理解正确的<br>有？<br>A. 不需要考虑各 SolrServer 实例上创建了多少 Shared<br>B. 为保证数据可靠性，创建索引时必须创建 Replica<br>C. 通过 HDFS 读取索引时占用磁盘 IO，因此不建议 Solr 实例与 DataNode 部署在同一节<br>点上<br>D. 当 Solr 服务参考 INDEX_ON_HDFS 值为 HDFS 时，创建 Collection 的索引默认存储在<br>HDFS 上。 </p><p>QUESTION 284-m<br>以下关于 Hadoop 的 HDFS 描述正确的有？（多选）<br>A. HDFS 由 NameNode， DataNode， Client 组成<br>B. HDFS 备 NameNode 上的元数据是由主 NameNode 同步过去的<br>C. HDFS 采用就近的机架节点进行数据的第一副本存储<br>D. HDFS 适合一次写入，多次读取的读写任务 </p><p>QUESTION 286<br>客户 IT 系统中 Fusionlnsight HD 集群有 150 个节点，每个节点 12 块磁盘（不包括 OS<br>盘），每块磁盘大小 IT,只安装 HDFS，按照默认配置最大可存储多少数据？<br>A. 1764TB<br>B. 1800TB<br>C. 600TB<br>D. 588TB </p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>QUESTION 34<br>Hadoop 中 MapReduce 组件擅长处理哪种场景的计算任务？<br>A. 迭代计算<br>B. 离线计算<br>C. 实时交互计算<br>D. 流式计算 </p><p>QUESTION 35<br>Hadoop 系统中，如果 HDFS 文件系统的备份因子是 3，那么 MapReduce 每次运行 Task 都要<br>从 3 个有副本的机器上传输需要处理的文件段。<br>A. 对<br>B. 错</p><p> QUESTION 62<br>Hadoop 系 统 中 YARN 分 配 给 Container 的 内 存 大 小 ， 可 以 通 过 参 数<br>yarn.app.mapreduce.am.resource.mb 来设置<br>A. 对<br>B. 错</p><p>QUESTION 80<br>以下哪个不属于 Hadoop 中 MapReduce 组件的特点？<br>A. 易于编程<br>B. 良好的拓展性<br>C. 实时计算<br>D. 高容错性 </p><p>QUESTION 246<br>Hadoop 中 MapReduce 组件擅长处理哪种场景的计算任务？<br>A. 迭代计算<br>B. 离线计算<br>C. 实时交互计算<br>D. 流式计算 </p><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p><strong>关于loader的都不是很懂</strong></p><p>QUESTION 20-m<br>YARN 服务中，如果要给队列 QuqueA 设置容量为 30%，应该配置哪个参数？<br>A. yarn.scheduler.capacity.root.QueueA.user-limit-factor<br>B. yarn.scheduler.capacity.root.QueueA.minimum-user-limit-percent<br>C. yarn.scheduler.capacity.root.QueueA.capacity<br>D. yarn.scheduler.capacity.root.QueueA.state </p><p>QUESTION 36<br>YARN 调度器分配资源的顺序，下面哪一个描述是正确的？<br>A. 任意机器 -&gt; 同机架 -&gt; 本地资源<br>B. 任意机器 -&gt; 本地资源 -&gt; 同机架<br>C. 本地资源 -&gt; 同机架 -&gt; 任意机器<br>D. 同机架 -&gt; 任意机器 -&gt; 本地资源 </p><p>QUESTION 45<br>如果 YARN 集群中只有 Default、 QueueA 和 QueueB 子队列，那么允许将他们的容量<br>分别设置为 60%、 25%、 22%。<br>A. 对<br>B. 错 </p><p>QUESTION 63-m<br>YARN 通过 ResourceManager 对集群资源进行管理，它的主要功能有？<br>A. 集群资源调度<br>B. 应用程序管理<br>C. 日志管理<br>D. 以上说法都不对</p><p>QUESTION 88<br>YARN 上有两个同级队列 Q1 与 Q2，容量都是 50%， Q1 上已经有 10 个任务共占用了 40 的容<br>量， Q2 上有两个任务共占用了 30 的容量，那么由于 Q1 的任务数多，调度器会优先将资<br>源分配给 Q1。<br>A. 对<br>B. 错  </p><p>QUESTION 91<br>FusionInsight HD 中 Loader 作业提交到 YARN 后，作业不能手动停止。<br>A. 对<br>B. 错 </p><p>QUESTION 97<br>Hadoop 平台中启用 YARN 组件的日志聚集功能，需要配置哪个参数？<br>A. yarn.nodemanager.local-dir<br>B. yarn.nodemanager.log-dirs<br>C. yarn.acl.enable<br>D. yarn.log-aggregation-enable</p><p>QUESTION 104<br>YARN 中设置队列 QueueA 最大使用资源量，需要配置哪个参数？<br>A. yarn,scheduler.capacity.root,QueueA.user-limit-factor<br>B. yarn,scheduler.capacity.root,QueueA.minimum-user-limit-fpercent<br>C. yarn,scheduler.capacity.root,QueueA.state<br>D. yarn,scheduler.capacity.root,QueueA.maximum-capacity </p><p>QUESTION 124<br>Fusionlnsight HD Loader 作业前后，需要哪些节点与外部数据源通讯？<br>A. loader 服务主节点<br>B. 运行 Yarn 服务作业的节点<br>C. 前面两个都需要<br>D. 前面两个都不需要</p><p>QUESTION 143-m<br>Fusionlnsight HD LLD 配置规划工具可以生成哪些配置文件？<br>A. 监控告警阈值配置文件<br>B. 集群的安装模板文件<br>C. HDFS 和 YARN 的配置文件<br>D. 执行 Precheck 所需要的配置文件 CheckNodes.Config </p><p>QUESTION 153<br>Fusionlnsight HD 系统中 ，下列哪个方法不能查看到 Loader 作业执行的结果？<br>A. 通过 Yarn 任务管理查看<br>B. 通过 Loader UI 界面查看<br>C. 通过 Manager 的告警查看<br>D. 通过 NodeManager 查看 </p><p>QUESTION 169<br>关于 Fusionlnsight HD 中 Loader 作业描述正确的是？<br>A. Loader 将作业提交到 Yarn 执行后，如果此时 Loader 服务异常，则此作业执行失败。<br>B. Loader 将作业提交到 Yarn 执行后，如果某个 Mapper 任务执行失败，能够自动进行重<br>试<br>C. Loader 将作业执行失败后将会产生垃圾数据，需要用户手动清除<br>D. Loader 将一个作业提交至 Yarn 执行后，该作业执行完成前，不能再提交其他作业 </p><p>QUESTION 254<br>Hadoop 平台中，要查看 YARN 服务中的一个 application 信息，通常需要使用什么命令？<br>A. container<br>B. applicationatternpt<br>C. iar<br>D. application </p><p>QUESTION 261-m<br>Hadoop 系统中， YARN 支持哪些资源类型的管理？（多选）<br>A. 内存<br>B. CPU<br>C. 网络<br>D. 磁盘空间 </p><p>#Spark</p><p> QUESTION 9</p><p>Spark On Yarn 模式下的 driver 只能运行在客户端。<br>A. 对<br>B. 错 Spark</p><p>QUESTION 21<br>Spark 和 Hadoop 都不适用于迭代计算的场景。<br>A. 对<br>B. 错 </p><p>QUESTION 37<br>Spark SQL 表中，经常会存在很多小文件（大小远小于 HDFS 块大小），在这种情况下，<br>Spark 会启动更多的 Task 来处理这些小文件，当 SQL 逻辑中存在 Shuffle 操作时，会大<br>大增加 hash 分桶数，从而严重影响性能。<br>A. 对<br>B. 错 </p><p>QUESTION 40<br>Spark 应用运行时，如果某个 Task 运行失败则导致整个 app 运行失败。<br>A. 对<br>B. 错 </p><p>QUESTION 54<br>Spark On YARN 模式下，没有部署 NodeManager 的节点不能启动 executor 执行 Task<br>A. 对<br>B. 错 </p><p>QUESTION 79<br>Spark 是基于内存的计算引擎，所有 Spark 程序运行过程中，的数据只能存储在内存中<br>A. 对<br>B. 错 </p><p>QUESTION 95<br>Spark 应用在运行时， Stage 划分的依据是什么？<br>A. task<br>B. taskSet<br>C. action<br>D. shuffle </p><p>QUESTION 98<br>Spark 任务的一个 Executor 同时可以运行多个 task<br>A. 对<br>B. 错 </p><p>QUESTION 101<br>Fusionlnsight Manager 不能够管理哪个对象？<br>A. Spark<br>B. 主机 OS<br>C. YARN<br>D. HDFS </p><p>QUESTION 121<br>Spark 任务的每个 stage 可划分为 job, 划分的标记是 shuffle<br>A. 正确<br>B. 错误 </p><p>QUESTION 147<br>下列哪些是 Spark 可以提供的功能？<br>A. 分布式内存计算引擎<br>B. 分布式文件系统<br>C. 集群资源的统一调度<br>D. 流处理功能 </p><p>QUESTION 238<br>Spark 组建中哪个选项不属于 transformation 操作？<br>A. join<br>B. distinct<br>C. reduceBykey<br>D. reduce </p><p>QUESTION 278<br>以下哪些是 Spark 服务的常驻进程？（多选）<br>A. JobHistory<br>B. JDBCServer<br>C. SparkResource<br>D. Nodemanager </p><p>QUESTION 299<br>华为 Fusionlnsight HD 集群中， Spark 服务可以从以下哪些服务读取数据？（多选）<br>A. YARN<br>B. HDFS<br>C. Hive<br>D. HBase </p><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>QUESTION 3-m<br>HBase 集群定时执行 Compaction 的目的是什么？<br>A. 减少同一 Region，同一 ColumnFamily 下的文件数目<br>B. 提升数据读取性能<br>C. 减少同一 ColumnFamily 的文件数据<br>D. 减少同一 Region 的文件数目 </p><p>QUESTION 8<br>FusionInsight HD HBase 默认使用什么作为其底层文件存储系统？<br>A. HDFS<br>B. Hadoop<br>C. Memory<br>D. MapReduce </p><p>QUESTION 14-m<br>HBase 的主要特点有哪些？<br>A. 高可靠性<br>B. 高性能<br>C. 面向列<br>D. 可伸缩 </p><p>QUESTION 18<br>下列哪些组件必须依赖于 Zookeeper 才能运行？<br>A. HDFS<br>B. HBase<br>C. Spark<br>D. YARN </p><p>QUESTION 24<br>HBase 中 Region 的物理存储单元是什么<br>A. Region<br>B. ColumnFamily<br>C. Column<br>D. Row </p><p>QUESTION 32<br>FusionInsight HD 中使用 HBase 进行数据<strong>读取</strong>服务时需要连接 HMaster<br>A. 对<br>B. 错 </p><p>QUESTION 33<br>HBase 中一个 Region 进行 Split 操作时，将一个 HFile 文件真正分开到两个 Region 的过<br>程发生在以下什么阶段？<br>A. Split 过程中<br>B. Flush 过程中<br>C. Compaction 过程中<br>D. HFile 分开过程中 </p><p>QUESTION 43-m<br>HBase 的数据文件 HFile 中一个 KeyValue 格式包含哪些信息？<br>A. Key<br>B. Value<br>C. Timestamp<br>D. KeyType </p><p>QUESTION 48<br>HBase 的某张表的 RowKey 划分 SplitKey 为 9， E， a， z，请问该表有几个 Region？<br>A. 3<br>B. 4<br>C. 5<br>D. 6 </p><p>QUESTION 52<br>FusionInsight HD 平台中， HBase 暂不支持二级索引<br>A. 对<br>B. 错 </p><p>QUESTION 56<br>下列关于 HBase 的 BloomFilter 特性理解正确的是？<br>A. 用来过滤数据<br>B. 用来优化随机读取的性能<br>C. 会增加存储的消耗<br>D. 可以准确判断某条数据不存在 </p><p>QUESTION 60<br>Loader 仅支持关系型数据库与 HBase 之间的数据导入导出。<br>A. 对<br>B. 错 </p><p>QUESTION 71<br>HBase 的最小处理单元是 Region， User Region 和 Region Server 之间的路由信息是保存<br>在哪里的？<br>A. Zookeeper<br>B. HDFS<br>C. Master<br>D. meta 表 </p><p>QUESTION 83<br>HBase 元数据 Meta Region 路由信息保存在哪里？<br>A. Root 表<br>B. Zookeeper<br>C. HMaster<br>D. Meta 表 </p><p>QUESTION 87<br>执行 HBase 数据读取业务时，需要读取哪几部分数据？<br>A. HFile<br>B. HLog<br>C. MemStore<br>D. HMaster </p><p>QUESTION 89<br>FusionInsight HD 的 HBase 服务包含哪些进程？<br>A. HMaster<br>B. Slave<br>C. HRegionServer<br>D. DataNode </p><p>QUESTION 92<br>HBase 的主 Master 是如何选举的？<br>A. 随机选取<br>B. 由 RegionServer 进行裁决<br>C. 通过 Zookeeper 进行裁决<br>D. HMaster 为双主模式，不需要进行裁 </p><p>QUESTION 109<br>Fusionlnsight HD HBase 的管理进程是如何选择主节点的？<br>A. 随机选取<br>B. 由 RegionServer 进行裁决<br>C. 通过 ZooKeeper 进行裁决<br>D. HMaster 为双主模式，不需要进行裁决 </p><p>QUESTION 142<br>Fusionlnsight HD 系统中 HBase 元数据 Meta region 路由信息保存在哪？<br>A. Root 表<br>B. ZooKeeper<br>C. HMaster<br>D. Mata 表 </p><p>QUESTION 155<br>Fusionlnsight HD 中,如果需要查看当前登录 HBase 的用户和权限组，可以在 HBase shell<br>中执行什么命令？<br>A. use-permission<br>B. whoami<br>C. who<br>D. get-user </p><p>QUESTION 162<br>Hadoop 的 HBase 不适合哪些数据类型的应用场景？<br>A. 大文件应用场景<br>B. 海量数据应用场景<br>C. 高吞吐率应用场景<br>D. 半结构化数据应用场景 </p><p>QUESTION 165<br>Hadoop 平台中 HBase 的 Region 是由哪个服务进程来管理？<br>A. HMaster<br>B. Datanode<br>C. RegionServer<br>D. Zookeeper </p><p>QUESTION 173-m<br>基于 Hadoop 开源大数据平台主要提供了针对数据分布式计算和存储能力，如下属于分布<br>式存储组件的有？（多选）<br>A. MR<br>B. Spark<br>C. HDFS<br>D. HBase </p><p>QUESTION 190<br>Fusionlnsight HD 使用 HBase 客户端批量写入 10 条数据，某个 RegionServer 节点上<br>包含该表的 2 个 Region，分别 A 和 B， 10 条数据中有两条属于 A， 4 条属于 B，请问写入<br>这 10 条数据需要向该 RegionServer 发送几次 RPC 请求？<br>A. 1<br>B. 2<br>C. 3<br>D. 4 </p><p>QUESTION 210<br>Fusionlnsight HD 中使用 HBase 进行数据读写服务时，需要连接 HManager。<br>A. 正确<br>B. 错误 </p><p>QUESTION 214<br>Fusionlnsight HD 系统中，以下选项哪一个不是 HBase 写数据流程涉及的角色或服务？<br>A. Zookeeper<br>B. HDFS<br>C. HMaster<br>D. RegionServer </p><p>QUESTION 225<br>关于 HBase 中 HFile 的描述不正确的是？<br>A. 一个 HFile 属于一个 Region<br>B. 一个 HFile 包含多个列族的数据<br>C. 一个 HFile 包含多列数据<br>D. 一个 HFile 包含多行数据 </p><p>QUESTION 252<br>Fusionlnsight HD 的 HBase 中会保存一张用户信息表 meg-table,Rowkey 为用户 ID ,<br>其 中 一 列 为 用 户 昵 称 ， 现 在 按 先 后 顺 序 往 这 列 写 入 三 个<br>KeyValue:001:Li,001:Mary,001:Lily，请问 scan’meg-table’,{ERSIONS=&gt;2}会返回哪几<br>条数据？<br>A. 001:Li<br>B. 001:Lily<br>C. 001:Li,001:Mary,001:Lily<br>D. 001:Mary,001:Lily </p><p>QUESTION 253<br>关于 HBase 的 Region 分裂流程 Split 的描述不正确的是？<br>A. Split 过程中并没有真正的将文件分开，仅仅是创建了引用文件<br>B. Split 为了减少 Region 中数据大小，从而将一个 Region 分裂成两个 Region<br>C. Split 过程中该表会暂停服务<br>D. Split 过程中分裂的 Region 会暂停服务 </p><p>QUESTION 255<br>Fusionlnsight HD 系统中执行 HBase 写数据时候，数据被写入内存 Memstore、日志 HLog<br>和 HDP 中，请问哪一步写入成功后才会最终返回客户端写数据成功？<br>A. Memstore<br>B. HLog<br>C. HDFS<br>D. Menmory </p><p>QUESTION 265<br>HBase 的物理存储单元是什么？<br>A. Region<br>B. ColumnFamily<br>C. Column<br>D. ROW </p><p>QUESTION 270<br>HBase 中数据存储的文件格式是什么？<br>A. Flie<br>B. SequenceFile<br>C. Log<br>D. TXTflie </p><p>QUESTION 292<br>Fusionlnsight HD 系统中 HBase 支持动态扩展列。<br>A. 正确<br>B. 错误 </p><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p>QUESTION 4-m<br>FusionInsight HD 系统中 Hive 支持的存储格式包括？<br>A. HFile<br>B. TextFile<br>C. SequenceFile<br>D. RCFile </p><p>QUESTION 6-m<br>FusionInsight Manager 界面显示 Hive 服务状态为 Bad 时，可能原因有哪些？<br>A. DBService 不可用<br>B. HDFS 服务不可用<br>C. MetaStore 实例不可用<br>D. HBase 服务不可用 </p><p>QUESTION 31<br>在 FusionInsight HD 中，以下哪一项不属于 Hive 的流控特性<br>A. 支持对已建立的总连接数做阈值控制<br>B. 支持对每个用户已经建立的连接数做阈值控制<br>C. 支持对某个特定用户已建立的连接数做阈值控制<br>D. 支持对单位时间内所建立的连接数做阈值控制 </p><p>QUESTION 50<br>关于 Hive 中普通表和外部表的描述不正确的是？<br>A. 默认创建普通表<br>B. 外部表实质是将已经存在 HDFS 上的文件路径跟表关联起来<br>C. 删除普通表时，元数据和数据同时被删除<br>D. 删除外部表时，只删除外部表数据而不删除元数据</p><p>QUESTION 68<br>关于 Hive 建表的基本操作，描述正确的是？<br>A. 创建外部表的时需要指定 external 关键字<br>B. 一旦表创建好，不可再修改表名<br>C. 一旦表创建好，不可再修改列名<br>D. 一旦表创建好，不可再增加新列  </p><p>QUESTION 137<br>加载数据到 Hive 表，哪种方式不正确？<br>A. 直接将本地路径的文件 load 到 Hive 表中<br>B. 将 HDFS 上的额文件 load 到 Hive 表中<br>C. Hive 支持 insert into 单条记录的方法，所以可以直接在命令行插入单条记录<br>D. 将其他表的结果集 insert into 到 Hive 表中 </p><p>QUESTION 185<br>Fusionlnsight HD Manager 界面 Hive 日志收集，哪个选项不正确？<br>A. 可指定实例进行日志收集，比如指定单独收集 MetaStore 的日志<br>B. 可指定时间段进行日志收集，比如只收集 2016-1-10 的日志<br>C. 可指定节点 IP 进行日志收集，例如仅下载某个 IP 的日志<br>D. 可指定特定用户进行日志收集，例如仅下载 userA 用户产生的日志 </p><p>QUESTION 202<br>关于 Hive 与 Hadoop 其他组件的关系，以下描述错误的是？<br>A. Hive 最终将数据存储在 HDFS 中<br>B. Hive SQL 其本质是执行 MapReduce 任务<br>C. Hive 是 Hadoop 平台的数据仓库工具<br>D. Hive 对 HBase 有强依赖 </p><p>QUESTION 297<br>关于 Hive 在 Fusionlnsight HD 中的架构描述错误的是？<br>A. 只要有一个 HiveServer 不可用，整个 Hive 集群便不可用<br>B. Hiveserver 负责接受客户端请求、解析、执行 HQL 命令并返回查询结果<br>C. MetaStore 用于提供数据服务，依赖于 DBServer<br>D. 在同一个时间点 Hiveserve 只有一个处于 Active 状态，另一个则处于 Standby 状态 </p><h1 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h1><p>QUESTION 2<br>FusionInsight HD 的 Streaming 对于 Zookeeper 弱依赖，即使 Zookeeper 故障 Streaming<br>可以正常提供服务。<br>A. 对<br>B. 错 </p><p>QUESTION 28<br>关于 FusionInsight HD Streaming 的 Supervisor 描述正确的是？<br>A. Supervisor 负责资源的分配和任务的调度<br>B. Supervisor 负责接受 Nimbus 分配的任务，启动停止属于自己管理的 Worker 进程<br>C. Supervisor 是运行具体处理逻辑的进程<br>D. Supervisor 是在 Topology 中接收数据然后执行处理的组件 </p><p>QUESTION 74-m<br>FusionInsight HD 系统中使用 Streaming 客户端 Shell 命令查看拓扑或提交拓扑失败，<br>以下哪些定位手段是正确的？<br>A. 查看客户端异常堆栈，判断是否客户端使用问题<br>B. 查看主 Nimbus 的运行日志，判断是否 Nimbus 服务端异常<br>C. 查看 Supervisor 运行日志，判断是否 Supervisor 异常<br>D. 查看 Worker 运行日志 </p><p>QUESTION 207-m<br>Fusionlnsight HD 系统中 使用 Streaming 客户端 Shell 命令提交了拓扑之后，使用<br>Storm UI 查看发现该拓扑长时间没有处理数据，可能原因有？<br>A. 拓扑结构过于复杂或者并发太大，导致 worker 启动时间过长，超过 supervisor 的等<br>待时间<br>B. supervisor 的 slots 资源被耗尽，拓扑提交上去后分不到 slot 去启动 worker 进程<br>C. 拓扑业务存在扩及错误，提交之后无法正常运行<br>D. 当数据量较大时，拓扑处理速度较慢</p><p>QUESTION 263<br>安装 Fusionlnsight HD 的 Streaming 组件时， Nimbus 角色要求安装几个节点？<br>A. 1<br>B. 2<br>C. 3<br>D. 4 </p>]]></content>
      
      
      
        <tags>
            
            <tag> HCIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop各组件URL</title>
      <link href="/2020/01/06/hadoop%E5%90%84%E7%BB%84%E4%BB%B6URL/"/>
      <url>/2020/01/06/hadoop%E5%90%84%E7%BB%84%E4%BB%B6URL/</url>
      
        <content type="html"><![CDATA[<p>1、HDFS页面：50070</p><p>2、YARN的管理界面：8088</p><p>3、HistoryServer的管理界面：19888</p><p>4、Zookeeper的服务端口号：2181</p><p>5、Mysql的服务端口号：3306</p><p>6、Hive.server1=10000</p><p>7、Kafka的服务端口号：9092</p><p>8、azkaban界面：8443</p><p>9、Hbase界面：16010,60010</p><p>10、Spark的界面：8080</p><p>11、Spark的URL：7077</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/01/01/leetcode%E5%88%B7%E9%A2%98/"/>
      <url>/2020/01/01/leetcode%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h1 id="理论知识学习笔记"><a href="#理论知识学习笔记" class="headerlink" title="理论知识学习笔记"></a>理论知识学习笔记</h1><h2 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h2><p><a href="https://blog.csdn.net/weixin_41644993/article/details/96498297" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41644993/article/details/96498297</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>压栈 push()<br>出栈 pop()<br>返回栈顶元素 peek()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__li = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.__li.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__li.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__li:</span><br><span class="line">            <span class="keyword">return</span> self.__li[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_e</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__li == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__li)</span><br></pre></td></tr></table></figure><p><strong><a href="https://www.cnblogs.com/jmliao/p/6706762.html" target="_blank" rel="noopener">最大（小）堆和堆排序简介</a></strong></p><p>调用heapq库 (排好序的)</p><p><code>from heapq import xxxx</code></p><ol><li>heappush(heap, x) 将x压入堆中</li><li>heappop(heap) 从堆中弹出最小的元素</li><li>heapify(heap) 让列表具备堆特征</li><li>heapreplace(heap, x) 弹出最小的元素，并将x压入堆中，返回弹出的元素</li><li>nlargest(n, iter) 返回iter中n个最大的元素</li><li>nsmallest(n, iter) 返回iter中n个最小的元素</li></ol><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p>栈空的时候是迷宫走完了(此时没走出去)</p><blockquote><p>可以通过在列表或者元祖前加*,来展开列表中的元素</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="排序和刹闸坡"><a href="#排序和刹闸坡" class="headerlink" title="排序和刹闸坡"></a>排序和刹闸坡</h2><p>(对比)[<a href="https://images2015.cnblogs.com/blog/975503/201702/975503-20170214211234550-1109833343.png]" target="_blank" rel="noopener">https://images2015.cnblogs.com/blog/975503/201702/975503-20170214211234550-1109833343.png]</a></p><ol><li><p>冒泡排序  O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="comment"># 冒泡排序，两两进行比较</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)):</span><br><span class="line">        <span class="comment"># 0 ~ n-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">            <span class="comment"># 0 ~ j-1</span></span><br><span class="line">            <span class="keyword">if</span> li[i] &gt; li[i+<span class="number">1</span>]:</span><br><span class="line">                li[i], li[i+<span class="number">1</span>] = li[i+<span class="number">1</span>], li[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">print(bubble_sort(a))</span><br></pre></td></tr></table></figure></li><li><p>选择排序  O(n^2)<br> (主要是分成两部分，前面那部分是排好序的，后面那部分是未排序的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="comment"># 选择排序是找到后j个里面最小的一个，并把它放在li[]上</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)):</span><br><span class="line">        <span class="comment"># 0 ~ n-1</span></span><br><span class="line">        min = li[j]</span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j, len(li)):</span><br><span class="line">            <span class="comment"># 0 ~ j-1</span></span><br><span class="line">            <span class="keyword">if</span> li[i] &lt; min:</span><br><span class="line">                min = li[i]</span><br><span class="line">                min_index = i</span><br><span class="line">        li[j], li[min_index] = li[min_index], li[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">print(select_sort(a))</span><br></pre></td></tr></table></figure></li><li><p>插入排序  O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="comment"># 思路: 每次对第i个元素之前的进行排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> li[i] &lt; li[i<span class="number">-1</span>]:</span><br><span class="line">                li[i], li[i<span class="number">-1</span>] = li[i<span class="number">-1</span>], li[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">print(insert_sort(a))</span><br></pre></td></tr></table></figure></li><li><p>希尔排序</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="comment"># 思路: 本质上是在插入排序的基础上进行的改进</span></span><br><span class="line">    <span class="comment">#       主要是把原来的数组按gap划分</span></span><br><span class="line">    n = len(li)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> li[i] &lt; li[i-gap]:</span><br><span class="line">                    li[i], li[i-gap] = li[i-gap], li[i]</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap = gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">print(shell_sort(a))</span><br></pre></td></tr></table></figure><ol start="5"><li><p>快速排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li, start, final)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= final:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    low = start</span><br><span class="line">    high = final</span><br><span class="line">    minvalue = li[low]</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># 如果high处的值大于 minvalue high的值减一，然后继续比较</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> minvalue &lt;= li[high]:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 直到比较到high处的值小，这是把high处的值交换到low处</span></span><br><span class="line">        li[low] = li[high]</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> li[low] &lt; minvalue:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        li[high] = li[low]</span><br><span class="line">    li[low] = minvalue</span><br><span class="line"></span><br><span class="line">    quick_sort(li, start, low<span class="number">-1</span>)</span><br><span class="line">    quick_sort(li, low+<span class="number">1</span>, final)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">quick_sort(a, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></li><li><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge_Sort</span><span class="params">(li)</span>:</span></span><br><span class="line"></span><br><span class="line">    n = len(li)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li <span class="comment"># 这是其内部只有一个元素</span></span><br><span class="line">    m = n//<span class="number">2</span></span><br><span class="line">    left_li = Merge_Sort(li[:m])</span><br><span class="line">    right_li = Merge_Sort(li[m:])</span><br><span class="line">    <span class="comment"># 先写当分成每个数组都是一个元素的时候：</span></span><br><span class="line">    left_pointer, right_poiter = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_pointer &lt; len(left_li) <span class="keyword">and</span> right_poiter &lt; len(right_li):</span><br><span class="line">        <span class="keyword">if</span> left_li[left_pointer] &lt;= right_li[right_poiter]:</span><br><span class="line">            result.append(left_li[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_li[right_poiter])</span><br><span class="line">            right_poiter += <span class="number">1</span></span><br><span class="line">    result += left_li[left_pointer:]</span><br><span class="line">    result += right_li[right_poiter:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">b = Merge_Sort(a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>两个条件：1. 有序 2.列表(顺序表)</p><p>计算：头跟尾坐标相加除二</p><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>注意一点 <code>bool([])</code>是False; <code>bool[None]</code>是True。 因为这本质上是对列表进行判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(self.root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 弹出来的是一个node？</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">B_travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(self.root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem, end=<span class="string">' '</span>)</span><br><span class="line">            <span class="comment"># 其实每一个元素都是一个节点，直接在队列里把他们都显示出来</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_order</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = root</span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)</span><br><span class="line">        self.before_order(node.lchild)</span><br><span class="line">        self.before_order(node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = root</span><br><span class="line">        self.in_order(node.lchild)</span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)</span><br><span class="line">        self.in_order(node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pos_order</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = root</span><br><span class="line">        self.pos_order(node.lchild)</span><br><span class="line">        self.pos_order(node.rchild)</span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">tree = Tree()</span><br><span class="line">tree.add(<span class="number">0</span>)</span><br><span class="line">tree.add(<span class="number">1</span>)</span><br><span class="line">tree.add(<span class="number">2</span>)</span><br><span class="line">tree.add(<span class="number">3</span>)</span><br><span class="line">tree.add(<span class="number">4</span>)</span><br><span class="line">tree.add(<span class="number">5</span>)</span><br><span class="line">tree.add(<span class="number">6</span>)</span><br><span class="line">tree.add(<span class="number">7</span>)</span><br><span class="line">tree.add(<span class="number">8</span>)</span><br><span class="line">tree.add(<span class="number">9</span>)</span><br><span class="line">tree.B_travel()</span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line">tree.before_order(tree.root)</span><br><span class="line">print(<span class="string">''</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line">print(<span class="string">''</span>)</span><br><span class="line">tree.pos_order(tree.root)</span><br></pre></td></tr></table></figure><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>DAG：有向无圈图</p><hr><h3 id="图论中BFS、DFS-Python-BFS和DFS算法（第1讲）、Dijkstra"><a href="#图论中BFS、DFS-Python-BFS和DFS算法（第1讲）、Dijkstra" class="headerlink" title="图论中BFS、DFS[Python] BFS和DFS算法（第1讲）、Dijkstra"></a>图论中BFS、DFS<a href="https://www.bilibili.com/video/av25761720/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">[Python] BFS和DFS算法（第1讲）</a>、Dijkstra</h3><h3 id="BFS（一层一层的来）"><a href="#BFS（一层一层的来）" class="headerlink" title="BFS（一层一层的来）"></a>BFS（一层一层的来）</h3><p><a href="https://imgchr.com/i/l2b00g" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/08/l2b00g.md.png" alt="l2b00g.md.png"></a></p><p>BFS的算法思想：</p><p>1.选择一个根 ，并放入队列</p><p>2.将队列位于head的 节点拿出来，并把与目前head节点相连的节点放到队列中</p><p>3.重复2</p><p><strong>python实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph1 = &#123;</span><br><span class="line">    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">    <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'C'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'D'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'D'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    queue = [s]  <span class="comment"># 1.把根进入队列</span></span><br><span class="line">    seen = set()</span><br><span class="line">    seen.add(s)</span><br><span class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        head = queue.pop(<span class="number">0</span>)  <span class="comment"># 2. head pop出来</span></span><br><span class="line">        nodes = graph[head]  <span class="comment">#  并把与head相连的节点遍历出来</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                queue.append(w)  <span class="comment"># 放入队列中</span></span><br><span class="line">                seen.add(w)</span><br><span class="line">        print(head)</span><br><span class="line"></span><br><span class="line">BFS(graph1, <span class="string">'A'</span>)</span><br></pre></td></tr></table></figure><p>对BFS进行扩展，如何找到路径<br><img src="https://s2.ax1x.com/2020/01/09/lWvS6s.png" alt="lWvS6s.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">graph1 = &#123;</span><br><span class="line">    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">    <span class="string">'B'</span>: [<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'C'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'D'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'D'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    queue = [s]  <span class="comment"># 1.把根进入队列</span></span><br><span class="line">    seen = set()</span><br><span class="line">    seen.add(s)</span><br><span class="line">    parent = &#123;s: <span class="literal">None</span>&#125;   <span class="comment"># 创建一个父亲节点</span></span><br><span class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        head = queue.pop(<span class="number">0</span>)  <span class="comment"># 2. head pop出来</span></span><br><span class="line">        nodes = graph[head]  <span class="comment"># 并把与head相连的节点遍历出来</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                queue.append(w)  <span class="comment"># 放入队列中</span></span><br><span class="line">                seen.add(w)</span><br><span class="line">                parent[w] = head  <span class="comment"># 记录节点的父亲节点(父亲节点是head，w是与父亲节点相连接的点)</span></span><br><span class="line">        <span class="comment"># print(head)</span></span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line">parent1 = BFS(graph1, <span class="string">'E'</span>)</span><br><span class="line">v = <span class="string">'B'</span>  <span class="comment"># 从B开始</span></span><br><span class="line">print(parent1)</span><br><span class="line"><span class="keyword">while</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 只要v不是空，就一直去打印它的父亲节点</span></span><br><span class="line">    print(v)</span><br><span class="line">    v = parent1[v]</span><br></pre></td></tr></table></figure><h3 id="DFS（一条路走到黑）（回溯法）"><a href="#DFS（一条路走到黑）（回溯法）" class="headerlink" title="DFS（一条路走到黑）（回溯法）"></a>DFS（一条路走到黑）（回溯法）</h3><p>DFS的算法思想：</p><p>1.选择一个根 ，并放入堆栈中</p><p>2.将堆栈位于top的 节点拿出来，并把与目前top节点相连的节点压栈</p><p>3.重复2</p><p><strong>python实现：</strong></p><p><img src="https://s2.ax1x.com/2020/01/09/lWWPPK.png" alt="lWWPPK.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    stack = [s]</span><br><span class="line">    seen = set()</span><br><span class="line">    seen.add(s)</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        top = stack.pop()  <span class="comment"># 2. top(栈顶) pop出来</span></span><br><span class="line">        nodes = graph[top]</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                stack.append(w)</span><br><span class="line">                seen.add(w)</span><br><span class="line">        print(top)</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-讲解"><a href="#Dijkstra-讲解" class="headerlink" title="Dijkstra  讲解"></a>Dijkstra  <a href="https://www.bilibili.com/video/av25829980/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">讲解</a></h3><p>利用priority queue (优先队列)</p><p><img src="https://s2.ax1x.com/2020/01/09/lfCEh6.png" alt="lfCEh6.png"></p><p>思路：1.先确定一个起点，并初始化一个parent字典用以记录父节点</p><p>​            2.把与起点(或pop出的点)相连接的节点放入priority queue中，放入后会自动根据距离排序(此时节点中要包含<strong>与起点的距离</strong>)</p><p>​            3.在priority queue中pop出距离最短的节点(其余节点均保留在队列之中)（若pop出的节点已经输出则舍去不用），并记录父节点</p><p>​            4.重复2 3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">graph1 = &#123;</span><br><span class="line">    <span class="string">'A'</span>: &#123;<span class="string">'B'</span>: <span class="number">5</span>, <span class="string">'C'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">'B'</span>: &#123;<span class="string">'A'</span>: <span class="number">5</span>, <span class="string">'C'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">'C'</span>: &#123;<span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>, <span class="string">'D'</span>: <span class="number">4</span>, <span class="string">'E'</span>: <span class="number">8</span>&#125;,</span><br><span class="line">    <span class="string">'D'</span>: &#123;<span class="string">'B'</span>: <span class="number">1</span>, <span class="string">'C'</span>: <span class="number">4</span>, <span class="string">'E'</span>: <span class="number">3</span>, <span class="string">'F'</span>: <span class="number">6</span>&#125;,</span><br><span class="line">    <span class="string">'E'</span>: &#123;<span class="string">'C'</span>: <span class="number">8</span>, <span class="string">'D'</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">'F'</span>: &#123;<span class="string">'D'</span>: <span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化distance 把除了根节点以外的节点到根节点的距离设置为无穷</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_distnace</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    distance = &#123;s: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> node != s:</span><br><span class="line">            distance[node] = math.inf</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    pqueue = []</span><br><span class="line">    heapq.heappush(pqueue, (<span class="number">0</span>, s))  <span class="comment"># 1.把根进入优先队列</span></span><br><span class="line">    seen = set()</span><br><span class="line">    parent = &#123;s: <span class="literal">None</span>&#125;</span><br><span class="line">    distance = init_distnace(graph, s)</span><br><span class="line">    <span class="keyword">while</span> len(pqueue) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 2. head pop出来(注意pop出来的东西是一对的)</span></span><br><span class="line">        head_pair = heapq.heappop(pqueue)</span><br><span class="line">        dist = head_pair[<span class="number">0</span>]</span><br><span class="line">        head = head_pair[<span class="number">1</span>]</span><br><span class="line">        seen.add(head)  <span class="comment"># 这里的seen与bfs中的位置不同，这里只有当点被弹出的时候才能认为这个点被看到</span></span><br><span class="line">        <span class="comment"># 并把与head相连的节点遍历出来(要注意此时是.keys()因为graph里面的值此时也是一个字典)</span></span><br><span class="line">        nodes = graph[head].keys()</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">if</span> dist + graph[head][w] &lt; distance[w]:</span><br><span class="line">                    <span class="comment"># distance存的是根到w的最短距离 graph[head][w]为两点之间的距离</span></span><br><span class="line">                    heapq.heappush(pqueue, (dist + graph[head][w], w))</span><br><span class="line">                    <span class="comment"># 下面两组数据即为要输出的结果</span></span><br><span class="line">                    parent[w] = head</span><br><span class="line">                    distance[w] = dist + graph[head][w]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent, distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parent1, distance1 = dijkstra(graph1, <span class="string">'A'</span>)</span><br><span class="line">print(parent1)</span><br><span class="line">print(distance1)</span><br></pre></td></tr></table></figure><hr><h2 id="有关return的一个小陷阱"><a href="#有关return的一个小陷阱" class="headerlink" title="有关return的一个小陷阱"></a>有关return的一个小陷阱</h2><p><a href="https://blog.csdn.net/csdniter/article/details/90694394" target="_blank" rel="noopener">https://blog.csdn.net/csdniter/article/details/90694394</a> 由于return返回值会传递给上一层函数，而上一层函数没有return命令，故会返回None值给最外层，所以结果是None<br>找到原因之后，再加一个return命令即可</p><hr><h1 id="测试函数编写"><a href="#测试函数编写" class="headerlink" title="测试函数编写"></a>测试函数编写</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>创建和遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BuildListNode</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="comment"># convert that list into linked list</span></span><br><span class="line">    dummyRoot = ListNode(<span class="number">0</span>)</span><br><span class="line">    ptr = dummyRoot</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        ptr.next = ListNode(number)</span><br><span class="line">        ptr = ptr.next</span><br><span class="line"></span><br><span class="line">    ptr = dummyRoot.next</span><br><span class="line">    <span class="keyword">return</span> ptr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TrvalListNode</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line"></span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        result += str(node.val) + <span class="string">", "</span></span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"["</span> + result[:<span class="number">-2</span>] + <span class="string">"]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    s = BuildListNode(numbers)</span><br><span class="line">    print(TrvalListNode(s))</span><br></pre></td></tr></table></figure><p><strong>使用举例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">from</span> ListNodeBuild <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            res.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            res.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        res.sort()</span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        ptr = root</span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> res:</span><br><span class="line">            ptr.next = ListNode(number)</span><br><span class="line">            ptr = ptr.next</span><br><span class="line"></span><br><span class="line">        ptr = root.next</span><br><span class="line">        <span class="keyword">return</span> ptr</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    l1 = BuildListNode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">    l2 = BuildListNode([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">    s = Solution().mergeTwoLists(l1,l2)</span><br><span class="line"></span><br><span class="line">    print(TrvalListNode(s))</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>树的创建和遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    root = TreeNode(data)</span><br><span class="line">    nodeQueue = [root]</span><br><span class="line">    front = <span class="number">0</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(data):</span><br><span class="line">        node = nodeQueue[front]</span><br><span class="line">        front = front + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        item = data[index]</span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            leftNumber = item</span><br><span class="line">            node.left = TreeNode(leftNumber)</span><br><span class="line">            nodeQueue.append(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &gt;= len(data):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        item = data[index]</span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            rightNumber = item</span><br><span class="line">            node.right = TreeNode(rightNumber)</span><br><span class="line">            nodeQueue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">travelTree</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">    output = <span class="string">""</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current != len(queue):</span><br><span class="line">        node = queue[current]</span><br><span class="line">        current = current + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            output += <span class="string">"null, "</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        output += str(node.val) + <span class="string">", "</span></span><br><span class="line">        queue.append(node.left)</span><br><span class="line">        queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"["</span> + output[:<span class="number">-2</span>] + <span class="string">"]"</span></span><br></pre></td></tr></table></figure><p><strong>使用举例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> BuildTree <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 先把根找到 (注意根root是个节点不是一个数)</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        mid = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:mid+<span class="number">1</span>], inorder[:mid])</span><br><span class="line">        root.right = self.buildTree(preorder[mid+<span class="number">1</span>:], inorder[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    preo = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    ino = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">    root = Solution().buildTree(preo, ino)</span><br><span class="line">    s = travelTree(root)</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            half = self.myPow(x, n//<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 说明n能被2整除</span></span><br><span class="line">                <span class="keyword">return</span> half*half</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> half*half*x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = -n</span><br><span class="line">            x = <span class="number">1</span>/x</span><br><span class="line">            half = self.myPow(x, n//<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 说明n能被2整除</span></span><br><span class="line">                <span class="keyword">return</span> half*half</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> half*half*x</span><br></pre></td></tr></table></figure><p>总结： 分情况讨论，注意是用到了分治的思想。</p><h2 id="412-FizzBuzz"><a href="#412-FizzBuzz" class="headerlink" title="412.FizzBuzz"></a>412.FizzBuzz</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># if n == 1:</span></span><br><span class="line">        <span class="comment">#     res.append("1")</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="string">"FizzBuzz"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">5</span> != <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="string">"Fizz"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i%<span class="number">3</span> != <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="string">"Buzz"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(str(i))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326 3的幂"></a>326 3的幂</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            n = n/<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>总结: 注意以下几个问题，1.小于等于0和2都不是3的幂，1是3的0次幂；2.最后要再加一次判断，n==1是True</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ol><li>sort() 无返回值</li><li>l=list(s) 把s转换成列表<h2 id="9-回文数-20-1-4"><a href="#9-回文数-20-1-4" class="headerlink" title="9.回文数 20-1-4"></a>9.回文数 20-1-4</h2></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &gt;=<span class="number">0</span> : </span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            a = abs(x)</span><br><span class="line">            <span class="keyword">while</span>(a != <span class="number">0</span>):</span><br><span class="line">                temp = a % <span class="number">10</span> <span class="comment">#保存余数</span></span><br><span class="line">                a = a//<span class="number">10</span></span><br><span class="line">                num = num * <span class="number">10</span> + temp</span><br><span class="line">            <span class="keyword">if</span> num == x:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>总结：与上一题类似，需要注意在a除10的时候是整除，即<code>a = int(a/10)</code>or<code>a = a // 10</code></p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span> </span><br><span class="line">       left = <span class="number">0</span></span><br><span class="line">       right = len(height) - <span class="number">1</span></span><br><span class="line">       result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> left &lt; right:</span><br><span class="line">           area = (right - left) * min(height[left],height[right])</span><br><span class="line">           <span class="keyword">if</span> result &lt; area:</span><br><span class="line">               result = area</span><br><span class="line">           <span class="keyword">if</span> height[left] &gt; height[right]:</span><br><span class="line">               right -= <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               left += <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总结：1.<code>min()</code>可以找到最小值；</p><p>​            2.一开始就已经把指针定义在两端，如果短指针不动，而把长指针向着另一端移动，两者的距离已经变小了，无论会不会遇到更高的指针，结果都只是以短的指针来进行计算。 故移动长指针是无意义的。</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span>  </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        self.helpler(n, n, <span class="string">''</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helpler</span><span class="params">(self, l, r, item, result1)</span>:</span>  </span><br><span class="line">    <span class="comment"># l: 左边剩余括号数量</span></span><br><span class="line">    <span class="comment"># r: 右边剩余括号数量</span></span><br><span class="line">    <span class="comment"># item: 现在输出的结果(不一定是对的)</span></span><br><span class="line">    <span class="comment"># result1: 最后要return的结果</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span>:</span><br><span class="line">            result1.append(item)</span><br><span class="line">        <span class="keyword">if</span> l &gt; <span class="number">0</span>:</span><br><span class="line">            self.helpler(l<span class="number">-1</span>, r, item + <span class="string">'('</span>, result1)</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            self.helpler(l, r<span class="number">-1</span>, item + <span class="string">')'</span>, result1)</span><br></pre></td></tr></table></figure><p>总结: 1.搞懂实例中的变量和函数  注意<code>self.</code>的用法</p><h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        j=len(nums)</span><br><span class="line">        k=list(set(nums))</span><br><span class="line">        k.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> k:</span><br><span class="line">            nums.append(i)</span><br><span class="line">        <span class="keyword">del</span> nums[<span class="number">0</span>:j]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p>总结: 1.为了避开原地 用了把新的加进去，再删除前面的j个；<br>      2.注意set(nums)是把nums这个数组变成一个无序的集合，list()又将其转化为数组；<br>      3.k.sort()可以对数组进行排序。</p><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i]  &lt; prices[i+<span class="number">1</span>]:</span><br><span class="line">                profit += (prices[i+<span class="number">1</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><p>总结: 一句话，涨就买，跌就不管，把所有涨价的日子都加进来！</p><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        j = len(nums)</span><br><span class="line">        <span class="keyword">if</span> k &gt; j:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j-k%j):</span><br><span class="line">                nums.append(nums[i])</span><br><span class="line">            <span class="keyword">del</span> nums[<span class="number">0</span>:j-k%j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j-k):</span><br><span class="line">                nums.append(nums[i])</span><br><span class="line">            <span class="keyword">del</span> nums[<span class="number">0</span>:j-k]</span><br></pre></td></tr></table></figure><h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        nums2 = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) == len(nums2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724.寻找数组的中心索引"></a>724.寻找数组的中心索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        part_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> part_sum == (total - j) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            part_sum += j</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>总结:  </p><h2 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498.对角线遍历"></a>498.对角线遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        M = len(matrix)</span><br><span class="line">        N = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> M == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(M+N<span class="number">-1</span>): <span class="comment"># c代表第几个对角线</span></span><br><span class="line">        <span class="comment"># 一开始先不考虑对角线顺序的问题</span></span><br><span class="line">            <span class="keyword">if</span> c+<span class="number">1</span> &lt;= N: <span class="comment"># 说明还在第一行</span></span><br><span class="line">                row_begin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_begin = c-N+<span class="number">1</span>  <span class="comment"># 第二/三/..行最后一列</span></span><br><span class="line">            <span class="keyword">if</span> c+<span class="number">1</span> &lt;= M:</span><br><span class="line">                row_end = c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_end = M  <span class="comment"># 最后半部分结尾的行一定是M</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_begin, row_end+<span class="number">1</span>):</span><br><span class="line">                    res.append(matrix[i][c-i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_end, row_begin+<span class="number">1</span>,<span class="number">-1</span>):</span><br><span class="line">                    res.append(matrix[i][c-i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix = list(map(list, zip(*matrix)))[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>总结:1.<a href="https://www.cnblogs.com/YukiNote/p/11335076.html" target="_blank" rel="noopener">Python变量前’<em>‘和’*</em>‘的作用</a></p><p>2.<a href="https://www.runoob.com/python/python-func-zip.html" target="_blank" rel="noopener">Python zip() 函数</a></p><p>3.<a href="https://blog.csdn.net/mingyuli/article/details/81604795" target="_blank" rel="noopener">python 中的[:-1]和[::-1]</a></p><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        candidate, cnt = nums[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == candidate:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                     candidate = nums[i]</span><br><span class="line">                     cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol><li>字符串替换 <code>s = s.replace</code>(旧, 新, 个数)</li><li>只保留字符串中的字母和数字，并且变成小写 <code>s_n = [*filter(str.isalnum, s.lower())]</code><br>  <code>filter(function, iterable)</code></li></ol><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        dist = &#123;&#125;</span><br><span class="line">        start = <span class="number">-1</span></span><br><span class="line">        max = <span class="number">0</span></span><br><span class="line">        <span class="comment">#先做一个遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># range（0， 5） 是[0, 1, 2, 3, 4]没有5</span></span><br><span class="line">            <span class="comment">#分两种情况 </span></span><br><span class="line">            <span class="comment">#1.要判断的字符已经在字典中，and是为了保证是在新的子串中，和之前计算过的子串区分开</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> dist <span class="keyword">and</span> dist[s[i]] &gt; start:</span><br><span class="line">                start = dist[s[i]] <span class="comment"># 主要是后面i-start 其中的start是代表的重复的那个字母之前的字母</span></span><br><span class="line">                dist[s[i]] = i</span><br><span class="line">            <span class="comment">#2.要判断的字符未在字典中,如果未在判断是否需要更新max</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i-start &gt; max:</span><br><span class="line">                    max = i - start</span><br><span class="line">                dist[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> max</span><br></pre></td></tr></table></figure><p>总结：1.start要设置成-1，作为只有一个值的时候用<code>i-start</code>（0-1）</p><p>   2.<code>start = dist[s[i]]</code> 保证star是从前一个值开始，就像-1一样</p><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h2><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        x_abs = abs(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x_abs != <span class="number">0</span>):</span><br><span class="line">            tmp = x_abs % <span class="number">10</span></span><br><span class="line">            num = tmp + num*<span class="number">10</span></span><br><span class="line">            x_abs = int(x_abs/<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">elif</span> x &lt; <span class="number">0</span> <span class="keyword">and</span>  num &lt;= <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> -num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">-1</span>*x</span><br><span class="line">            x = int(<span class="string">"-"</span> + str(x)[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = int(str(x)[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">or</span> x &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>总结：1.方法一中注意是 x_abs = <strong>int</strong>(x_abs/10)否则x_abs的数值将一直保留小数，或者改成x_abs//10</p><p>​            2.方法二中是把输入结果转换成字符串，再通过str(x)[::-1]就可以直接把字符串反向输入</p><p>​            3. ** 代表平方</p><p>## </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        s_n = [*filter(str.isalnum, s.lower())]</span><br><span class="line">        n = len(s_n)</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n-i<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> s_n[i] == s_n[n-i<span class="number">-1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><p>方法一:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        sl, tl = list(s), list(t)</span><br><span class="line">        sl.sort()</span><br><span class="line">        tl.sort()</span><br><span class="line">        <span class="keyword">if</span> sl == tl:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>方法二:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        k = len(t)</span><br><span class="line">        <span class="keyword">if</span> k != len(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t = t.replace(s[i], <span class="string">''</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span> <span class="keyword">or</span> len(s)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        j = len(s)<span class="number">-1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            tmp = s[i]</span><br><span class="line">            s[i] = s[j]</span><br><span class="line">            s[j] = tmp</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>总结: 利用双字符串，设置中间量。</p><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> index, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> s[:index] <span class="keyword">and</span> c <span class="keyword">not</span> <span class="keyword">in</span> s[index+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 设置一个函数来每次计算新的seq</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">        seq = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            seq = self.helper(seq)</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, seq)</span>:</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 注意下面两个循环的设置，第一个while保证了可以循环的最后一位</span></span><br><span class="line">        <span class="comment"># 第二个while保证了循环不会出界(两个判断条件不可调换)</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(seq):</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(seq)<span class="number">-1</span> <span class="keyword">and</span> seq[i] == seq[i+<span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res += str(count) + seq[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="number">6</span></span><br><span class="line">    print(Solution().countAndSay(s))</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[l] + nums[r] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    <span class="keyword">while</span> l+<span class="number">1</span> &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r<span class="number">-1</span> <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> l &lt; r - <span class="number">1</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[l] + nums[r] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>总结：本题的难点在于如何去除重复解。这里有3个帮助去重的地方。</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-两个数的和"><a href="#1-两个数的和" class="headerlink" title="1.两个数的和"></a>1.两个数的和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dist=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i]) <span class="keyword">not</span> <span class="keyword">in</span> dist:  <span class="comment">#对健判断</span></span><br><span class="line">                dist[nums[i]] = i  <span class="comment"># num[i]是键  i是值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [dist[target - nums[i]],i]  <span class="comment">#返回的是键的=值</span></span><br></pre></td></tr></table></figure><p>总结：Python 字典 <strong>in</strong> 操作符用于判断<strong>键</strong>是否存在于字典中</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span>        </span><br><span class="line">        stack = []</span><br><span class="line">        lookup = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ss <span class="keyword">in</span> lookup:</span><br><span class="line">                stack.append(ss)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> ss != lookup[stack.pop()]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结： 1. 最后的return 要考虑到<code>{</code> （此时最后一个return为Falsee）</p><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;<span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">             <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line"></span><br><span class="line">        result = [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits: <span class="comment"># 先遍历出来输入的所有字符串</span></span><br><span class="line">            tmp_list = []</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> d[digit]: <span class="comment"># 再把第一个字符串内的字符遍历出来</span></span><br><span class="line">                <span class="keyword">for</span> ch2 <span class="keyword">in</span> result: <span class="comment"># 将上面遍历出来的字符串和result内的字符串进行串联</span></span><br><span class="line">                    tmp_list.append(ch2 + ch)</span><br><span class="line">            result = tmp_list</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总结: 1.此方法需要三个循环遍历，需要注意的是 把新遍历出的字符串与之前存在result里的字符串进行串联</p><p><strong>方法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>], <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>], <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">             <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>], <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>], <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>], <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(combination, index = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(digits) == index:</span><br><span class="line">                res.append(combination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> phone[digits[index]]: </span><br><span class="line">                dfs(combination + letter, index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits:</span><br><span class="line">            dfs(<span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>总结：1.回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解;</p><p>​            2.<code>digits[index]</code>的意思的<code>digits</code>这个字符串的第几个字符;</p><p>​            3.特别注意这里的return的位置(详细解释见前面，不过这里的return是没有返回值的，不会出现return None的结果)：<strong>return的作用是将函数结果返回，即退出def函数模块</strong>。</p><h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># values = [1000, 900, 500, 400, 100...]</span></span><br><span class="line">        <span class="comment"># numberals = ['M', 'CM', 'D', 'CD', 'C'...]</span></span><br><span class="line">        <span class="comment"># 1994 &gt;? 1000 =&gt; M</span></span><br><span class="line">        <span class="comment"># 994 &gt;? 1000  X</span></span><br><span class="line">        <span class="comment"># 994 &gt;? 900 =&gt; MCM</span></span><br><span class="line">        <span class="comment"># 94 &gt;? 900  X</span></span><br><span class="line">        <span class="comment"># 94 &gt;? 500  X  ....</span></span><br><span class="line">        values = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        numberals = [<span class="string">'M'</span>, <span class="string">'CM'</span>, <span class="string">'D'</span>, <span class="string">'CD'</span>,<span class="string">'C'</span>, <span class="string">'XC'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>, <span class="string">'X'</span>, <span class="string">'IX'</span>, <span class="string">'V'</span>, <span class="string">'IV'</span>, <span class="string">'I'</span>]</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(values)):</span><br><span class="line">            <span class="keyword">while</span> num &gt;= values[i]:</span><br><span class="line">                num -= values[i]</span><br><span class="line">                result += numberals[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># values = [1000, 900, 500, 400, 100...]</span></span><br><span class="line">        <span class="comment"># numberals = ['M', 'CM', 'D', 'CD', 'C'...]</span></span><br><span class="line">        <span class="comment"># 1994 &gt;? 1000 =&gt; M</span></span><br><span class="line">        <span class="comment"># 994 &gt;? 1000  X</span></span><br><span class="line">        <span class="comment"># 994 &gt;? 900 =&gt; MCM</span></span><br><span class="line">        <span class="comment"># 94 &gt;? 900  X</span></span><br><span class="line">        <span class="comment"># 94 &gt;? 500  X  ....</span></span><br><span class="line">        num_dict=&#123;<span class="number">1</span>:<span class="string">'I'</span>,</span><br><span class="line">            <span class="number">4</span>:<span class="string">'IV'</span>,</span><br><span class="line">            <span class="number">5</span>:<span class="string">'V'</span>,</span><br><span class="line">            <span class="number">9</span>:<span class="string">'IX'</span>,</span><br><span class="line">            <span class="number">10</span>:<span class="string">'X'</span>,</span><br><span class="line">            <span class="number">40</span>:<span class="string">'XL'</span>,</span><br><span class="line">            <span class="number">50</span>:<span class="string">'L'</span>,</span><br><span class="line">            <span class="number">90</span>:<span class="string">'XC'</span>,</span><br><span class="line">            <span class="number">100</span>:<span class="string">'C'</span>,</span><br><span class="line">            <span class="number">400</span>:<span class="string">'CD'</span>,</span><br><span class="line">            <span class="number">500</span>:<span class="string">'D'</span>,</span><br><span class="line">            <span class="number">900</span>:<span class="string">'CM'</span>,</span><br><span class="line">            <span class="number">1000</span>:<span class="string">'M'</span> &#125;</span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(num_dict.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= i:</span><br><span class="line">                num -= i</span><br><span class="line">                result += num_dict[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总结：1.尽可能多列出所有可能性，然后从大向减</p><p>​            2.若要使用字典应该注意，字典是没有索引的，先使用<code>sorted(num_dict.keys())[::-1]</code>排好序，再遍历其key， 这时候i就是key  <code>num_dict[i</code>就是其值  ｛i : ‘num_dict[i]’｝</p><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        numberal_map = &#123;<span class="string">'I'</span>:<span class="number">1</span>,<span class="string">'V'</span>:<span class="number">5</span>,<span class="string">'X'</span>:<span class="number">10</span>,<span class="string">'L'</span>:<span class="number">50</span>,<span class="string">'C'</span>:<span class="number">100</span>,<span class="string">'D'</span>:<span class="number">500</span>,<span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                result += numberal_map[s[i]]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span>  i &gt; <span class="number">0</span> <span class="keyword">and</span> numberal_map[s[i]] &lt;= numberal_map[s[i<span class="number">-1</span>]]:</span><br><span class="line">                result += numberal_map[s[i]]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result +=  numberal_map[s[i]] - <span class="number">2</span>* numberal_map[s[i<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总结：1.当<code>numberal_map[s[i]] &gt; numberal_map[s[i-1]]</code>时，此时result内已经加上了<code>i-1</code>时的值，所以这时候要减去2倍的<code>i-1</code>的值;(eg:IV 在第一个字符传进来的时候result内值为<code>I</code>，再第二个值传进来的时候本来是<code>I+V</code>，但是我们需要的是<code>V-I</code>所以要减去二倍的之前传过来的值。)</p><ol start="2"><li>要注意<code>i == 0</code>的情况。(是<strong>＝=</strong>哦)</li></ol><hr><hr><hr><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a>705. 设计哈希集合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)] <span class="comment"># 相当于创建1000个None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        k = key % <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># data[k] 里存的可能也是一个列表</span></span><br><span class="line">        <span class="keyword">if</span> self.data[k] == <span class="literal">None</span>:</span><br><span class="line">            self.data[k] = [key] <span class="comment"># 这边是赋的一个list</span></span><br><span class="line">        <span class="comment"># # 可能这个data[k]里已经存了多个key值了</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> self.data[k]:</span><br><span class="line">            <span class="keyword">if</span> val == key:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果data[k] != None</span></span><br><span class="line">        self.data[k].append(key) <span class="comment"># 注意这里，一般情况下是使用data.append()加在列表的最后。而这里面 data[k]内存的就是一个列表，相当于这里的data[k]是个list。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        k = key % <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.data[k]:</span><br><span class="line">            <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(self.data[k]): <span class="comment"># 这里的i是起到一个计数的作用</span></span><br><span class="line">                <span class="keyword">if</span> val == key:</span><br><span class="line">                    self.data[k].remove(key) <span class="comment"># list[].remove()</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, key: int)</span> -&gt; bool:</span></span><br><span class="line">        k = key % <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.data[k]:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> self.data[k]:</span><br><span class="line">                <span class="keyword">if</span> val == key:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="706. 设计哈希映射"></a>706. 设计哈希映射</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.keys = []</span><br><span class="line">        self.values = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        value will always be non-negative.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="comment"># self.keys.index(key) --&gt;找到key所在的list keys的索引值，因为一对键值对对应的索引值是相同的</span></span><br><span class="line">            self.values[self.keys.index(key)] = value   <span class="comment"># Upgrade</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.keys.append(key)</span><br><span class="line">            self.values.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="keyword">return</span> self.values[self.keys.index(key)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the mapping of the specified value key if this map contains a mapping for the key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            idx = self.keys.index(key)</span><br><span class="line">            self.keys.pop(idx)</span><br><span class="line">            self.values.pop(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># # obj = MyHashMap()</span></span><br><span class="line"><span class="comment"># # obj.put(key,value)</span></span><br><span class="line"><span class="comment"># # param_2 = obj.get(key)</span></span><br><span class="line"><span class="comment"># # obj.remove(key)</span></span><br></pre></td></tr></table></figure><h2 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numJewelsInStones</span><span class="params">(self, J: str, S: str)</span> -&gt; int:</span> </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        Jset = set(J)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> Jset:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>总结: 这道题用哈希集合可以简化思维过程，即记下在哈希集合中的宝石数目。</p><hr><h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        d=ListNode(<span class="number">0</span>) <span class="comment">#初始化一个预先指针，目的为了return时是从开头 开始</span></span><br><span class="line">        p = d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2 : <span class="comment">#l1,2 不为None</span></span><br><span class="line">            p.next = ListNode((l1.val + l2.val + carry) % <span class="number">10</span>) <span class="comment"># p.next是链表处的值</span></span><br><span class="line">            carry = (l1.val + l2.val + carry) // <span class="number">10</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1: <span class="comment"># 防止出现位数不匹配</span></span><br><span class="line">            <span class="keyword">while</span> l1:</span><br><span class="line">                p.next = ListNode((l1.val + carry) % <span class="number">10</span>)</span><br><span class="line">                carry = (l1.val  + carry) // <span class="number">10</span></span><br><span class="line">                l1 = l1.next</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            <span class="keyword">while</span> l2:</span><br><span class="line">                p.next = ListNode(( l2.val + carry) % <span class="number">10</span>)</span><br><span class="line">                carry = (l2.val + carry) // <span class="number">10</span></span><br><span class="line">                l2 = l2.next</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">if</span> carry: <span class="comment">#防止出现最后还有一个进位</span></span><br><span class="line">            p.next = ListNode(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> d.next</span><br></pre></td></tr></table></figure><p>总结：1.对于链表问题，返回结果为头结点时，通常需要先初始化一个<strong>预先指针 dummy</strong>，该指针的下一个节点指向真正的头结点head (即第一次用p.next=…的地方)。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        cur = head</span><br><span class="line">        prv = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = prv</span><br><span class="line">            prv = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> prv</span><br></pre></td></tr></table></figure><p>总结： 1.我们可以申请两个指针，第一个指针叫 prv，最初是指向 None 的。<br>        第二个指针 cur 指向 head，然后不断遍历 cur。<br>        每次迭代到 cur，都将 cur 的 next 指向 pre，然后 prv 和 cur 前进一位。<br>        都迭代完了(cur 变成 null 了)，<strong>prv 就是最后一个节点了</strong>。</p><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        k = len(res)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; k:</span><br><span class="line">            <span class="keyword">if</span> res[i] != res[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        thead = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thead.next = head</span><br><span class="line">        c = thead</span><br><span class="line">        <span class="keyword">while</span> c.next <span class="keyword">and</span> c.next.next:</span><br><span class="line">            a, b=c.next, c.next.next</span><br><span class="line">            c.next, a.next = b, b.next</span><br><span class="line">            b.next = a</span><br><span class="line">            c = c.next.next</span><br><span class="line">        <span class="keyword">return</span> thead.next</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/43254846f029b4814a6c9a139e4f9f89833ac54803ea50b24feb35210631f88b-a.jpg" target="_blank" rel="noopener">https://pic.leetcode-cn.com/43254846f029b4814a6c9a139e4f9f89833ac54803ea50b24feb35210631f88b-a.jpg</a></p><p>总结： 1.参考的此方法，通过建立<strong>一个额外的空头节点c</strong></p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            res.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            res.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        res.sort()</span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        ptr = root</span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> res:</span><br><span class="line">            ptr.next = ListNode(number)</span><br><span class="line">            ptr = ptr.next</span><br><span class="line"></span><br><span class="line">        ptr = root.next</span><br><span class="line">        <span class="keyword">return</span> ptr</span><br></pre></td></tr></table></figure><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure><p>总结：阅读理解</p><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1= head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">        p2= head</span><br><span class="line">        <span class="keyword">while</span> i-n<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i-n<span class="number">-1</span> == <span class="number">-1</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2.next = p2.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        node1 = head</span><br><span class="line">        node2 = head.next</span><br><span class="line">        <span class="keyword">while</span>(node1 != node2):</span><br><span class="line">            <span class="keyword">if</span>(node2 == <span class="literal">None</span> <span class="keyword">or</span> node2.next == <span class="literal">None</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node1 = node1.next</span><br><span class="line">            node2 = node2.next.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结：通过两个指针 一快一慢。注意什么时候判断为False</p><p>方法二：哈希值法, 空间复杂度O(n)</p><p>这个很好考虑, 把遍历过的节点记录,当发现遍历的节点下一个节点遍历过, 说明有环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lookup = set()</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            lookup.add(p)</span><br><span class="line">            <span class="keyword">if</span> p.next <span class="keyword">in</span> lookup:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h1><h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a>622. 设计循环队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.f,self.r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        self.k = k + <span class="number">1</span></span><br><span class="line">        self.__li = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.k)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Insert an element into the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isFull():</span><br><span class="line">            self.__li[self.r] = value</span><br><span class="line">            self.r = (self.r + <span class="number">1</span>) % self.k</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete an element from the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            self.f = (self.f + <span class="number">1</span>) % self.k            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front item from the queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.__li[self.f]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the last item from the queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.__li[(self.r - <span class="number">1</span> + self.k) % self.k] <span class="comment"># 防止减完一变成负的</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.r==self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.r + <span class="number">1</span>) % self.k == self.f</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyCircularQueue(k)</span></span><br><span class="line"><span class="comment"># param_1 = obj.enQueue(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deQueue()</span></span><br><span class="line"><span class="comment"># param_3 = obj.Front()</span></span><br><span class="line"><span class="comment"># param_4 = obj.Rear()</span></span><br><span class="line"><span class="comment"># param_5 = obj.isEmpty()</span></span><br><span class="line"><span class="comment"># param_6 = obj.isFull()</span></span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        <span class="comment"># 使用堆的nlargest(n,iter)返回前n个最大的数,倒序排练</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k,nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>总结: 使用heapq库，详细的函数见前面知识点。</p><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a>295. 数据流的中位数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import heapq</span></span><br><span class="line"><span class="comment"># class MedianFinder:</span></span><br><span class="line"><span class="comment">#     def __init__(self):</span></span><br><span class="line"><span class="comment">#         self.h = []</span></span><br><span class="line"><span class="comment">#     def addNum(self, num: int) -&gt; None:</span></span><br><span class="line"><span class="comment">#         heapq.heappush(self.h, num)</span></span><br><span class="line"><span class="comment">#     def findMedian(self) -&gt; float:</span></span><br><span class="line"><span class="comment">#         if len(self.h)%2!=0:</span></span><br><span class="line"><span class="comment">#             return heapq.nlargest(len(self.h)//2+1,self.h)[-1]</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             return ((heapq.nlargest(len(self.h)//2, self.h)[-1]+heapq.nlargest(len(self.h)//2+1, self.h)[-1])/2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.store = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.store.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        self.store.sort()</span><br><span class="line">        n = len(self.store)</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>: <span class="comment"># n 是奇数</span></span><br><span class="line">            <span class="keyword">return</span> self.store[n // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.store[n // <span class="number">2</span> - <span class="number">1</span>] + self.store[n // <span class="number">2</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h1><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">del</span> nums1[m:]</span><br><span class="line">        nums1 += nums2</span><br><span class="line">        nums1.sort()</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><p>总结：sort 与 sorted 区别：</p><ol><li>sort 是应用在 list 上的方法，属于列表的成员方法，sorted 可以对所有可迭代的对象进行排序操作。</li><li>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</li><li>sort使用方法为ls.sort()，而sorted使用方法为sorted(ls)</li></ol><h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h2> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 找到最小的那个True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面两句话就相当于，只要是True就继续往左走，只要是False就继续往右走</span></span><br><span class="line">        <span class="comment"># 判断 isBadVersion(mid):</span></span><br><span class="line">        <span class="comment"># True: 更新right = mid (因为此时的right可能就是想要的结果)</span></span><br><span class="line">        <span class="comment"># False: 更新left = mid + 1(因为第一个True一定在mid右边))</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> right - left &gt; <span class="number">1</span>: </span><br><span class="line">            <span class="comment"># 将left和right分别锁定成两个临近值，最后对着两个值进行单独判断</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion((left + right)//<span class="number">2</span>) :</span><br><span class="line">                right = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = (left + right)//<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isBadVersion(left):</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><hr><h1 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><p>方法一：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        self.result=[]</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.result.append(root.val)</span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        self.helper(root.right)</span><br></pre></td></tr></table></figure><p>总结: 1.我们针对之前所学习的print的那个版本进行修改，通过建立一个数组(result)和一个helper函数。注意这里的result数组的值不能被清零。</p><p>方法二：(迭代)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        self.result=[]</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        self.result.append(root.val)</span><br><span class="line">        self.helper(root.right)</span><br></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        self.result=[]</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        self.helper(root.right) </span><br><span class="line">        self.result.append(root.val)</span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a>102. 二叉树的层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que = [root]</span><br><span class="line">        result = []</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n= len(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = que.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">                <span class="keyword">elif</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">                <span class="keyword">elif</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">            result.append(tmp)</span><br><span class="line">            tmp=[]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总结: 1.首先看答案的结果，是一层当作一个列表进行输出，而不是一个一个输出，所以这里用了一个tmp列表，并且每层都清零一次<br>      2. 我这个迭代的方法是每层把队列里的值一次性都清空，这样就变成一层一层的了。</p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 运用递归的方法，先看假如是一个子树如何处理</span></span><br><span class="line">        left_d = self.maxDepth(root.left)</span><br><span class="line">        right_d = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(left_d, right_d)+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        que = [root, root]</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            node1 = que.pop(<span class="number">0</span>)</span><br><span class="line">            node2 = que.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果两个节点都是空就继续循环，有一个是空就False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (node1 <span class="keyword">or</span> node2):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (node1 <span class="keyword">and</span> node2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 将左节点的左孩子和右节点的右孩子入队</span></span><br><span class="line">            que.append(node1.left)</span><br><span class="line">            que.append(node2.right)</span><br><span class="line">            <span class="comment"># 将左节点的右孩子和右节点的左孩子入队</span></span><br><span class="line">            que.append(node1.right)</span><br><span class="line">            que.append(node2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结: 与普通的迭代遍历不同，这里要注意压入的左右孩子。</p><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> BuildTree <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 先把根找到 (注意根root是个节点不是一个数)</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        mid = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:mid+<span class="number">1</span>], inorder[:mid])</span><br><span class="line">        root.right = self.buildTree(preorder[mid+<span class="number">1</span>:], inorder[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    preo = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    ino = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">    root = Solution().buildTree(preo, ino)</span><br><span class="line">    s = travelTree(root)</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                hash_table.pop(i)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                hash_table[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> hash_table.popitem()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    print(Solution().singleNumber(nums))</span><br></pre></td></tr></table></figure><p>总结: 1. <code>try  except</code>语句是当try中的语句发生错误时执行except内的语句。<br>      2. 也可以使用异或，因为 相同数字 的异或 就是0</p><h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">                result.append(i)</span><br><span class="line">                nums2.remove(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [*(collections.Counter(nums1) &amp; collections.Counter(nums2)).elements()]</span><br></pre></td></tr></table></figure><p>## </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        d=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> digits:</span><br><span class="line">            d = d*<span class="number">10</span> + int(x)</span><br><span class="line">        <span class="comment"># d = ""</span></span><br><span class="line">        <span class="comment"># for i in digits:</span></span><br><span class="line">        <span class="comment">#     d =d+str(i)</span></span><br><span class="line">        <span class="comment"># d = int(d)</span></span><br><span class="line">        d = d+<span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str(d):</span><br><span class="line">            res.append(int(i))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">    print(Solution().plusOne(s))</span><br></pre></td></tr></table></figure><p>总结:此方法是把 str()–&gt;int()–&gt;str()</p><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i + j &lt; n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                nums.append(<span class="number">0</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        pre, cur = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># n=1 - 1</span></span><br><span class="line">        <span class="comment"># n=2 - 2</span></span><br><span class="line">        <span class="comment"># n=3 - 3</span></span><br><span class="line">        <span class="comment"># n=4 - 5 :1111 112 121 211 22</span></span><br><span class="line">        <span class="comment"># n=5 - 8 :11111 1112 1121 1211 2111 122 212 221 </span></span><br><span class="line">        <span class="comment"># fib</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            pre, cur = cur, pre + cur</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><p>总结：观察规律后发现是fib，事半功倍！</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_profit, min_price = <span class="number">0</span>, float(<span class="string">"inf"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_price = min(min_price, price)</span><br><span class="line">            max_profit = max(max_profit, price - min_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><p>总结：我们都希望在当前时刻去看，要是能在xx号(之前极小值的时候)买入该多好啊！所以 两个变量，一个为最大利润，一个为最小值。</p><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> max(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        local_max, global_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            local_max = max(<span class="number">0</span>, local_max + num)  </span><br><span class="line">            <span class="comment"># 大于0说明之前加的数还有意义，小于0之前的数就别要了</span></span><br><span class="line">            </span><br><span class="line">            global_max = max(global_max, local_max)</span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure><p>总结：local_max代表着只要大于0，之前加的数就是有意义的<br>    global_max一直记录着求和的最大值</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3实战Spark大数据分析及调度</title>
      <link href="/2019/12/17/Python3%E5%AE%9E%E6%88%98Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%8A%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/12/17/Python3%E5%AE%9E%E6%88%98Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%8A%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="spark的运行"><a href="#spark的运行" class="headerlink" title="spark的运行"></a>spark的运行</h1><p>1.启动hadoop (要在root用户下运行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd app/hadoopxxxxxxx/sbin</span><br><span class="line">start-dfs.sh</span><br><span class="line">**可在 http://localhost:50070/ 中查看自己上传的文件**</span><br></pre></td></tr></table></figure><p>2.启动spark</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd app/sparkxxxxxxx/bin</span><br><span class="line">./spark-shell</span><br></pre></td></tr></table></figure><h1 id="spark-core核心-RDD"><a href="#spark-core核心-RDD" class="headerlink" title="spark core核心 RDD"></a>spark core核心 RDD</h1><p>Spark源码所在的地方：<a href="https://github.com/apache/spark" target="_blank" rel="noopener">https://github.com/apache/spark</a></p><p>官网：xxxx.apache.org<br>源码：<a href="https://github.com/apache/xxxx" target="_blank" rel="noopener">https://github.com/apache/xxxx</a></p><p>spark url查看 <a href="http://hadoop000:4040" target="_blank" rel="noopener">http://hadoop000:4040</a></p><h2 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h2><p>abstract class RDD[T: ClassTag](<br>    @transient private var _sc: SparkContext,<br>    @transient private var deps: Seq[Dependency[_]]<br>) extends Serializable with Logging</p><p>1）RDD是一个抽象类<br>2）带泛型的，可以支持多种类型： String、Person、User</p><p>RDD：Resilient Distributed Dataset   弹性 分布式 数据集</p><p>弹性：遇到故障以后可以进行修复或者跟踪</p><p>Represents an<br>    immutable：<strong>不可变</strong>(RDD不可变)<br>    partitioned collection of elements ：分区<br>        Array(1,2,3,4,5,6,7,8,9,10)  3个分区： (1,2,3) (4,5,6) (7,8,9,10)<br>    that can be operated on in <strong>parallel</strong>： 并行计算的问题</p><p>单机存储/计算==&gt;分布式存储/计算<br>1）数据的存储: 切割    HDFS的Block<br>2）数据的计算: 切割(分布式并行计算)   MapReduce/Spark<br>3）存储+计算 :   HDFS/S3+MapReduce/Spark</p><pre><code>==&gt; OK </code></pre><h2 id="RDD的五大特性："><a href="#RDD的五大特性：" class="headerlink" title="RDD的五大特性："></a>RDD的五大特性：</h2><p>Internally, each RDD is characterized by five main properties:</p><p>*<em>1. *</em>A list of partitions<br>   一系列的分区/分片</p><p>*<em>2. *</em>A function for computing each split(切片)/partition<br>   y = f(x)<br>   rdd.map(_+1)  :对RDD进行函数就是对RDD里所有的分区进行一个函数</p><p><strong>3.</strong> A list of dependencies on other RDDs<br>   rdd1 ==&gt; rdd2 ==&gt; rdd3 ==&gt; rdd4  存在依赖关系(依赖其他RDD)<br>   dependencies:*<em>\</em>*</p><p>   rdda = 5个partition<br>   ==&gt;map操作<br>   rddb = 5个partition</p><p>   当遇到rdda内第三个分区丢失时，spark会通过dependency重新计算数据(从源文件重新读取)</p><p>*<em>4. *</em>Optionally(可选的), a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</p><p>*<em>5. *</em>Optionally, a list of preferred locations(最佳的位置) to compute each split on (e.g.<br>   block locations for an HDFS file)</p><p>   数据在哪，优先把作业调度到数据所在的节点进行计算：<strong>移动数据不如移动计算</strong><br>   为什么location有s？</p><p>   答: spark会尽可能地将任务分配到数据块所存储的位置。Hadoop中读取数据生成RDD时，preferredLocation[s]返回每一个数据块所在的机器名或者IP地址，如果每一块数据是多份存储的，那么就会返回多个机器地址,以便后续调度的程序根据这个地址更加有效地分配任务.</p><p>五大特性源码体现：<br>def compute(split: Partition, context: TaskContext): Iterator[T] 特性二<br>def getPartitions: Array[Partition]  特性一<br>def getDependencies: Seq[Dependency[_]] = deps  特性三<br>def getPreferredLocations(split: Partition): Seq[String] = Nil  特性五<br>val partitioner: Option[Partitioner] = None  特性四</p><h2 id="图解RDD"><a href="#图解RDD" class="headerlink" title="图解RDD"></a>图解RDD</h2><p><img src="https://s2.ax1x.com/2019/12/18/Q7nJ0O.png" alt="Q7nJ0O.png"></p><h2 id="SparkContext-amp-SparkConf"><a href="#SparkContext-amp-SparkConf" class="headerlink" title="SparkContext&amp;SparkConf"></a>SparkContext&amp;SparkConf</h2><p>第一要务：创建SparkContext<br>    连接到Spark“集群”：local、standalone、yarn、mesos<br>    通过SparkContext来创建RDD、广播变量到集群</p><p>在创建SparkContext之前还需要创建一个SparkConf对象(conf-&gt;配置)</p><p>RDD创建方式<br>    Parallelized Collections<br>    External Datasets</p><p>If using a path on the local filesystem, the file must also be accessible at the same path on worker nodes<br>    1）我们上课是在单节点上的：一个节点， hello.txt只要在这台机器上有就行了<br>    2）standalone: Spark集群： 3个节点  local path 都是从节点的本地读取数据  不建议</p><h2 id="IDE开发"><a href="#IDE开发" class="headerlink" title="IDE开发"></a>IDE开发</h2><p>开发pyspark应用程序<br>    1) IDE(Integrated Development Environment ): IDEA  pycharm<br>    2) 设置基本参数: python interceptor    PYTHONPATH   SPARK_HOME   2zip包<br>    3）开发<br>    4）使用local进行本地测试</p><p>提交pyspark应用程序($SPARK_HOME)<br>    ./spark-submit –master local[2] –name spark0301 /home/hadoop/script/spark0301.py<br>    具体提交的详细说明参见：<a href="http://spark.apache.org/docs/latest/submitting-applications.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/submitting-applications.html</a></p><p><strong><a href="https://blog.csdn.net/qq_37332702/article/details/88687251" target="_blank" rel="noopener">Spark任务提交全流程</a></strong></p><p><img src="https://s2.ax1x.com/2020/01/16/ljBa6I.png" alt="ljBa6I.png"></p><p>1.Driver端启动SparkSubmit进程，启动后开始向Master进行通信，此时创建了一个对象（SparkContext），接着向Master发送任务消息<br>2.Master接收到任务信息后，开始资源调度，此时会和所有的Worker进行通信，找到空闲的Worker，并通知Worker来拿取任务和启动相应的Executor<br>3.Executor启动后，开始与Driver进行反向注册，接下来Driver开始把任务发送给相应的Executor，Executor开始计算任务</p><p>全流程:</p><p><img src="https://s2.ax1x.com/2020/01/16/ljBytg.png" alt="ljBytg.png"><a href="https://imgchr.com/i/ljBytg" target="_blank" rel="noopener">https://imgchr.com/i/ljBytg</a></p><p>1.调用SparkSubmit类，内部执行submit –&gt; doRunMain -&gt; 通过反射获取应用程序的主类对象 –&gt; 执行主类的main方法。<br>2.构建SparkConf和SparkContext对象，在SparkContext入口做了三件事，创建了SparkEnv对象（创建了ActorSystem对象），TaskScheduler（用来生成并发送task给Executor），DAGScheduler（用来划分Stage）。<br>3.ClientActor将任务信息封装到ApplicationDescription对象里并且提交给Master。<br>4.Master收到ClientActor提交的任务信息后，把任务信息存在内存中，然后又将任务信息放到队列中。<br>5.当开始执行这个任务信息的时候，调用scheduler方法，进行资源的调度。<br>6.将调度好的资源封装到LaunchExecutor并发送给对应的Worker。<br>7.Worker接收到Master发送过来的调度信息（LaunchExecutor）后，将信息封装成一个ExecutorRunner对象。<br>8.封装成ExecutorRunner后，调用ExecutorRunner的start方法，开始启动 CoarseGrainedExecutorBackend对象。<br>9.Executor启动后向DriverActor进行反向注册。<br>10.与DriverActor注册成功后，创建一个线程池（ThreadPool），用来执行任务。<br>11.当所有的Executor注册完成后，意味着作业环境准备好了，Driver端会结束与SparkContext对象的初始化。<br>12.当Driver初始化完成后（创建了sc实例），会继续执行我们提交的App的代码，当触发了Action的RDD算子时，就触发了一个job，这时就会调用DAGScheduler对象进行Stage划分。<br>13.DAGScheduler开始进行Stage划分。<br>14.将划分好的Stage按照区域生成一个一个的task，并且封装到TaskSet对象，然后TaskSet提交到TaskScheduler。<br>15.TaskScheduler接收到提交过来的TaskSet，拿到一个序列化器，对TaskSet序列化，将序列化好的TaskSet封装到LaunchExecutor并提交到DriverActor。<br>16.把LaunchExecutor发送到Executor上。<br>17.Executor接收到DriverActor发送过来的任务（LaunchExecutor），会将其封装成TaskRunner，然后从线程池中获取线程来执行TaskRunner。<br>18.TaskRunner拿到反序列化器，反序列化TaskSet，然后执行App代码，也就是对RDD分区上执行的算子和自定义函数。</p><h2 id="a-example-about-SparkContext-amp-SparkConf"><a href="#a-example-about-SparkContext-amp-SparkConf" class="headerlink" title="a example about SparkContext&amp;SparkConf"></a>a example about SparkContext&amp;SparkConf</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf,SparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SparkConf：设置的是Spark相关的参数信息</span></span><br><span class="line">conf = SparkConf().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"spark0301"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SparkContext</span></span><br><span class="line">sc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 业务逻辑</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">distData = sc.parallelize(data)  <span class="comment"># parallelize的目的是为了把data转换成RDD</span></span><br><span class="line">print(distData.collect())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好的习惯</span></span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure><h1 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h1><h2 id="官网参考文件"><a href="#官网参考文件" class="headerlink" title="官网参考文件"></a>官网参考文件</h2><p><a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/rdd-programming-guide.html</a>  RDD Programming Guide</p><p>RDD Operation<br>    transformations: create a new dataset from an existing one<br>        RDDA —transformation–&gt; RDDB</p><pre><code>    y = f(x)    rddb = rdda.map(....)    lazy(*****) (它不会立刻计算，相反，它仅仅记住作用到数据集中---直到遇到action( collect() ))    rdda.map().filter()......collect    map/filter/group by/distinct/.....actions:     return a value to the driver program after running a computation on the dataset    count/reduce/collect......1) transformation are lazy, nothing actually happens until an action is called;2) action triggers the computation;3) action returns values to driver or writes data to external storage;</code></pre><h2 id="常用的RDD函数"><a href="#常用的RDD函数" class="headerlink" title="常用的RDD函数"></a>常用的RDD函数</h2><p><strong>map</strong>:<br>    map(func)<br>    将func函数作用到数据集的每一个元素上，生成一个新的分布式的数据集返回</p><pre><code>word =&gt; (word,1)</code></pre><p><code>map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次 。reduce()是将传人的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算）。</code></p><p><code>简单说，map是对每个元素进行操作-返回一个列表；reduce是所有元素操作-返回一个结果。</code></p><p><strong>filter:</strong><br>    filter(func)<br>    选出所有func返回值为true的元素，生成一个新的分布式的数据集返回</p><p><strong>flatMap</strong>  —-&gt;(压扁以后做map 先拆成多个部分)<br>    flatMap(func)<br>    输入的item能够被map到0或者多个items输出，返回值是一个Sequence</p><p><strong>groupByKey：</strong></p><p>​    把相同的key的数据分发到一起<br>​    [‘hello’, ‘spark’, ‘hello’, ‘world’, ‘hello’, ‘world’]<br>​    (‘hello’,1) (‘spark’,1)……..</p><p>*<em>reduceByKey: *</em>  </p><p>​    reduceByKey的作用对像是(key, value)形式的rdd，而reduce有减少、压缩之意，reduceByKey的作用就是对相同key的数据进行处理，最终每个key只保留一条记录。</p><p>​    把相同的key的数据分发到一起并进行相应的计算<br>​     mapRdd.reduceByKey(lambda a,b:a+b)<br>​     [1,1]  1+1<br>​     [1,1,1]  1+1=2+1=3<br>​     [1]    1</p><p>​    需求: 请按wc结果中出现的次数降序排列  sortByKey 按照Key进行排序<br>​        (‘hello’, 3), (‘world’, 2),  (‘spark’, 1)</p><p><strong>答</strong>：完成上面的方法就是key和value交换 即<code>lambda x：x[1],x[0]</code> 后进行sortByKey， 最后再做一步map再交换回来</p><p><strong>union：</strong></p><p>*<em>join： *</em><br>    inner join<br>    outer join:left/right/full</p><p><strong>action:</strong></p><p>rdd.take(3) 显示前3个</p><p>rdd.sum()求和</p><p>rdd.max()最大值</p><p>rdd.count()计数</p><p>saveAsTextFile()以文件的形式保存</p><h2 id="如何在本地运行spark-不用IDE，提交到本地-，并写到文件系统中"><a href="#如何在本地运行spark-不用IDE，提交到本地-，并写到文件系统中" class="headerlink" title="如何在本地运行spark(不用IDE，提交到本地)，并写到文件系统中"></a>如何在本地运行spark(不用IDE，提交到本地)，并写到文件系统中</h2><blockquote><p>1.把在IDE中已经测试好的代码建立 .py（/mycode）</p><p>2.在到./spark中 执行—&gt;此时可以在控制台上显示</p><p><code>./spark-submit --master local[2] --name spark04cp /home/hadoop/mycode/spark04cp.py(执行文件) file:///home/hadoop/data/hello.txt(要处理的数据)</code></p><p>3.在代码中加入 saveAsTextFile(sys.argv[2])</p><p>在执行是最后再加入第三个参数，即为保存的目录</p><p><code>./spark-submit --master local[2] --name spark04cp /home/hadoop/mycode/spark04cp.py(执行程序) file:///home/hadoop/data/hello*.txt(要处理的数据) file:///home/hadoop/data/tmp/wc(保存的处理后数据的位置)</code></p></blockquote><h2 id="算子综合实例："><a href="#算子综合实例：" class="headerlink" title="算子综合实例："></a>算子综合实例：</h2><p>一、词频案例:wc<br>    1) input: 1/n文件  文件夹  后缀名<br>        hello spark<br>        hello hadoop<br>        hello welcome<br>    2) 开发步骤分析<br>        文本内容的每一行转成一个个的单词 : flatMap<br>        单词 ==&gt; (单词, 1):  map<br>        把所有相同单词的计数相加得到最终的结果: reduceByKey<br>        最后按照个数的升序排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:  <span class="comment"># 等于1代表只有这个.py运行了，没有别的外部参数</span></span><br><span class="line">        print(<span class="string">'Usage:wordcount &lt;input&gt;'</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">        sys.exit(<span class="number">-1</span>) <span class="comment"># 如果没有文件输入就直接退出</span></span><br><span class="line"></span><br><span class="line">    conf = SparkConf()</span><br><span class="line">    sc = SparkContext(conf=conf)</span><br><span class="line">    <span class="comment"># sys.argv[0] 代表运行的本程序名称 sys.argv[1]代表输入</span></span><br><span class="line">    print(sys.argv[<span class="number">0</span>])</span><br><span class="line">    print(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printResult</span><span class="params">()</span>:</span></span><br><span class="line">        counts = sc.textFile(sys.argv[<span class="number">1</span>]) \</span><br><span class="line">            .flatMap(<span class="keyword">lambda</span> line: line.split(<span class="string">"\t"</span>)) \</span><br><span class="line">            .map(<span class="keyword">lambda</span> x: (x, <span class="number">1</span>)) \</span><br><span class="line">            .reduceByKey(<span class="keyword">lambda</span> a, b: (a + b))\</span><br><span class="line">            .map(<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>]))\</span><br><span class="line">            .sortByKey()\</span><br><span class="line">            .map(<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>])).saveAsTextFile(sys.argv[<span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printResult()</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br></pre></td></tr></table></figure><p>二、TopN<br>    1) input : 1/n文件  文件夹  后缀名<br>    2) 求某个维度的topn<br>    3）开发步骤分析<br>        文本内容的每一行根据需求提取出你所需要的字段： map<br>        单词 ==&gt; (单词, 1):  map<br>        把所有相同单词的计数相加得到最终的结果: reduceByKey<br>        取最多出现次数的降序： sortByKey</p><p>平均数：统计平均年龄<br>id age<br>3 96<br>4 44<br>5 67<br>6 4<br>7 98<br>    开发步骤分析：<br>    1) 取出年龄  map<br>    2）计算年龄综合 reduce<br>    3）计算记录总数 count<br>    4）求平均数  </p><h2 id="spark运行模式"><a href="#spark运行模式" class="headerlink" title="spark运行模式"></a>spark运行模式</h2><p> Local模式：<br>    开发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--master </span><br><span class="line">--name  # 应用程序名称</span><br><span class="line">--py-files  # 上传文件</span><br></pre></td></tr></table></figure><p><code>./spark-submit --master local[2] --name spark-local /home/hadoop/script/spark0402.py file:///home/hadoop/data/hello.txt file:///home/hadoop/wc/output</code></p><p>standalone<br>    hdfs: NameNode  DataNode<br>    yarn: ResourceManager NodeManager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">master: (主)</span><br><span class="line">worker:(从)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>SPARK_HOME/conf/slaves</span><br><span class="line">hadoop000</span><br><span class="line"></span><br><span class="line">假设你有5台机器，就应该进行如下slaves的配置</span><br><span class="line">hadoop000</span><br><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br><span class="line">hadoop004</span><br><span class="line">如果是多台机器，那么每台机器都在相同的路径下部署spark</span><br><span class="line"></span><br><span class="line">启动spark集群</span><br><span class="line"><span class="meta">$</span>SPARK_HOME/sbin/start-all.sh</span><br><span class="line">ps: 要在spark-env.sh中添加JAVA_HOME，否则会报错</span><br><span class="line">检查： </span><br><span class="line">jps： Master和Worker进程，就说明我们的standalone模式安装成功</span><br><span class="line">webui：</span><br></pre></td></tr></table></figure><p><code>./spark-submit --master spark://hadoop000:7077 --name spark-standalone /home/hadoop/script/spark0402.py hdfs://hadoop000:8020/wc.txt hdfs://hadoop000:8020/wc/output</code></p><pre><code>如果使用standalone模式，而且你的节点个数大于1的时候，如果你使用本地文件测试，必须要保证每个节点上都有本地测试文件  (或者选择在hdfs内的文件)</code></pre><p>yarn<br>    mapreduce yarn<br>    spark on yarn 70%<br>    spark作为客户端而已，他需要做的事情就是提交作业到yarn上去执行<br>    yarn vs standalone<br>        yarn： 你只需要一个节点，然后提交作业即可   这个是不需要spark集群的（不需要启动master和worker的）<br>        standalone：你的spark集群上每个节点都需要部署spark，然后需要启动spark集群（需要master和worker）</p><p><code>./spark-submit --master yarn --name spark-yarn /home/hadoop/script/spark0402.py hdfs://hadoop000:8020/wc.txt hdfs://hadoop000:8020/wc/output</code></p><p>When running with master ‘yarn’ either HADOOP_CONF_DIR or YARN_CONF_DIR must be set in the environment</p><p>作业：试想：为什么需要指定HADOOP_CONF_DIR或者YARN_CONF_DIR</p><p>如何使得这个信息规避掉<br>Neither spark.yarn.jars nor spark.yarn.archive is set, falling back to uploading libraries under SPARK_HOME</p><p>yarn支持client和cluster模式：driver运行在哪里<br>    client：提交作业的进程是不能停止的，否则作业就挂了<br>    cluster：提交完作业，那么提交作业端就可以断开了，因为driver是运行在am里面的</p><p>Error: Cluster deploy mode is not applicable to Spark shells</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyspark/spark-shell : 交互式运行程序  client</span><br><span class="line">spark-sql</span><br></pre></td></tr></table></figure><p>如何查看已经运行完的yarn的日志信息： yarn logs -applicationId <applicationid> (此ID在hadoop000:8088/cluster中可以查看)<br>Log aggregation has not completed or is not enabled.<br>参见：<a href="https://coding.imooc.com/class/chapter/128.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/chapter/128.html#Anchor</a>  JobHistory使用</applicationid></p><p>不管你的spark应用程序运行在哪里，你的spark代码都是一样的，不需要做任何的修改和调整，所以spark使用起来是非常方便的！！！！！！</p><p>##spark core 进阶</p><p>Spark核心概述</p><p>​    <img src="https://s2.ax1x.com/2020/01/06/lyCVbT.png" alt="Spark 架构图"></p><p>​        用户提交Job后会生成SparkContext对象，SparkContext向Cluster Manager（在Standalone模式下是Spark Master）申请Executor资源，并将Job分解成一系列可并行处理的task，然后将task分发到不同的Executor上运行，Executor在task执行完后将结果返回到SparkContext。</p><p>(上图SparkContext 与 executor为什么是双向的是因为 当连接的时候， SparkContext acquires <em>executors</em> on nodes in the cluster, which are processes that run computations and store data for your application，同时 executor返回心跳信息，当一个exceutor挂掉的时候可以开启另外一个exceutor</p><p><a href="http://spark.apache.org/docs/latest/cluster-overview.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/cluster-overview.html</a>)</p><p><strong>1.Application</strong>    ：基于Spark的应用程序 =  1 driver + executors<br>        User program built on Spark.<br>        Consists of a driver program and executors on the cluster.<br>        spark0402.py （这就是一个应用程序）<br>        pyspark/spark-shell（这也是）</p><p><strong>2.Driver program</strong><br>        The process running the main() function of the application<br>        creating the SparkContext    </p><p><strong>3.Cluster manager</strong><br>        An external service for acquiring resources on the cluster (e.g. standalone manager, Mesos, YARN)<br>        spark-submit –master local[2]/spark://hadoop000:7077/yarn(后面这些东西就是集群管理)</p><p><strong>4.Deploy mode</strong><br>        Distinguishes where the driver process runs.<br>            In “cluster” mode, the framework launches the driver inside of the cluster.<br>            In “client” mode, the submitter launches the driver outside of the cluster.<br>            <a href="https://www.cnblogs.com/bonelee/p/11032262.html" target="_blank" rel="noopener">Yarn-cluster VS Yarn-client</a><br>*<em>5.Worker node    *</em><br>        Any node that can run application code in the cluster<br>        standalone: slave节点 slaves配置文件<br>        yarn: nodemanager</p><p>*<em>6.Executor    *</em><br>        A process launched for an application on a worker node<br>        runs tasks<br>        keeps data in memory or disk storage across them<br>        Each application has its own executors.    </p><p>*<em>7.Task    *</em><br>        A unit of work that will be sent to one executor    </p><p><strong>8.Job    **<br>        A parallel computation consisting of multiple tasks that<br>        gets spawned in response to a Spark action (e.g. save, collect);<br>        you’ll see this term used in the driver’s logs.<br>        //一个action对应一个job，</strong>理解：job里面多个task，运行在executor里**//</p><p><strong>9.Stage</strong><br>        Each job gets divided into smaller sets of tasks called stages<br>        that depend on each other<br>        (similar to the map and reduce stages in MapReduce);<br>        you’ll see this term used in the driver’s logs.<br>        一个stage的边界往往是从某个地方取数据开始，到shuffle的结束</p><p><strong>另外的解释方式</strong></p><ol><li>job定义：<pre><code>我们都知道，在spark rdd中，有action、transform操作，当真正触发action时，才真正执行计算，此时产生一个job任务。</code></pre></li><li>stage定义：<pre><code>以shuffle为界，当在一个job任务中涉及shuffle操作时，会进行stage划分，产生一个或多个stage。</code></pre></li><li>task定义：<br>   一个stage可能包含一个或者多个task任务，task任务与partition、executor息息相关，即并行度。</li><li>partition定义：<br>  partition个数即rdd的分区数，不同的数据源读进来的数据分区数默认不同，可以通过repartition进行重分区操作。</li><li>executor定义：<br>  executor运行在work上，一个work可以运行一个或多个executor，一个executor可以运行一个或者多个task（取决于executor的core个数，默认是一个task占用一个core，即有多少个core就可以启动多少个task任务）</li><li>各个之间的关系图：</li></ol><p><img src="https://s2.ax1x.com/2020/01/09/lRXHAS.png" alt="lRXHAS.png"></p><p>​        一个work有一个或多个executor<br>​        一个executor有一个或者多个task（取决于executor的core个数）<br>​        一个task对应一个partition分区，即并行度（官网推荐partition分区数设置是task个数的2~3倍，充分利用资源）<br>​        一个stage有一个或多个task任务<br>​        一个job有一个或多个stage</p><p><strong>理解：job里面多个task，运行在executor里</strong></p><p><strong>hadoop与spark对比</strong></p><p><img src="https://s2.ax1x.com/2020/01/09/lRO7W9.png" alt="lRO7W9.png"></p><p><strong>10.Spark Cache</strong><br>        rdd.cache(): StorageLevel</p><p>​        cache它和tranformation: lazy   没有遇到action是不会提交作业到spark上运行的<br><img src="https://s2.ax1x.com/2020/01/12/lTA7NT.png" alt="lTA7NT.png"><br>​    如果一个RDD在后续的计算中可能会被使用到，那么建议cache<br>​<br>​        cache底层调用的是persist方法，传入的参数是：StorageLevel.MEMORY_ONLY<br>​        cache=persist<br>​<br>​        unpersist: 立即执行的</p><p><strong>11.Spark Lineage</strong>    </p><p><img src="https://s2.ax1x.com/2020/01/15/lOxDKA.png" alt="lOxDKA.png"></p><p>​        是一种RDD之间的依赖关系，可以有效的帮助容错。(当一个里面的RDD内的paritition丢失时，因为Lineage记录paritition的血缘关系)</p><p><strong>12.Spark Dependency(依赖)</strong></p><p><img src="https://s2.ax1x.com/2020/01/15/lOxHaV.png" alt="lOxHaV.png"></p><p>​        窄依赖：一个父RDD的partition至多被子RDD的某个partition使用一次    (<a href="https://blog.csdn.net/modefrog/article/details/79581176" target="_blank" rel="noopener">pipiline流水线</a>)</p><p>​        宽依赖：一个父RDD的partition会被子RDD的partition使用多次，有<a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html#shuffle-operations" target="_blank" rel="noopener">shuffle</a> (宽依赖的容错效果更差)</p><pre><code>hello,1hello,1       hello(相同的放在一起处理)world,1hello,1       worldworld,1</code></pre><p><strong>RDD的shuffle以及依赖关系</strong></p><p><img src="https://s2.ax1x.com/2020/01/15/lXPCCV.png" alt="lXPCCV.png"></p><p>正如上图，hdfs在三台机器上运行，左边前3个操作都是窄依赖(lines、words、pairs), 当遇到reduceByKey(宽依赖)时，会进行shuffle操作，同时也会变成两个stage。</p><p>sc.textFile(“file:///home/hadoop/data/hello.txt”).flatMap(lambda line: line.split(“\t”)).map(lambda x: (x, 1)).reduceByKey(lambda a, b: a + b).collect()</p><p><img src="https://s2.ax1x.com/2020/01/15/lXmn54.png" alt="lXmn54.png"></p><h2 id="Spark-Core调优"><a href="#Spark-Core调优" class="headerlink" title="Spark Core调优"></a>Spark Core调优</h2><h3 id="HistorySever-优化"><a href="#HistorySever-优化" class="headerlink" title="HistorySever 优化"></a>HistorySever 优化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>SPARK_HOME/sbin/</span><br><span class="line">./start-history-server.sh</span><br></pre></td></tr></table></figure><p>可以在./start-history-server.sh参看历史信息</p><h3 id="序列化优化"><a href="#序列化优化" class="headerlink" title="序列化优化"></a>序列化优化</h3><p>1.java 速度慢，简单，默认</p><p>2.kryo速度快，麻烦</p><h3 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h3><p>两大类：执行和存储 (一般各占一半)</p><h3 id="广播变量优化"><a href="#广播变量优化" class="headerlink" title="广播变量优化"></a>广播变量优化</h3><p>一个机器一个副本，可以减小副本的大小</p><p>###数据本地性优化</p><p>如果数据和节点在同一台机器上时，运行速度最快</p><p><strong>移动计算而不是移动数据！！</strong></p><h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><p>Spark SQL<br>    SQL:  MySQL、Oracle、DB2、SQLServer<br>    很多小伙伴熟悉SQL语言<br>    数据量越来越大 ==&gt; 大数据(Hive、Spark Core-基于RDD)<br>    直接使用SQL语句来对大数据进行分析：这是大家所追逐的梦想</p><pre><code>person.txt ==&gt; 存放在HDFS1,zhangsan,302,lisi,313,wangwu,32hive表：person    id:int   name:string  age:int导入数据：    load .....统计分析：    select ... from person    </code></pre><p>SQL on Hadoop<br>    Hive<br>    Impala: Cloudera<br>    Presto<br>    Drill<br>    …..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hive: on MapReduce (性能差)</span><br><span class="line">SQL =(翻译)=&gt; MapReduce =(提交到)=&gt; Hadoop Cluster</span><br><span class="line"></span><br><span class="line">Spark SQL: on Spark</span><br><span class="line"></span><br><span class="line">Hive on Spark (与上面的不同)</span><br><span class="line"></span><br><span class="line">共同点： metastore  mysql</span><br></pre></td></tr></table></figure><p>Spark SQL不仅仅是SQL这么简单的事情，它还能做更多的事情<br>    Hive: SQL<br>    Spark SQL: SQL</p><p>Spark SQL提供的操作数据的方式<br>    SQL<br>    DataFrame API<br>    Dataset API</p><p>===&gt; 一个用于处理结构化数据的Spark组件，强调的是“结构化数据”，而非“SQL”</p><p>Spark RDD  VS  MapReduce<br>R/Pandas :  one machine  (单机的)<br>    ==&gt; DataFrame：让小伙伴们感觉像开发单机版应用程序一样来开发分布式应用程序</p><p>A DataFrame is a Dataset organized into named columns (可以简单的把DataFrame理解成关系型数据库中的一个表，这是表层，底层其实做了更深的优化)<br>以列(列名、列类型、列值)的形式构成分布式的数据集</p><p><strong>面试题：RDD与DataFrame的区别</strong>12345</p><p>schema: 在SQL环境下，schema就是数据库对象的集合</p><p><a href="https://zhuanlan.zhihu.com/p/61631248" target="_blank" rel="noopener">区别</a></p><h3 id="RDD与DataFrame"><a href="#RDD与DataFrame" class="headerlink" title="RDD与DataFrame"></a>RDD与DataFrame</h3><p><strong>方法一：</strong></p><p><a href="http://spark.apache.org/docs/2.3.0/sql-programming-guide.html#inferring-the-schema-using-reflection" target="_blank" rel="noopener">Inferring the Schema Using Reflection</a></p><p>方法二：</p><p>下面的已运行过 8_8.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import data types</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">'spark0801'</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"><span class="comment"># Load a text file and convert each line to a Row.</span></span><br><span class="line">lines = sc.textFile(<span class="string">"file:///home/hadoop/app/spark-2.3.0-bin-2.6.0-cdh5.7.0/examples/src/main/resources/people.txt"</span>)</span><br><span class="line">parts = lines.map(<span class="keyword">lambda</span> l: l.split(<span class="string">","</span>))</span><br><span class="line"><span class="comment"># Each line is converted to a tuple.</span></span><br><span class="line">people = parts.map(<span class="keyword">lambda</span> p: (p[<span class="number">0</span>], p[<span class="number">1</span>].strip()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The schema is encoded in a string.</span></span><br><span class="line">schemaString = <span class="string">"name age"</span></span><br><span class="line"></span><br><span class="line">fields = [StructField(field_name, StringType(), <span class="literal">True</span>) <span class="keyword">for</span> field_name <span class="keyword">in</span> schemaString.split()]</span><br><span class="line">schema = StructType(fields)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the schema to the RDD.</span></span><br><span class="line">schemaPeople = spark.createDataFrame(people, schema)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a temporary view using the DataFrame</span></span><br><span class="line">schemaPeople.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">print(schemaPeople.printSchema())</span><br><span class="line"><span class="comment"># SQL can be run over DataFrames that have been registered as a table.</span></span><br><span class="line"><span class="comment"># results = spark.sql("SELECT name FROM people")</span></span><br><span class="line"></span><br><span class="line">print(schemaPeople.show())</span><br><span class="line">sc.stop()</span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |   name|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |Michael|</span></span><br><span class="line"><span class="comment"># |   Andy|</span></span><br><span class="line"><span class="comment"># | Justin|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br></pre></td></tr></table></figure><h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a><a href="http://spark.apache.org/docs/2.3.0/streaming-programming-guide.html" target="_blank" rel="noopener">Spark Streaming</a></h2><pre><code>is an extension of the core Spark API enables scalable, high-throughput, fault-tolerant stream processing of live data streams</code></pre><p>流： Java SE  IO<br>    输入: 山沟沟、下水道…    Kafka, Flume, Kinesis, or TCP sockets<br>    // TODO…  业务逻辑处理<br>    输出: 痛、瓶子….   filesystems, databases, and live dashboards</p><p>在线机器学习</p><p>Q:安装完Spark之后能否直接使用Spark Streaming?<br>A:YES</p><p>常用实时流处理框架对比<br>    Storm：真正的实时流处理  Tuple   Java<br>    Spark Streaming：并不是真正的实时流处理，而是一个mini batch操作(批处理)<br>        Scala、Java、Python  使用Spark一栈式解决问题<br>    Flink: 底层是流处理，可以做到批处理(和spark相反)<br>    Kafka Stream</p><p><img src="https://s2.ax1x.com/2020/03/09/89yWY4.png" alt="89yWY4.png"></p><p>Spark Streaming它的职责所在<br>    receives live input data streams<br>    divides the data into batches<br>    batches are then processed by the Spark engine<br>    to generate the final stream of results in batches.</p><p><img src="https://s2.ax1x.com/2020/03/09/89yH0K.png" alt="89yH0K.png"></p><p>Spark Core的核心抽象叫做：RDD  5大特性、对应源码中的5个方法是什么<br>Spark Streaming的核心抽象叫做：DStream<br>    represents a continuous stream of data<br>    DStreams can be created either from input data streams from sources such as Kafka, Flume, and Kinesis<br>    or by applying high-level operations on other DStreams.<br>    Internally, a DStream is represented as a sequence of RDDs.</p><h2 id="Azkaban基础篇-工作流插件-（必须在-bin-az-启动，否则报错）"><a href="#Azkaban基础篇-工作流插件-（必须在-bin-az-启动，否则报错）" class="headerlink" title="Azkaban基础篇(工作流插件)（必须在/bin/az..启动，否则报错）"></a>Azkaban基础篇(工作流插件)（必须在/bin/az..启动，否则报错）</h2><p>工作流概述<br>    请假  OA<br>        1 ：部门经理审批<br>        3 ：部门经理审批 ==&gt; HR<br>        5 ：部门经理审批 ==&gt; HR ==&gt; 老大<br>        10：…..<br>    借款： 涉及金额</p><p>Spark SQL/Hadoop用于做离线统计处理<br>ETL(<em>ETL</em>，是英文Extract-Transform-Load的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。)<br>1) 数据抽取：<br>    Sqoop把RDBMS中的数据抽取到Hadoop<br>    Flume进行日志、文本数据的采集，采集到Hadoop<br>2) 数据处理<br>    Hive/MapReduce/Spark/……<br>3) 统计结果入库<br>    数据就存放到HDFS(Hive/Spark SQL/文件)<br>        启动一个Server: HiveServer2 / ThriftServer<br>        jdbc的方式去访问统计结果<br>    使用Sqoop把结果导出到RDBMS中</p><p>这些作业之间是存在<strong>时间先后依赖</strong>关系的<br>Step A ==&gt; Step B ==&gt; Step C </p><p>crontab定时调度<br>为了更好的组织起这样的复杂执行计算的关系===&gt; 这就需要一个工作流调度系统来进行依赖关系作业的调度</p><p>Linux crontab + shell<br>    优点：简单、易用<br>    缺点：<br>        维护<br>        依赖<br>            step a:  01:30  30分钟<br>            step b:  02:10  30分钟<br>            step c:  02:50  30分钟<br>            …..<br>            资源利用率<br>            集群在0130压力非常大，资源没有申请到</p><p>常用的调度框架<br>    Azkaban：轻量级<br>    Oozie：重量级<br>        cm hue<br>        xml<br>    宙斯(Zeus)</p><p>Azkaban概述<br>    Open-source Workflow Manager<br>    批处理工作流，用于跑Hadoop的job<br>    提供了一个易于使用的用户界面来维护和跟踪你的工作流程</p><p>Azkaban架构<br>    Relational Database (MySQL)<br>    AzkabanWebServer<br>    AzkabanExecutorServer</p><p>Azkaban运行模式<br>    solo-server<br>        数据信息存储在H2==&gt;MySQL<br>        webserver和execserver是运行在同一个进程中婢女<br>    the heavier weight two server mode<br>        数据信息存储在MySQL，在生产上一定要做主备<br>        webserver和execserver是运行在不同的进程中的<br>    distributed multiple-executor mode</p><p>Azkaban编译：万世开头难，务必要保证你的网络速度不错(这里的编译是在对源码进行修改以后进行的)<br>    1） 去github上下载源码包<br>    2） ./gradlew build installDist<br>    3） 建议搭建先去下载gradle-4.1-all.zip 然后整合azkaban源码中来，避免在编译的过程中去网络上下载，导致编译速度非常慢<br>    4） 编译成功之后，去对应的目录下找到对应模式的安装包即可</p><p>Azkaban环境搭建<br>    1) 解压编译后的安装包到~/app<br>    2）启动azkaban   $AZKABAN_HOME/bin/azkaban-solo-start.sh<br>        验证：jps  AzkabanSingleServer<br>        ip:8081</p><h2 id="ES使用"><a href="#ES使用" class="headerlink" title="ES使用"></a>ES使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bin目录下</span><br><span class="line">./elasticsearch</span><br><span class="line"><span class="meta">#</span> 查看</span><br><span class="line">192.168.211.4:9200</span><br></pre></td></tr></table></figure><h2 id="kibana使用"><a href="#kibana使用" class="headerlink" title="kibana使用"></a>kibana使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana</span><br><span class="line"><span class="meta">#</span> 查看</span><br><span class="line">192.168.211.4:5601</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="大数据项目开发流程"><a href="#大数据项目开发流程" class="headerlink" title="大数据项目开发流程"></a>大数据项目开发流程</h3><p>1) 调研<br>    业务<br>2) 需求分析<br>    项目的需求<br>        显示<br>        隐式<br>    甘特图：项目周期管理<br>3) 方案设计<br>    概要设计<br>    详细设计<br>        基本要求<br>        系统要求：扩展性、容错性、高可用(HDFS YARN HA???)、定制化<br>4) 功能开发<br>    开发<br>    单元测试  junit<br>5) 测试<br>    测试环境 QA<br>    功能、性能、压力<br>    用户测试<br>6) 部署上线<br>    试运行   DIFF  “双活”<br>    正式上线<br>7) 运维<br>    7*24<br>8) 后期迭代开发</p><h3 id="大数据企业级应用"><a href="#大数据企业级应用" class="headerlink" title="大数据企业级应用"></a>大数据企业级应用</h3><p>1) 数据分析<br>    商业<br>    自研<br>2）搜索/引擎<br>    Lucene/Solr/ELK<br>3）机器学习<br>4) 精准营销<br>5) 人工智能</p><h3 id="企业级大数据分析平台"><a href="#企业级大数据分析平台" class="headerlink" title="企业级大数据分析平台"></a>企业级大数据分析平台</h3><p>1) 商业</p><p>2) 自研<br>    Apache<br>    CDH<br>    HDP</p><h3 id="数据量预估及集群规划"><a href="#数据量预估及集群规划" class="headerlink" title="数据量预估及集群规划"></a>数据量预估及集群规划</h3><p>Q: 一条日志多大、多少个字段、一天多少数据<br>300<del>500字节 * 1000W * 5 * 5  =  100G<br>HDFS 3副本 * 100G * (2</del>3年)</p><p>服务器一台：磁盘多少？ ==&gt; Node数量<br>    集群规模：数据量 + 存储周期</p><h3 id="集群机器规模："><a href="#集群机器规模：" class="headerlink" title="集群机器规模："></a>集群机器规模：</h3><pre><code>DN: 数据量大小/每个Node的磁盘大小NN: 2RM: 2NM: DNZK: 3/5/7/9GATEWAY: </code></pre><p>资源设置：cpu/memory/disk/network</p><h3 id="作业规划："><a href="#作业规划：" class="headerlink" title="作业规划："></a>作业规划：</h3><pre><code>MapReduce/Hive/SparkServer: ***** 调度：AZ、OOZIE</code></pre><p>数据来源：<a href="http://stateair.net/web/historical/1/1.html" target="_blank" rel="noopener">http://stateair.net/web/historical/1/1.html</a></p><p>根据北京的数据进行统计分析</p><p>同时间：北京 vs 广州 vs 成都</p><p>空气质量指数     pm2.5 健康建议<br>0-50          健康<br>51-100    中等<br>101-150  对敏感人群不健康<br>151-200   不健康<br>201-300 非常不健康<br>301-500 危险</p><blockquote><p>500   爆表</p></blockquote><p>数据分析==&gt;es==&gt;kibana</p><p>data2017 = spark.read.format(“csv”).option(“header”,”true”).option(“inferSchema”,”true”).load(“file:///home/hadoop/data/Beijing_2017_HourlyPM25_created20170803.csv”).select(“Year”,”Month”,”Day”,”Hour”,”Value”,”QC Name”)<br>data2016 = spark.read.format(“csv”).option(“header”,”true”).option(“inferSchema”,”true”).load(“file:///home/hadoop/data/Beijing_2016_HourlyPM25_created20170201.csv”).select(“Year”,”Month”,”Day”,”Hour”,”Value”,”QC Name”)<br>data2015 = spark.read.format(“csv”).option(“header”,”true”).option(“inferSchema”,”true”).load(“file:///home/hadoop/data/Beijing_2015_HourlyPM25_created20160201.csv”).select(“Year”,”Month”,”Day”,”Hour”,”Value”,”QC Name”)<br>data2017.show()<br>data2016.show()<br>data2015.show()<br>def get_grade(value):<br>    if value &lt;=50 and value &gt;=0:<br>        return “健康”<br>    elif value &lt;= 100:<br>        return “中等”<br>    elif value &lt;= 150:<br>        return “对敏感人群不健康”<br>    elif value &lt;= 200:<br>        return “不健康”<br>    elif value &lt;= 300:<br>        return “非常不健康”<br>    elif value &lt;= 500:<br>        return “危险”<br>    elif value &gt; 500:<br>        return “爆表”<br>    else:<br>        return None</p><pre><code># 进来一个Value，出去一个Grade</code></pre><p>group2017 = data2017.withColumn(“Grade”,grade_function_udf(data2017[‘Value’])).groupBy(“Grade”).count()<br>group2016 = data2016.withColumn(“Grade”,grade_function_udf(data2016[‘Value’])).groupBy(“Grade”).count()<br>group2015 = data2015.withColumn(“Grade”,grade_function_udf(data2015[‘Value’])).groupBy(“Grade”).count()</p><p>group2017.show()<br>group2016.show()<br>group2015.show()</p><p>使用SparkSQL将统计结果写入到ES中去</p><p>from pyspark.sql.functions import *<br>from pyspark.sql.types import *</p><p>def get_grade(value):<br>    if value &lt;= 50:<br>        return “健康”<br>    elif value &lt;= 100:<br>        return “中等”<br>    elif value &lt;= 150:<br>        return “对敏感人群不健康”<br>    elif value &lt;= 200:<br>        return “不健康”<br>    elif value &lt;= 300:<br>        return “非常不健康”<br>    elif value &lt;= 500:<br>        return “危险”<br>    elif value &gt; 500:<br>        return “爆表”<br>    else:<br>        return None</p><p>data2017 = spark.read.format(“csv”).option(“header”,”true”).option(“inferSchema”,”true”).load(“/data/Beijing_2017_HourlyPM25_created20170803.csv”).select(“Year”,”Month”,”Day”,”Hour”,”Value”,”QC Name”)<br>grade_function_udf = udf(get_grade, StringType())<br>group2017 = data2017.withColumn(“Grade”, grade_function_udf(data2017[‘Value’])).groupBy(“Grade”).count()<br>result2017_2 = group2017.select(“Grade”, “count”, group2017[‘count’] / data2017.count()*100)</p><p>result2017_2=group2017.select(“Grade”, “count”).withColumn(“precent”,group2017[‘count’] / data2017.count()*100)</p><p>result2017_2.selectExpr(“Grade as grade”, “count”, “precent”).write.format(“org.elasticsearch.spark.sql”).option(“es.nodes”,”192.168.199.102:9200”).mode(“overwrite”).save(“weaes/weather”)</p><p>练习：<br>1) 同一个城市不同年份的对比<br>2）相同年份的不同城市的对比</p><p>3) 月份为统计维度：3-1 3-2<br>4) 小时为统计维度</p><p>curl -XPOST ‘<a href="http://hadoop000:9200/imooc_es/student/1&#39;" target="_blank" rel="noopener">http://hadoop000:9200/imooc_es/student/1&#39;</a> -H ‘Content-Type: application/json’ -d ‘{<br>“name”:”imooc”,<br>“age”:5,<br>“interests”:[“Spark”,”Hadoop”]<br>}’</p><p>ek后台启动： nohup …. &amp; </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>克隆虚拟机</title>
      <link href="/2019/12/17/%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2019/12/17/%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.克隆虚拟机</span><br><span class="line">2.克隆后的虚拟机配置</span><br><span class="line">sudo -i</span><br><span class="line">修改网卡信息</span><br><span class="line">vi /etc/udev/rules.d/70-persistent-net.rules </span><br><span class="line"></span><br><span class="line">修改主机名</span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">修改ip信息</span><br><span class="line">(改UUID的一个数字、ipaddr末尾改一个、HWADDR换成网卡的MAC地址)</span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0 </span><br><span class="line"></span><br><span class="line">修改映射</span><br><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">重启网卡</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术原理与应用</title>
      <link href="/2019/11/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2019/11/13/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="hadoop的启动"><a href="#hadoop的启动" class="headerlink" title="hadoop的启动"></a>hadoop的启动</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop</span><br><span class="line">./sbin/start-dfs.sh #启动hadoop</span><br></pre></td></tr></table></figure><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>HDFS的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop</span><br><span class="line">../bin/hdfs dfs +命令</span><br></pre></td></tr></table></figure><p>用<strong>shell</strong>命令将本地文件上传到<strong>HDFS</strong>中</p><h3 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1. 目录操作"></a>1. 目录操作</h3><p>需要注意的是，Hadoop系统安装好以后，第一次使用HDFS时，需要首先在HDFS中创建用户目录。本教程全部采用hadoop用户登录Linux系统，因此，需要在HDFS中为hadoop用户创建一个用户目录，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop./bin/hdfs dfs –mkdir –p /user/hadoop</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>该命令中表示在HDFS中创建一个“/user/hadoop”目录，“–mkdir”是创建目录的操作，“-p”表示如果是多级目录，则父目录和子目录一起创建，这里“/user/hadoop”就是一个多级目录，因此必须使用参数“-p”，否则会出错。<br>“/user/hadoop”目录就成为hadoop用户对应的用户目录，可以使用如下命令显示HDFS中与当前用户hadoop对应的用户目录下的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –ls .</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>该命令中，“-ls”表示列出HDFS某个目录下的所有内容，“.”表示HDFS中的当前用户目录，也就是“/user/hadoop”目录，因此，上面的命令和下面的命令是等价的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –ls /user/hadoop</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>如果要列出HDFS上的所有目录，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –ls</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>下面，可以使用如下命令创建一个input目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –mkdir input</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>在创建个input目录时，采用了相对路径形式，实际上，这个input目录创建成功以后，它在HDFS中的完整路径是“/user/hadoop/input”。如果要在HDFS的根目录下创建一个名称为input的目录，则需要使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –mkdir /input</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>可以使用rm命令删除一个目录，比如，可以使用如下命令删除刚才在HDFS中创建的“/input”目录（不是“/user/hadoop/input”目录）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –rm –r /input</span><br></pre></td></tr></table></figure><p>Shell 命令</p><p>上面命令中，“-r”参数表示如果删除“/input”目录及其子目录下的所有内容，如果要删除的一个目录包含了子目录，则必须使用“-r”参数，否则会执行失败。</p><h3 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在实际应用中，经常需要从本地文件系统向HDFS中上传文件，或者把HDFS中的文件下载到本地文件系统中。</span><br><span class="line">首先，使用vim编辑器，在本地Linux文件系统的“/home/hadoop/”目录下创建一个文件myLocalFile.txt，里面可以随意输入一些单词，比如，输入如下三行：</span><br><span class="line">Hadoop</span><br><span class="line">Spark</span><br><span class="line">XMU DBLAB</span><br></pre></td></tr></table></figure><p>然后，可以使用如下命令把本地文件系统的“/home/hadoop/myLocalFile.txt”上传到HDFS中的当前用户目录的input目录下，也就是上传到HDFS的“/user/hadoop/input/”目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -put /home/hadoop/myLocalFile.txt  input</span><br></pre></td></tr></table></figure><p>可以使用ls命令查看一下文件是否成功上传到HDFS中，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –ls input1</span><br></pre></td></tr></table></figure><p>该命令执行后会显示类似如下的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found 1 items   </span><br><span class="line">-rw-r--r--   1 hadoop supergroup         36 2017-01-02 23:55 input/ myLocalFile.txt</span><br></pre></td></tr></table></figure><p>下面使用如下命令查看HDFS中的myLocalFile.txt这个文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs –cat input1/myLocalFile.txt</span><br></pre></td></tr></table></figure><p>下面把HDFS中的myLocalFile.txt文件下载到本地文件系统中的“/home/hadoop/下载/”这个目录下，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -get input1/myLocalFile.txt  /home/hadoop/下载</span><br></pre></td></tr></table></figure><p>可以使用如下命令，到本地文件系统查看下载下来的文件myLocalFile.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~<span class="built_in">cd</span> 下载lscat myLocalFile.txt</span><br></pre></td></tr></table></figure><p>最后，了解一下如何把文件从HDFS中的一个目录拷贝到HDFS中的另外一个目录。比如，如果要把HDFS的“/user/hadoop/input/myLocalFile.txt”文件，拷贝到HDFS的另外一个目录“/input”中（注意，这个input目录位于HDFS根目录下），可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -cp input/myLocalFile.txt  /input</span><br></pre></td></tr></table></figure><p><strong>可在 <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a> 中查看自己上传的文件</strong></p><p>###3.用<strong>pyhdfs</strong>对文件进行操作：(先启动hadoop)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyhdfs</span><br><span class="line"></span><br><span class="line">client = pyhdfs.HdfsClient(hosts=<span class="string">"localhost,50070"</span>,user_name=<span class="string">"hadoop"</span>)</span><br><span class="line"></span><br><span class="line">print(client.listdir(<span class="string">"/user/hadoop/input"</span>)) <span class="comment"># 返回指定目录下的所有文件</span></span><br><span class="line"></span><br><span class="line">response = client.open(<span class="string">"/user/hadoop/input/test.txt"</span>) <span class="comment"># 打开文件 并读取</span></span><br><span class="line">print(response.read())</span><br><span class="line"></span><br><span class="line">print(client.exists(<span class="string">'/user/hadoop/input/test.txt'</span>)) <span class="comment"># 判断文件是否存在</span></span><br><span class="line"></span><br><span class="line">print(client.get_home_directory()) <span class="comment"># 返回 用户的根目录</span></span><br><span class="line"></span><br><span class="line">print(client.get_active_namenode()) <span class="comment"># 返回可用的namenode节点</span></span><br></pre></td></tr></table></figure><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>启动HBase</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.启动hadoop (启动后输入jps后可以看大盘Name(data/secondary)Node)</span><br><span class="line">ssh localhost</span><br><span class="line">cd /usr/local/hadoop</span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">2.启动HBase</span><br><span class="line">cd /usr/local/hbase</span><br><span class="line">bin/start-hbase.sh</span><br><span class="line">进入shell界面</span><br><span class="line">bin/hbase shell</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010416101/article/details/89186320" title="CSDN" target="_blank" rel="noopener">HBase Shell 基本使用</a></p><h1 id="MAPREDUCE"><a href="#MAPREDUCE" class="headerlink" title="MAPREDUCE"></a>MAPREDUCE</h1><p><a href="https://blog.csdn.net/weixin_41768073/article/details/82830833" target="_blank" rel="noopener">MapReduce理解</a></p><h1 id="HIVE"><a href="#HIVE" class="headerlink" title="HIVE"></a>HIVE</h1><p>采用MySQL数据库保存Hive的元数据，而不是采用Hive自带的derby来存储元数据。</p><p>hive的启动(先启动hadoop)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop</span><br><span class="line">./sbin/start-all.sh</span><br><span class="line">cd /usr/local/hive</span><br><span class="line">./bin/hive</span><br></pre></td></tr></table></figure><p><a href="http://dblab.xmu.edu.cn/blog/1080-2/" target="_blank" rel="noopener">hive基本命令</a> (sql语言)</p><h3 id="Hive简单编程实践"><a href="#Hive简单编程实践" class="headerlink" title="Hive简单编程实践"></a>Hive简单编程实践</h3><p>1.先上传本地文件到HDFS中(参考前面的)</p><p>2.进入HIVE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> docs(line <span class="keyword">string</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'文件夹或者文件目录'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> docs;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> word_count <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> word, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(line,<span class="string">' '</span>))<span class="keyword">as</span> word <span class="keyword">from</span> docs) w</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> word</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> word;</span><br></pre></td></tr></table></figure><p>执行后，用select语句查看，结果如下：</p><p><img src="https://s2.ax1x.com/2019/11/26/MzCEes.png" alt="MzCEes.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> BD </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习</title>
      <link href="/2019/10/14/MySQL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/14/MySQL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><blockquote><p>VIM一些命令</p><p>退出vim的快捷键，不需要进入命令编辑模式</p><p>按住shift</p><p>CTRL+Z 退出</p><p>zz    保存退出</p><p>zq    不保存退出，q表示放弃</p><p>之所以按住shift，其实是切换大小写</p><p>在命令编辑模式下：</p><p>:q 不保存退出</p><p>:q! 不保存强制退出</p><p>:wq 保存退出，w表示写入，不论是否修改，都会更改时间戳</p><p>:x     保存退出，如果内容未改，不会更改时间戳</p></blockquote><p>DB(database)</p><p>DBMS(DB Management System)数据库管理系统，C/S  客户端/服务端</p><p>SQL(Structure Query L)语言</p><blockquote><p>  SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。</p><p>\1. <strong>数据查询语言DQL</strong><br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE<br>子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p><p>2 .<strong>数据操纵语言DML</strong><br>数据操纵语言DML主要有三种形式：<br>1) 插入：INSERT<br>2) 更新：UPDATE<br>3) 删除：DELETE</p><p>\3. 数据定义语言DDL<br>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>| | | | |<br>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p>\4. 数据控制语言DCL<br>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：<br>1) GRANT：授权。</p><p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>回滚—ROLLBACK<br>回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</p><p>3) COMMIT [WORK]：提交。  </p></blockquote><p>列—&gt;字段 行–&gt;记录</p><p><img src="https://s2.ax1x.com/2019/10/25/KaquX6.png" alt="KaquX6.png"></p><p>DBA数据库管理员(职务)</p><p>cmd进sql  C:\Windows\system32&gt;mysql -h localhost -P3306 -u root -p</p><p>连接本机可以简化为 C:\Windows\system32&gt;mysql -u root -p</p><blockquote><p>sql命令后面加;</p></blockquote><p>mysql中<code>+</code>只作为   数值加法</p><p>CONCAT(  ,  )是拼接</p><p>DESC 表名 ； 显示表的结构 </p><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名;</span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">列名 列类型,</span><br><span class="line">列名 列类型，</span><br><span class="line">。。。</span><br><span class="line">);</span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.不区分大小写,但建议关键字大写， 表名、列名小写</span><br><span class="line">2.每条命令最好用分号结尾</span><br><span class="line">3.每条命令根据需要，可以进行缩进 或换行</span><br><span class="line">4.注释</span><br><span class="line">单行注释：#注释文字</span><br><span class="line">单行注释：-- 注释文字</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line">show tables ; 显示库中的所有表</span><br><span class="line">show tables from 库名;显示指定库中的所有表</span><br><span class="line">create table 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line">select * from 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">SELECT 要查询的东西</span><br><span class="line">【FROM 表名】;</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</span><br><span class="line">② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</span><br><span class="line">可以直接双击表 不用打字了!</span><br><span class="line">F12可以整理格式</span><br></pre></td></tr></table></figure><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">语法：</span><br><span class="line">select </span><br><span class="line">要查询的字段|表达式|常量值|函数</span><br><span class="line">from </span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件 ;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">一、条件表达式</span><br><span class="line">示例：salary&gt;10000</span><br><span class="line">条件运算符：</span><br><span class="line">&gt; &lt; &gt;= &lt;= = != &lt;&gt;</span><br><span class="line"></span><br><span class="line">二、逻辑表达式</span><br><span class="line">示例：salary&gt;10000 &amp;&amp; salary&lt;20000</span><br><span class="line"></span><br><span class="line">逻辑运算符：</span><br><span class="line"></span><br><span class="line">and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</span><br><span class="line">or(||)：两个条件只要有一个成立，结果为true，否则为false</span><br><span class="line">not(!)：如果条件成立，则not后为false，否则为true</span><br><span class="line"></span><br><span class="line">三、模糊查询</span><br><span class="line">示例：last_name like &apos;a%&apos;</span><br><span class="line">IS NULL  IS NOT NULL</span><br><span class="line">IN</span><br><span class="line">安全等于&lt;=&gt;</span><br></pre></td></tr></table></figure><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select</span><br><span class="line">要查询的东西</span><br><span class="line">from</span><br><span class="line">表</span><br><span class="line">where </span><br><span class="line">条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 【asc|desc】</span><br></pre></td></tr></table></figure><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">一、单行函数</span><br><span class="line">1、字符函数</span><br><span class="line">concat拼接</span><br><span class="line">substr截取子串</span><br><span class="line">upper转换成大写</span><br><span class="line">lower转换成小写</span><br><span class="line">trim去前后指定的空格和字符</span><br><span class="line">ltrim去左边空格</span><br><span class="line">rtrim去右边空格</span><br><span class="line">replace替换</span><br><span class="line">lpad左填充</span><br><span class="line">rpad右填充</span><br><span class="line">instr返回子串第一次出现的索引</span><br><span class="line">length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">round 四舍五入</span><br><span class="line">rand 随机数</span><br><span class="line">floor向下取整</span><br><span class="line">ceil向上取整</span><br><span class="line">mod取余</span><br><span class="line">truncate截断</span><br><span class="line">3、日期函数</span><br><span class="line">now当前系统日期+时间</span><br><span class="line">curdate当前系统日期</span><br><span class="line">curtime当前系统时间</span><br><span class="line">str_to_date 将字符转换成日期</span><br><span class="line">date_format将日期转换成字符</span><br><span class="line">datadiff(&apos;2019-02-01&apos;,&apos;2019-1-1&apos;)前面的日期减后面的  </span><br><span class="line">4、流程控制函数</span><br><span class="line">if(判断条件，1，0)</span><br><span class="line">case 要判断的字段和表达式</span><br><span class="line"> when 常量1 then 要显示的值1或语句1</span><br><span class="line"> when 常量2 then 要显示的值2或语句2</span><br><span class="line"> else 要显示的值n</span><br><span class="line"> end</span><br><span class="line">(在最后一条后面加；)</span><br><span class="line"></span><br><span class="line">多重if</span><br><span class="line">case</span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">5、其他函数</span><br><span class="line">version版本</span><br><span class="line">database当前库</span><br><span class="line">user当前连接用户</span><br></pre></td></tr></table></figure><p>​    </p><p>二、分组函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1、以上五个分组函数都忽略null值，除了count(*)</span><br><span class="line">2、sum和avg一般用于处理数值型</span><br><span class="line">max、min、count可以处理任何数据类型</span><br><span class="line">   3、都可以搭配distinct使用，用于统计去重后的结果(只能去重一个)</span><br><span class="line">4、count的参数可以支持：</span><br><span class="line">字段、*、常量值，一般放1</span><br><span class="line"></span><br><span class="line">   建议使用 count(*) -----可以用来统计个数</span><br><span class="line">   eg：查询部门编号为90的员工个数</span><br><span class="line">   SELECT COUNT(*) 个数</span><br><span class="line">   FROM employees</span><br><span class="line">   WHERE department_id = 90;</span><br><span class="line">6、和分组函数一同查询的字段有限制（意义上的）要求是 group by 后面的字段</span><br></pre></td></tr></table></figure><h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表</span><br><span class="line">group by 分组的字段</span><br></pre></td></tr></table></figure><p>​    特点：<br>​    1、可以按单个字段分组<br>​    2、和分组函数一同查询的字段最好是分组后的字段<br>​    3、分组筛选<br>​            针对的表    位置            关键字<br>​    分组前筛选：    原始表        group by的前面        where<br>​    分组后筛选：    分组后的结果集    group by的后面        having<br>​<br>​    4、可以按多个字段分组，字段之间用逗号隔开<br>​    5、可以支持排序<br>​    6、having后可以支持别名</p><h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">笛卡尔乘积：如果连接条件省略或无效则会出现</span><br><span class="line">解决办法：添加上连接条件</span><br></pre></td></tr></table></figure><p>一、传统模式下的连接 ：等值连接——非等值连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.等值连接的结果 = 多个表的交集</span><br><span class="line">2.n表连接，至少需要n-1个连接条件</span><br><span class="line">3.多个表不分主次，没有顺序要求</span><br><span class="line">4.一般为表起别名，提高阅读性和性能</span><br></pre></td></tr></table></figure><p>二、sql99语法：通过join关键字实现连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">含义：1999年推出的sql语法</span><br><span class="line">支持：</span><br><span class="line">等值连接、非等值连接 （内连接）</span><br><span class="line">外连接</span><br><span class="line">交叉连接</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">select 字段，...</span><br><span class="line">from 表1</span><br><span class="line">【inner|left outer|right outer|cross】join 表2 on  连接条件</span><br><span class="line">【inner|left outer|right outer|cross】join 表3 on  连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br><span class="line"></span><br><span class="line">好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</span><br></pre></td></tr></table></figure><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m ON e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><p>sql92</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e,employees m </span><br><span class="line">WHERE e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure><h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure><p>特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.起始条目索引从0开始</span><br><span class="line"></span><br><span class="line">2.limit子句放在查询语句的最后</span><br><span class="line"></span><br><span class="line">3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure><h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure><p>特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">2、多条查询语句的查询的列的类型几乎相同</span><br><span class="line">3、union代表去重，union all代表不去重</span><br></pre></td></tr></table></figure><h1 id="黑马程序员"><a href="#黑马程序员" class="headerlink" title="黑马程序员"></a>黑马程序员</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br></pre></td><td class="code"><pre><span class="line">-- 数据库的操作</span><br><span class="line"></span><br><span class="line">    -- 链接数据库</span><br><span class="line">    mysql -uroot -p</span><br><span class="line">    mysql -uroot -pmysql</span><br><span class="line"></span><br><span class="line">    -- 退出数据库</span><br><span class="line">    exit/quit/ctrl+d</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- sql语句最后需要有分号;结尾</span><br><span class="line">    -- 显示数据库版本</span><br><span class="line">    select version();</span><br><span class="line"></span><br><span class="line">    -- 显示时间</span><br><span class="line">    select now();</span><br><span class="line"></span><br><span class="line">    -- 查看所有数据库</span><br><span class="line">    show databases;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- 创建数据库</span><br><span class="line">    -- create database 数据库名 charset=utf8;</span><br><span class="line">    create database python04;</span><br><span class="line">    create database python04new charset=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 查看创建数据库的语句</span><br><span class="line">    -- show crate database ....</span><br><span class="line">    show create database python04;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- 查看当前使用的数据库</span><br><span class="line">    select database();</span><br><span class="line"></span><br><span class="line">    -- 使用数据库</span><br><span class="line">    -- use 数据库的名字</span><br><span class="line">    use python04new;</span><br><span class="line"></span><br><span class="line">    -- 删除数据库</span><br><span class="line">    -- drop database 数据库名;</span><br><span class="line">    drop database python04;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 数据表的操作</span><br><span class="line"></span><br><span class="line">    -- 查看当前数据库中所有表</span><br><span class="line">    show tables;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- 创建表</span><br><span class="line">    -- auto_increment表示自动增长</span><br><span class="line">    -- not null 表示不能为空</span><br><span class="line">    -- primary key 表示主键</span><br><span class="line">    -- default 默认值</span><br><span class="line">    -- create table 数据表名字 (字段 类型 约束[, 字段 类型 约束]);</span><br><span class="line">    create table xxxxx(id int, name varchar(30));</span><br><span class="line">    create table yyyyy(id int primary key not null auto_increment, name varchar(30));</span><br><span class="line">    create table zzzzz(</span><br><span class="line">        id int primary key not null auto_increment,</span><br><span class="line">        name varchar(30)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    -- 查看表结构</span><br><span class="line">    -- desc 数据表的名字;</span><br><span class="line">    desc xxxxx;</span><br><span class="line"></span><br><span class="line">    -- 创建students表(id、name、age、high、gender、cls_id)</span><br><span class="line">    create table students(</span><br><span class="line">        id int unsigned not null auto_increment primary key,</span><br><span class="line">        name varchar(30),</span><br><span class="line">        age tinyint unsigned default 0,</span><br><span class="line">        high decimal(5,2),</span><br><span class="line">        gender enum(&quot;男&quot;, &quot;女&quot;, &quot;中性&quot;, &quot;保密&quot;) default &quot;保密&quot;,</span><br><span class="line">        cls_id int unsigned</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    insert into students values(0, &quot;老王&quot;, 18, 188.88, &quot;男&quot;, 0);</span><br><span class="line">    select * from students;</span><br><span class="line"></span><br><span class="line">    -- 创建classes表(id、name)</span><br><span class="line">    create table classes(</span><br><span class="line">        id int unsigned not null auto_increment primary key,</span><br><span class="line">        name varchar(30)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    insert into classes values(0, &quot;python04大神&quot;);</span><br><span class="line">    select * from classes;</span><br><span class="line"></span><br><span class="line">    -- 查看表的创建语句</span><br><span class="line">    -- show create table 表名字;</span><br><span class="line">    show create table students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 修改表-添加字段</span><br><span class="line">    -- alter table 表名 add 列名 类型;</span><br><span class="line">    alter table students add birthday datetime;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- 修改表-修改字段：不重命名版</span><br><span class="line">    -- alter table 表名 modify 列名 类型及约束;</span><br><span class="line">    alter table students modify birthday date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 修改表-修改字段：重命名版</span><br><span class="line">    -- alter table 表名 change 原名 新名 类型及约束;</span><br><span class="line">    alter table students change birthday birth date default &quot;2000-01-01&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 修改表-删除字段</span><br><span class="line">    -- alter table 表名 drop 列名;</span><br><span class="line">    alter table students drop high;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 删除表</span><br><span class="line">    -- drop table 表名;</span><br><span class="line">    -- drop database 数据库;</span><br><span class="line">    -- drop table 数据表;</span><br><span class="line">    drop table xxxxx;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">-- 增删改查(curd)</span><br><span class="line"></span><br><span class="line">    -- 增加</span><br><span class="line">        -- 全列插入</span><br><span class="line">        -- insert [into] 表名 values(...)</span><br><span class="line">        -- 主键字段 可以用 0  null   default 来占位</span><br><span class="line">        -- 向classes表中插入 一个班级</span><br><span class="line">        insert into classes values(0, &quot;菜鸟班&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        +--------+-------------------------------------+------+-----+------------+----------------+</span><br><span class="line">        | Field  | Type                                | Null | Key | Default    | Extra          |</span><br><span class="line">        +--------+-------------------------------------+------+-----+------------+----------------+</span><br><span class="line">        | id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment |</span><br><span class="line">        | name   | varchar(30)                         | YES  |     | NULL       |                |</span><br><span class="line">        | age    | tinyint(3) unsigned                 | YES  |     | 0          |                |</span><br><span class="line">        | gender | enum(&apos;男&apos;,&apos;女&apos;,&apos;中性&apos;,&apos;保密&apos;)       | YES  |     | 保密       |                |</span><br><span class="line">        | cls_id | int(10) unsigned                    | YES  |     | NULL       |                |</span><br><span class="line">        | birth  | date                                | YES  |     | 2000-01-01 |                |</span><br><span class="line">        +--------+-------------------------------------+------+-----+------------+----------------+</span><br><span class="line"></span><br><span class="line">        -- 向students表插入 一个学生信息</span><br><span class="line">        insert into students values(0, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);</span><br><span class="line">        insert into students values(null, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);</span><br><span class="line">        insert into students values(default, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);</span><br><span class="line"></span><br><span class="line">        -- 失败</span><br><span class="line">        -- insert into students values(default, &quot;小李飞刀&quot;, 20, &quot;第4性别&quot;, 1, &quot;1990-02-01&quot;);</span><br><span class="line"></span><br><span class="line">        -- 枚举中 的 下标从1 开始 1---“男” 2---&gt;&quot;女&quot;....</span><br><span class="line">        insert into students values(default, &quot;小李飞刀&quot;, 20, 1, 1, &quot;1990-02-01&quot;);</span><br><span class="line"></span><br><span class="line">        -- 部分插入</span><br><span class="line">        -- insert into 表名(列1,...) values(值1,...)</span><br><span class="line">        insert into students (name, gender) values (&quot;小乔&quot;, 2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        -- 多行插入</span><br><span class="line">        insert into students (name, gender) values (&quot;大乔&quot;, 2),(&quot;貂蝉&quot;, 2);</span><br><span class="line">        insert into students values(default, &quot;西施&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;), (default, &quot;王昭君&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -- 修改</span><br><span class="line">    -- update 表名 set 列1=值1,列2=值2... where 条件;</span><br><span class="line">        update students set gender=1; -- 全部都改</span><br><span class="line">        update students set gender=1 where name=&quot;小李飞刀&quot;; -- 只要name是小李飞刀的 全部的修改</span><br><span class="line">        update students set gender=1 where id=3; -- 只要id为3的 进行修改</span><br><span class="line">        update students set age=22, gender=1 where id=3; -- 只要id为3的 进行修改</span><br><span class="line">    </span><br><span class="line">    -- 查询基本使用</span><br><span class="line">        -- 查询所有列</span><br><span class="line">        -- select * from 表名;</span><br><span class="line">        select * from students;</span><br><span class="line"></span><br><span class="line">        ---定条件查询</span><br><span class="line">        select * from students where name=&quot;小李飞刀&quot;; -- 查询 name为小李飞刀的所有信息</span><br><span class="line">        select * from students where id&gt;3; -- 查询 name为小李飞刀的所有信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        -- 查询指定列</span><br><span class="line">        -- select 列1,列2,... from 表名;</span><br><span class="line">        select name,gender from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        -- 可以使用as为列或表指定别名</span><br><span class="line">        -- select 字段[as 别名] , 字段[as 别名] from 数据表 where ....;</span><br><span class="line">        select name as 姓名,gender as 性别 from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        -- 字段的顺序</span><br><span class="line">        select id as 序号, gender as 性别, name as 姓名 from students;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    -- 删除</span><br><span class="line">        -- 物理删除</span><br><span class="line">        -- delete from 表名 where 条件</span><br><span class="line">        delete from students; -- 整个数据表中的所有数据全部删除</span><br><span class="line">        delete from students where name=&quot;小李飞刀&quot;;</span><br><span class="line"></span><br><span class="line">        -- 逻辑删除</span><br><span class="line">        -- 用一个字段来表示 这条信息是否已经不能再使用了</span><br><span class="line">        -- 给students表添加一个is_delete字段 bit 类型</span><br><span class="line">        alter table students add is_delete bit default 0;</span><br><span class="line">        update students set is_delete=1 where id=6;</span><br><span class="line"></span><br><span class="line">-- 数据的准备</span><br><span class="line">-- 创建一个数据库</span><br><span class="line">create database python_test charset=utf8;</span><br><span class="line"></span><br><span class="line">-- 使用一个数据库</span><br><span class="line">use python_test;</span><br><span class="line"></span><br><span class="line">-- 显示使用的当前数据是哪个?</span><br><span class="line">select database();</span><br><span class="line"></span><br><span class="line">-- 创建一个数据表</span><br><span class="line">-- students表</span><br><span class="line">create table students(</span><br><span class="line">    id int unsigned primary key auto_increment not null,</span><br><span class="line">    name varchar(20) default &apos;&apos;,</span><br><span class="line">    age tinyint unsigned default 0,</span><br><span class="line">    height decimal(5,2),</span><br><span class="line">    gender enum(&apos;男&apos;,&apos;女&apos;,&apos;中性&apos;,&apos;保密&apos;) default &apos;保密&apos;,</span><br><span class="line">    cls_id int unsigned default 0,</span><br><span class="line">    is_delete bit default 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- classes表</span><br><span class="line">create table classes (</span><br><span class="line">    id int unsigned auto_increment primary key not null,</span><br><span class="line">    name varchar(30) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询</span><br><span class="line">-- 查询所有字段</span><br><span class="line">-- select * from 表名;</span><br><span class="line">select * from students;</span><br><span class="line">select * from classes;</span><br><span class="line">select id, name from classes;</span><br><span class="line"></span><br><span class="line">-- 查询指定字段</span><br><span class="line">-- select 列1,列2,... from 表名;</span><br><span class="line">select name, age from students;</span><br><span class="line"></span><br><span class="line">-- 使用 as 给字段起别名</span><br><span class="line">-- select 字段 as 名字.... from 表名;</span><br><span class="line">select name as 姓名, age as 年龄 from students;</span><br><span class="line"></span><br><span class="line">-- select 表名.字段 .... from 表名;</span><br><span class="line">select students.name, students.age from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 可以通过 as 给表起别名</span><br><span class="line">-- select 别名.字段 .... from 表名 as 别名;</span><br><span class="line">select students.name, students.age from students;</span><br><span class="line">select s.name, s.age from students as s;</span><br><span class="line">-- 失败的select students.name, students.age from students as s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 消除重复行</span><br><span class="line">-- distinct 字段</span><br><span class="line">select distinct gender from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 条件查询</span><br><span class="line">-- 比较运算符</span><br><span class="line">-- select .... from 表名 where .....</span><br><span class="line">-- &gt;</span><br><span class="line">-- 查询大于18岁的信息</span><br><span class="line">select * from students where age&gt;18;</span><br><span class="line">select id,name,gender from students where age&gt;18;</span><br><span class="line"></span><br><span class="line">-- &lt;</span><br><span class="line">-- 查询小于18岁的信息</span><br><span class="line">select * from students where age&lt;18;</span><br><span class="line"></span><br><span class="line">-- &gt;=</span><br><span class="line">-- &lt;=</span><br><span class="line">-- 查询小于或者等于18岁的信息</span><br><span class="line"></span><br><span class="line">-- =</span><br><span class="line">-- 查询年龄为18岁的所有学生的名字</span><br><span class="line">select * from students where age=18;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- != 或者 &lt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 逻辑运算符</span><br><span class="line">-- and</span><br><span class="line">-- 18到28之间的所以学生信息</span><br><span class="line">select * from students where age&gt;18 and age&lt;28;</span><br><span class="line">-- 失败select * from students where age&gt;18 and &lt;28;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 18岁以上的女性</span><br><span class="line">select * from students where age&gt;18 and gender=&quot;女&quot;;</span><br><span class="line">select * from students where age&gt;18 and gender=2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- or</span><br><span class="line">-- 18以上或者身高查过180(包含)以上</span><br><span class="line">select * from students where age&gt;18 or height&gt;=180;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- not</span><br><span class="line">-- 不在 18岁以上的女性 这个范围内的信息</span><br><span class="line">-- select * from students where not age&gt;18 and gender=2;</span><br><span class="line">select * from students where not (age&gt;18 and gender=2);</span><br><span class="line"></span><br><span class="line">-- 年龄不是小于或者等于18 并且是女性</span><br><span class="line">select * from students where (not age&lt;=18) and gender=2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 模糊查询</span><br><span class="line">-- like </span><br><span class="line">-- % 替换1个或者多个</span><br><span class="line">-- _ 替换1个</span><br><span class="line">-- 查询姓名中 以 &quot;小&quot; 开始的名字</span><br><span class="line">select name from students where name=&quot;小&quot;;</span><br><span class="line">select name from students where name like &quot;小%&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询姓名中 有 &quot;小&quot; 所有的名字</span><br><span class="line">select name from students where name like &quot;%小%&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询有2个字的名字</span><br><span class="line">select name from students where name like &quot;__&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询有3个字的名字</span><br><span class="line">select name from students where name like &quot;__&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询至少有2个字的名字</span><br><span class="line">select name from students where name like &quot;__%&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- rlike 正则</span><br><span class="line">-- 查询以 周开始的姓名</span><br><span class="line">select name from students where name rlike &quot;^周.*&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询以 周开始、伦结尾的姓名</span><br><span class="line">select name from students where name rlike &quot;^周.*伦$&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 范围查询</span><br><span class="line">-- in (1, 3, 8)表示在一个非连续的范围内</span><br><span class="line">-- 查询 年龄为18、34的姓名</span><br><span class="line">select name,age from students where age=18 or age=34;</span><br><span class="line">select name,age from students where age=18 or age=34 or age=12;</span><br><span class="line">select name,age from students where age in (12, 18, 34);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- not in 不非连续的范围之内</span><br><span class="line">-- 年龄不是 18、34岁之间的信息</span><br><span class="line">select name,age from students where age not in (12, 18, 34);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- between ... and ...表示在一个连续的范围内</span><br><span class="line">-- 查询 年龄在18到34之间的的信息</span><br><span class="line">select name, age from students where age between 18 and 34;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- not between ... and ...表示不在一个连续的范围内</span><br><span class="line">-- 查询 年龄不在在18到34之间的的信息</span><br><span class="line">select * from students where age not between 18 and 34;</span><br><span class="line">select * from students where not age between 18 and 34;</span><br><span class="line">-- 失败的select * from students where age not (between 18 and 34);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 空判断</span><br><span class="line">-- 判空is null</span><br><span class="line">-- 查询身高为空的信息</span><br><span class="line">select * from students where height is null;</span><br><span class="line">select * from students where height is NULL;</span><br><span class="line">select * from students where height is Null;</span><br><span class="line"></span><br><span class="line">-- 判非空is not null</span><br><span class="line">select * from students where height is not null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 排序</span><br><span class="line">-- order by 字段</span><br><span class="line">-- asc从小到大排列，即升序</span><br><span class="line">-- desc从大到小排序，即降序</span><br><span class="line"></span><br><span class="line">-- 查询年龄在18到34岁之间的男性，按照年龄从小到到排序</span><br><span class="line">select * from students where (age between 18 and 34) and gender=1;</span><br><span class="line">select * from students where (age between 18 and 34) and gender=1 order by age;</span><br><span class="line">select * from students where (age between 18 and 34) and gender=1 order by age asc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询年龄在18到34岁之间的女性，身高从高到矮排序</span><br><span class="line">select * from students where (age between 18 and 34) and gender=2 order by height desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- order by 多个字段</span><br><span class="line">-- 查询年龄在18到34岁之间的女性，身高从高到矮排序, 如果身高相同的情况下按照年龄从小到大排序</span><br><span class="line">select * from students where (age between 18 and 34) and gender=2 order by height desc,id desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询年龄在18到34岁之间的女性，身高从高到矮排序, 如果身高相同的情况下按照年龄从小到大排序,</span><br><span class="line">-- 如果年龄也相同那么按照id从大到小排序</span><br><span class="line">select * from students where (age between 18 and 34) and gender=2 order by height desc,age asc,id desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 按照年龄从小到大、身高从高到矮的排序</span><br><span class="line">select * from students order by age asc, height desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 聚合函数</span><br><span class="line">-- 总数</span><br><span class="line">-- count</span><br><span class="line">-- 查询男性有多少人，女性有多少人</span><br><span class="line">select * from students where gender=1;</span><br><span class="line">select count(*) from students where gender=1;</span><br><span class="line">select count(*) as 男性人数 from students where gender=1;</span><br><span class="line">select count(*) as 女性人数 from students where gender=2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 最大值</span><br><span class="line">-- max</span><br><span class="line">-- 查询最大的年龄</span><br><span class="line">select age from students;</span><br><span class="line">select max(age) from students;</span><br><span class="line"></span><br><span class="line">-- 查询女性的最高 身高</span><br><span class="line">select max(height) from students where gender=2;</span><br><span class="line"></span><br><span class="line">-- 最小值</span><br><span class="line">-- min</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 求和</span><br><span class="line">-- sum</span><br><span class="line">-- 计算所有人的年龄总和</span><br><span class="line">select sum(age) from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 平均值</span><br><span class="line">-- avg</span><br><span class="line">-- 计算平均年龄</span><br><span class="line">select avg(age) from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 计算平均年龄 sum(age)/count(*)</span><br><span class="line">select sum(age)/count(*) from students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 四舍五入 round(123.23 , 1) 保留1位小数</span><br><span class="line">-- 计算所有人的平均年龄，保留2位小数</span><br><span class="line">select round(sum(age)/count(*), 2) from students;</span><br><span class="line">select round(sum(age)/count(*), 3) from students;</span><br><span class="line"></span><br><span class="line">-- 计算男性的平均身高 保留2位小数</span><br><span class="line">select round(avg(height), 2) from students where gender=1;</span><br><span class="line">-- select name, round(avg(height), 2) from students where gender=1;</span><br><span class="line"></span><br><span class="line">-- 分组</span><br><span class="line"></span><br><span class="line">-- group by</span><br><span class="line">-- 按照性别分组,查询所有的性别</span><br><span class="line">select name from students group by gender;</span><br><span class="line">select * from students group by gender;</span><br><span class="line">select gender from students group by gender;</span><br><span class="line">-- 失败select * from students group by gender;</span><br><span class="line"></span><br><span class="line">-- 计算每种性别中的人数</span><br><span class="line">select gender,count(*) from students group by gender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 计算男性的人数</span><br><span class="line">select gender,count(*) from students where gender=1 group by gender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- group_concat(...)</span><br><span class="line">-- 查询同种性别中的姓名</span><br><span class="line"> select gender,group_concat(name) from students where gender=1 group by gender;</span><br><span class="line"> select gender,group_concat(name, age, id) from students where gender=1 group by gender;</span><br><span class="line"> select gender,group_concat(name, &quot;_&quot;, age, &quot; &quot;, id) from students where gender=1 group by gender;</span><br><span class="line"></span><br><span class="line">-- having</span><br><span class="line">-- 查询平均年龄超过30岁的性别，以及姓名 having avg(age) &gt; 30</span><br><span class="line">select gender, group_concat(name),avg(age) from students group by gender having avg(age)&gt;30;</span><br><span class="line"></span><br><span class="line">-- 查询每种性别中的人数多于2个的信息</span><br><span class="line">select gender, group_concat(name) from students group by gender having count(*)&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 分页</span><br><span class="line">-- limit start, count</span><br><span class="line"></span><br><span class="line">-- 限制查询出来的数据个数</span><br><span class="line">select * from students where gender=1 limit 2;</span><br><span class="line"></span><br><span class="line">-- 查询前5个数据</span><br><span class="line">select * from students limit 0, 5;</span><br><span class="line"></span><br><span class="line">-- 查询id6-10（包含）的书序</span><br><span class="line">select * from students limit 5, 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 每页显示2个，第1个页面</span><br><span class="line">select * from students limit 0,2;</span><br><span class="line"></span><br><span class="line">-- 每页显示2个，第2个页面</span><br><span class="line">select * from students limit 2,2;</span><br><span class="line"></span><br><span class="line">-- 每页显示2个，第3个页面</span><br><span class="line">select * from students limit 4,2;</span><br><span class="line"></span><br><span class="line">-- 每页显示2个，第4个页面</span><br><span class="line">select * from students limit 6,2; -- -----&gt; limit (第N页-1)*每个的个数, 每页的个数;</span><br><span class="line"></span><br><span class="line">-- 每页显示2个，显示第6页的信息, 按照年龄从小到大排序</span><br><span class="line">-- 失败select * from students limit 2*(6-1),2;</span><br><span class="line">-- 失败select * from students limit 10,2 order by age asc;</span><br><span class="line">select * from students order by age asc limit 10,2;</span><br><span class="line"></span><br><span class="line">select * from students where gender=2 order by height desc limit 0,2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 连接查询</span><br><span class="line">-- inner join ... on</span><br><span class="line"></span><br><span class="line">-- select ... from 表A inner join 表B;</span><br><span class="line">select * from students inner join classes;</span><br><span class="line"></span><br><span class="line">-- 查询 有能够对应班级的学生以及班级信息</span><br><span class="line">select * from students inner join classes on students.cls_id=classes.id;</span><br><span class="line"></span><br><span class="line">-- 按照要求显示姓名、班级</span><br><span class="line">select students.*, classes.name from students inner join classes on students.cls_id=classes.id;</span><br><span class="line">select students.name, classes.name from students inner join classes on students.cls_id=classes.id;</span><br><span class="line"></span><br><span class="line">-- 给数据表起名字</span><br><span class="line">select s.name, c.name from students as s inner join classes as c on s.cls_id=c.id;</span><br><span class="line"></span><br><span class="line">-- 查询 有能够对应班级的学生以及班级信息，显示学生的所有信息，只显示班级名称</span><br><span class="line">select s.*, c.name from students as s inner join classes as c on s.cls_id=c.id;</span><br><span class="line"></span><br><span class="line">-- 在以上的查询中，将班级姓名显示在第1列</span><br><span class="line">select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id;</span><br><span class="line"></span><br><span class="line">-- 查询 有能够对应班级的学生以及班级信息, 按照班级进行排序</span><br><span class="line">-- select c.xxx s.xxx from student as s inner join clssses as c on .... order by ....;</span><br><span class="line">select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by c.name;</span><br><span class="line"></span><br><span class="line">-- 当时同一个班级的时候，按照学生的id进行从小到大排序</span><br><span class="line">select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by c.name,s.id;</span><br><span class="line"></span><br><span class="line">-- left join</span><br><span class="line">-- 查询每位学生对应的班级信息</span><br><span class="line">select * from students as s left join classes as c on s.cls_id=c.id;</span><br><span class="line"></span><br><span class="line">-- 查询没有对应班级信息的学生</span><br><span class="line">-- select ... from xxx as s left join xxx as c on..... where .....</span><br><span class="line">-- select ... from xxx as s left join xxx as c on..... having .....</span><br><span class="line">select * from students as s left join classes as c on s.cls_id=c.id having c.id is null;</span><br><span class="line">select * from students as s left join classes as c on s.cls_id=c.id where c.id is null;</span><br><span class="line"></span><br><span class="line">-- right join   on</span><br><span class="line">-- 将数据表名字互换位置，用left join完成</span><br><span class="line"></span><br><span class="line">-- 自关联</span><br><span class="line">-- 省级联动 url:http://demo.lanrenzhijia.com/2014/city0605/</span><br><span class="line"></span><br><span class="line">-- 查询所有省份</span><br><span class="line">select * from areas where pid is null;</span><br><span class="line"></span><br><span class="line">-- 查询出山东省有哪些市</span><br><span class="line">select * from areas as province inner join areas as city on city.pid=province.aid having province.atitle=&quot;山东省&quot;;</span><br><span class="line">select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle=&quot;山东省&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询出青岛市有哪些县城</span><br><span class="line">select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle=&quot;青岛市&quot;;</span><br><span class="line">select * from areas where pid=(select aid from areas where atitle=&quot;青岛市&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 子查询</span><br><span class="line">-- 标量子查询</span><br><span class="line">-- 查询出高于平均身高的信息</span><br><span class="line"></span><br><span class="line">-- 查询最高的男生信息</span><br><span class="line">select * from students where height = 188;</span><br><span class="line">select * from students where height = (select max(height) from students);</span><br><span class="line"></span><br><span class="line">-- 列级子查询</span><br><span class="line">-- 查询学生的班级号能够对应的学生信息</span><br><span class="line">-- select * from students where cls_id in (select id from classes);</span><br></pre></td></tr></table></figure><h2 id="Python-中操作-MySQL-步骤"><a href="#Python-中操作-MySQL-步骤" class="headerlink" title="Python 中操作 MySQL 步骤"></a>Python 中操作 MySQL 步骤</h2><p><img src="https://s2.ax1x.com/2019/11/09/MmcqDe.jpg" alt="MmcqDe.jpg"></p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><ul><li>在py文件中引入pymysql模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h2 id="Connection-对象"><a href="#Connection-对象" class="headerlink" title="Connection 对象"></a>Connection 对象</h2><ul><li>用于建立与数据库的连接</li><li>创建对象：调用connect()方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn=connect(参数列表)</span><br></pre></td></tr></table></figure><ul><li>参数host：连接的mysql主机，如果本机是’localhost’</li><li>参数port：连接的mysql主机的端口，默认是3306</li><li>参数database：数据库的名称</li><li>参数user：连接的用户名</li><li>参数password：连接的密码</li><li>参数charset：通信采用的编码方式，推荐使用utf8</li></ul><h4 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h4><ul><li>close()关闭连接</li><li>commit()提交</li><li>cursor()返回Cursor对象，用于执行sql语句并获得结果</li></ul><h2 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h2><ul><li>用于执行sql语句，使用频度最高的语句为select、insert、update、delete</li><li>获取Cursor对象：调用Connection对象的cursor()方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs1=conn.cursor()</span><br></pre></td></tr></table></figure><h4 id="对象的方法-1"><a href="#对象的方法-1" class="headerlink" title="对象的方法"></a>对象的方法</h4><ul><li>close()关闭</li><li>execute(operation [, parameters ])执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句</li><li>fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</li><li>fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回</li></ul><h4 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h4><ul><li>rowcount只读属性，表示最近一次execute()执行后受影响的行数</li><li>connection获得当前连接对象</li></ul><h1 id="MySQL常用操作"><a href="#MySQL常用操作" class="headerlink" title="MySQL常用操作"></a>MySQL常用操作</h1><p>注意：MySQL中每个命令后都要以英文分号；结尾。<br>1、显示数据库<br>mysql&gt; show databases;<br>MySql刚安装完有两个数据库：mysql和test。mysql库非常重要，它里面有MySQL的系统信息，我们改密码和新增用户，实际上就是用这个库中的相关表进行操作。</p><p>2、显示数据库中的表<br>mysql&gt; use mysql; （打开库，对每个库进行操作就要打开此库）<br>Database changed<br>mysql&gt; show tables;</p><p>3、显示数据表的结构：<br>describe 表名;</p><p>4、显示表中的记录：<br>select * from 表名;<br>例如：显示mysql库中user表中的纪录。所有能对MySQL用户操作的用户都在此表中。<br>select * from user;</p><p>5、建库：<br>create database 库名;<br>例如：创建一个名字位aaa的库<br>mysql&gt; create database aaa;</p><p>6、建表：<br>use 库名；<br>create table 表名 (字段设定列表)；<br>例如：在刚创建的aaa库中建立表person,表中有id(序号，自动增长)，xm（姓名）,xb（性别）,csny（出身年月）四个字段<br>use aaa;<br>mysql&gt; create table person (id int(3) auto_increment not null primary key, xm varchar(10),xb varchar(2),csny date);<br>可以用describe命令察看刚建立的表结构。<br>mysql&gt; describe person;<br><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/describe-person.png" alt="describe-person"></p><p>7、增加记录<br>例如：增加几条相关纪录。<br>mysql&gt;insert into person values(null,’张三’,’男’,’1997-01-02′);<br>mysql&gt;insert into person values(null,’李四’,’女’,’1996-12-02′);<br>注意，字段的值（’张三’,’男’,’1997-01-02’）是使用两个英文的单撇号包围起来，后面也是如此。<br>因为在创建表时设置了id自增，因此无需插入id字段，用null代替即可。<br>可用select命令来验证结果。<br>mysql&gt; select * from person;<br><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/select-from-person.png" alt="select-from-person"></p><p>8、修改纪录<br>例如：将张三的出生年月改为1971-01-10<br>mysql&gt; update person set csny=’1971-01-10′ where xm=’张三’;</p><p>9、删除纪录<br>例如：删除张三的纪录。<br>mysql&gt; delete from person where xm=’张三’;</p><p>10、删库和删表<br>drop database 库名;<br>drop table 表名；</p><p>11、查看mysql版本<br>在mysql5.0中命令如下：<br>show variables like ‘version’;<br>或者：select version();</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法python版</title>
      <link href="/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python/"/>
      <url>/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 基础概念</strong></p><p> <strong>split()</strong> 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</p><p>split() 方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(str=<span class="string">""</span>, num=string.count(str))</span><br></pre></td></tr></table></figure><p>链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。</p><p>作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。</p><p>初学链表，一般从单向链表开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---&gt;<span class="literal">NULL</span></span><br><span class="line">head</span><br></pre></td></tr></table></figure><p>这是一个空链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ----&gt;[p1]----&gt;[p2]...----&gt;[pn]----&gt;[<span class="literal">NULL</span>]</span><br><span class="line">head   p1-&gt;next  p2-&gt;next   pn-&gt;next</span><br></pre></td></tr></table></figure><p>有n个节点的链表。</p><p>创建链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkList;</span><br></pre></td></tr></table></figure><p>一般创建链表我们都用typedef  struct，因为这样定义结构体变量时，我们就可以直接可以用LinkList  *a;定义结构体类型变量了。</p><p>初始化一个链表，n为链表节点个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList *<span class="title">creat</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">LinkList *head, *node, *end;<span class="comment">//定义头节点，普通节点，尾部节点；</span></span><br><span class="line">head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));<span class="comment">//分配地址</span></span><br><span class="line">end = head;         <span class="comment">//若是空链表则头尾节点一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList)); <span class="comment">//动态内存申请，将结构指针变成结构体变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node-&gt;score);</span><br><span class="line">end-&gt;next = node;</span><br><span class="line">end = node;</span><br><span class="line">&#125;</span><br><span class="line">end-&gt;next = <span class="literal">NULL</span>;<span class="comment">//结束创建</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改链表节点值</p><p>修改链表节点值很简单。下面是一个传入链表和要修改的节点，来修改值的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LinkList *<span class="built_in">list</span>,<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n为第n个节点</span></span><br><span class="line">LinkList *t = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"输入要修改的值"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"节点不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除链表节点</p><p>删除链表的元素也就是把前节点的指针域越过要删除的节点指向下下个节点。即：p-&gt;next = q-&gt;next;然后放出q节点的空间，即free(q);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">LinkList *t = <span class="built_in">list</span>, *in;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in = t;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in-&gt;next = t-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"节点不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入链表节点</p><p>我们可以看出来，插入节点就是用插入前节点的指针域链接上插入节点的数据域，再把插入节点的指针域链接上插入后节点的数据域。根据图，插入节点也就是：e-&gt;next = head-&gt;next;  head-&gt;next = e;</p><p>增加链表节点用到了两个结构体指针和一个int数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">LinkList *t = <span class="built_in">list</span>, *in;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"输入要插入的值"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in-&gt;score);</span><br><span class="line">in-&gt;next = t-&gt;next;<span class="comment">//填充in节点的指针域，也就是说把in的指针域指向t的下一个节点</span></span><br><span class="line">t-&gt;next = in;<span class="comment">//填充t节点的指针域，把t的指针域重新指向in</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"节点不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出链表</p><p>输出链表很简单，边遍历边输出就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">h = h-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, h-&gt;score);</span><br></pre></td></tr></table></figure><p><strong>python 初始化链表/列表输入</strong></p><p>1.只有一个整数：a = int(input)</p><p>2.一行多个整数并用空格分开：a,b = map(int,input().split())</p><p>3.数据较多时可用 列表存储：num = list(map(int,input().split()))</p><p>4.关于初始化链表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">num = list(map(int,input().split(<span class="string">','</span>)))  <span class="comment">#假设输入的每个元素按逗号隔开</span></span><br><span class="line">node = Node(<span class="number">-1</span>)</span><br><span class="line">tep = node</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">    tep.next = Node(i)</span><br><span class="line">    tep = tep.next</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>栈的存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成。LIFO</p><p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成 </p><p><strong>队列</strong></p><p>队列：具有一定操作约束的线性表，一端插入，另一端删除.FIFO</p><p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。 </p><p><strong>树</strong></p><p>儿子-兄弟表示法 旋转45后又叫二叉树</p><p><img src="https://s2.ax1x.com/2019/09/20/nv9Cbq.png" alt="nv9Cbq.png"></p><p>每个都是两个指针域</p><p>满二叉树：</p><p>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><p><a href="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/c2cec3fdfc0392457da6c1388a94a4c27d1e25f1.jpg" target="_blank" rel="noopener"><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=5337931f3b7adab43d851345bbe49f24/c2cec3fdfc0392457da6c1388a94a4c27d1e25f1.jpg" alt="img"></a></p><p>节点：</p><p>就是一个图中的0、1、2~~14，这些就叫节点。</p><p>叶子节点：</p><p>就是没有子节点的节点，比如图中的7、8、9~~14这些，0、1、2、3这些就不是叶子节点。</p><p><strong>拓展：二叉树相关术语</strong></p><p>树的结点（node）：包含一个数据元素及若干指向子树的分支；</p><p>孩子结点（child node）：结点的子树的根称为该结点的孩子；</p><p>双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；</p><p>兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；</p><p>祖先结点: 从根到该结点的所经分支上的所有结点子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙</p><p>结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；</p><p>树的深度：树中最大的结点层</p><p>结点的度：结点子树的个数</p><p>树的度： 树中最大的结点度。</p><p>叶子结点：也叫终端结点，是度为 0 的结点；</p><p>分枝结点：度不为0的结点；</p><p>有序树：子树有序的树，如：家族树；</p><p>无序树：不考虑子树的顺序；</p><p><img src="https://s2.ax1x.com/2019/09/20/nvJYAx.png" alt="nvJYAx.png"></p><p><img src="https://s2.ax1x.com/2019/09/21/nxElrD.png" alt="nxElrD.png"></p><p><img src="https://s2.ax1x.com/2019/09/21/nzCFm9.png" alt="nzCFm9.png"></p><p>注意在POP后T为栈顶值。</p><p><strong>二叉搜索树（BST， Binary Search Tree）</strong>，也称二叉排序树或二叉查找树 </p><p>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p><ol><li>非空左子树的所有键值小于其根结点的键值。</li><li>非空右子树的所有键值大于其根结点的键值。</li><li>左、右子树都是二叉搜索树。 </li></ol><p><strong>平衡二叉树</strong> </p><p>平均查找长度ASL</p><p>“平衡因子（ Balance Factor，简称BF） : BF(T) = hL-hR，其中hL和hR分别为T的左、右子树的高度。 </p><p>平衡二叉树（ Balanced Binary Tree）（ AVL树）空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T) |≤ 1 </p><p><img src="https://s2.ax1x.com/2019/09/23/uPXI5q.png" alt="uPXI5q.png"><br><img src="https://s2.ax1x.com/2019/09/23/uPX5an.png" alt="uPX5an.png"></p><p><img src="https://s2.ax1x.com/2019/09/23/uPX7GV.png" alt="uPX7GV.png"></p><p><img src="https://s2.ax1x.com/2019/09/23/uPjgF1.png" alt="uPjgF1.png"></p><hr><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>​      个人以为，BFS就像是再画一个半径为R++的圆，每画一次，这个圆就一点点的扩大，这样的好处在于他能够巨细无遗地扫描到你想要的元素；DFS就像是我们在画阴影的时候的方法，先沿对角线画一条斜线，然后在他的左边或者右边不断地画斜线填充，直到斜线接触到你想要的点；。</p><p>​      综上而言，在空间效率问题上，小范围而言BFS由于是采用队列的方式二优于DFS的递归方式，但是如果数据量扩大，这个真的不好说，这其中应该会有一个临界值，让两者的效率逆转。</p><p>​     而在时间效率上的话，一定程度上DFS的时间效率优于BFS。个人认为，BFS的主要作用在于扫描与找方向，DFS的作用主要在于在找到方向之后的建立最短 路径。 </p><p><strong>1.dfs(深度优先搜索)是两个搜索中先理解并使用的，其实就是暴力把所有的路径都搜索出来，它运用了回溯，保存这次的位置，深入搜索，都搜索完了便回溯回来，搜下一个位置，直到把所有最深位置都搜一遍，要注意的一点是，搜索的时候有记录走过的位置，标记完后可能要改回来；</strong></p><p>回溯法是一种搜索法，按条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法；</p><p><a href="https://imgchr.com/i/u59ym6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/09/u59ym6.png" alt="u59ym6.png"></a></p><p>例如这张图，从1开始到2，之后到5，5不能再走了，退回2，到6，退回2退回1，到3，一直进行；</p><p><strong>理解这种方法比较简单，难的是要怎么用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=deep/n,y=deep%n;</span><br><span class="line">    <span class="keyword">if</span>(符合某种要求||已经不能在搜了)</span><br><span class="line">    &#123;</span><br><span class="line">        做一些操作；</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(符合某种条件且有地方可以继续搜索的)<span class="comment">//这里可能会有多种条件，可能要循环什么的</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[x][y]=<span class="string">'x'</span>;<span class="comment">//可能要改变条件，这个是瞎写的</span></span><br><span class="line">            dfs(deep+<span class="number">1</span>,sum+<span class="number">1</span>);<span class="comment">//搜索下一层</span></span><br><span class="line">        a[x][y]=<span class="string">'.'</span>;<span class="comment">//可能要改回条件，有些可能不用改比如搜地图上有多少块连续的东西</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.bfs(宽度/广度优先搜索)，这个一直理解了思想，不会用，后面才会的，思想，从某点开始，走四面可以走的路，然后在从这些路，在找可以走的路，直到最先找到符合条件的，这个运用需要用到队列(queue)，需要稍微掌握这个才能用bfs</strong>.</p><p>还是这张图，从1开始搜，有2，3，4几个点，存起来，从2开始有5，6，存起来，搜3，有7，8，存起来，搜4，没有了；现在开始搜刚刚存的点，从5开始，没有，然后搜6.。。一直进行，直到找到；</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法题目python版</title>
      <link href="/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python-%E9%A2%98%E7%9B%AE/"/>
      <url>/2019/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python-%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="两个数的和"><a href="#两个数的和" class="headerlink" title="两个数的和"></a>两个数的和</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dist=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i]) <span class="keyword">not</span> <span class="keyword">in</span> dist:  <span class="comment">#对健判断</span></span><br><span class="line">                dist[nums[i]] = i  <span class="comment"># num[i]是键  i是值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [dist[target - nums[i]],i]  <span class="comment">#返回的是键的=值</span></span><br></pre></td></tr></table></figure><p>总结：Python 字典 <strong>in</strong> 操作符用于判断<strong>键</strong>是否存在于字典中</p><p><strong>1. 最大子列和问题</strong></p><p>给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }，“连续子列”被定义为{ <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性；</li><li>数据2：102个随机整数；</li><li>数据3：103个随机整数；</li><li>数据4：104个随机整数；</li><li>数据5：105个随机整数；</li></ul><p>输入格式:</p><p>输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p><p>输出格式:</p><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><p>程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num = int(input(<span class="string">'请给出正整数K'</span>))</span><br><span class="line"></span><br><span class="line">N = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input(<span class="string">'请给出K个数'</span>).split()]</span><br><span class="line">print(N)</span><br><span class="line">ThisSum = MaxSum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">    ThisSum += N[i]</span><br><span class="line">    <span class="keyword">if</span> ThisSum &gt; MaxSum:</span><br><span class="line">        MaxSum = ThisSum</span><br><span class="line">    <span class="keyword">elif</span>(ThisSum &lt; <span class="number">0</span>):</span><br><span class="line">        ThisSum = <span class="number">0</span></span><br><span class="line">print(MaxSum)</span><br></pre></td></tr></table></figure><p><strong>2.两个有序链表序列的合并</strong></p><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p><p>输入格式:</p><p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:</p><p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNewChart</span><span class="params">(self, list)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> list:</span><br><span class="line">            node = ListNode(list.pop(<span class="number">0</span>))  <span class="comment"># pop(0)是移除你的words中的第一个元素，并返回</span></span><br><span class="line">            <span class="comment"># 被移除的元素的值，也就是说返回的是你words中的第一个元素。</span></span><br><span class="line">            node.next = self.getNewChart(list)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">    list2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">    testList1 = Solution().getNewChart(list1)</span><br><span class="line">    testList2 = Solution().getNewChart(list2)</span><br><span class="line">    final = Solution().Merge(testList1, testList2)</span><br><span class="line">    <span class="keyword">while</span> final:</span><br><span class="line">        print(final.val, end=<span class="string">" "</span>)</span><br><span class="line">        final = final.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/2019/09/05/matplotlib/"/>
      <url>/2019/09/05/matplotlib/</url>
      
        <content type="html"><![CDATA[<p><strong>GUI编程–matplotlib绘图</strong></p><hr><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p><strong>array</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">t1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 存放数组</span></span><br><span class="line"></span><br><span class="line">t2 = np.array(range(<span class="number">1</span>,<span class="number">4</span>),dtype = float) <span class="comment"># 指定数组类型</span></span><br><span class="line"></span><br><span class="line">t6 = t5.astype(<span class="string">'int8'</span>) <span class="comment"># 调整数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#random.random() 取小数</span></span><br><span class="line">np.round(t7,<span class="number">2</span>) <span class="comment"># 取t7里小数的前两位</span></span><br><span class="line"></span><br><span class="line">t1.shape <span class="comment"># 返回一个元祖 返回元祖的含义注意！ 第一个是0轴，第二个是1轴...</span></span><br><span class="line"></span><br><span class="line">t1.reshape((<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 转入一个元祖  把1*12 变成3*4</span></span><br><span class="line"></span><br><span class="line">t5.flatte() <span class="comment"># 把数据转换成一维的</span></span><br></pre></td></tr></table></figure><p><strong>轴</strong></p><p>二维数组里 axis=0 代表行  1代表列</p><p><img src="https://s2.ax1x.com/2019/09/06/nMFMyd.png" alt="nMFMyd.png"></p><p><strong>numpy读取数据(.csv)</strong></p><p><code>np.loadtxt(fram.dtype = np.float,delimiter = None, skipprows = 0, usecoles = None, unpack=False)</code></p><p>fram 文件、字符或者生成器，可以是.gz  (文件名)</p><p>delimiter 分隔字符串，默认空格，可改成，</p><p>skiprows 跳过前x行，一般跳过第一行表头</p><p>usecols 读取指定的列，索引，元祖类型</p><p>unpack 如True读入属性分别写入不同数组变量，False 只写入一个数组变量，默认False。(类似于把矩阵旋转了)</p><p><code>t1.transpose()数组转置</code></p><p><code>或者t1.T</code></p><p><strong>索引  切片</strong></p><p><code>t2[2]</code>取第二行  ,  取多行<code>t2[2,6,9]</code></p><p>取行<code>t2[1,:]</code>  取列<code>t2[:,[0,2,7]]</code></p><p><strong>numpy中数值修改</strong></p><p><code>t2[t2&lt;10] = 3</code></p><p><code>np.where(t&lt;10,0,10)</code> 小于10是0，大于10是10</p><p><code>t.clip(10,18)</code>  小于10 是10 大于18是18</p><p><strong>数组的拼接</strong></p><p><code>np.vstack((t1,t2))</code> 竖直拼接</p><p><code>np.hstack((t1,t2))</code> 水平拼接</p><p>行列交换<code>t[[1,2],:] = t[[2,1],:]</code></p><p>构造全为0的数组 <code>np.zero((us_data.shape[0],1))</code></p><p>构造全为1的数组 <code>np.ones((us_data.shape[0],1))</code></p><p>获取最大值最小值的位置<code>np.argmax(t,axis=0)</code> /<code>np.argmin(t,axis=1)</code></p><p>创建一个对角线为1的正方形数组(方阵)：<code>np.eye(3)</code></p><p>numpy的注意点copy和view</p><ol><li><p>a=b 完全不复制，a和b相互影响</p></li><li><p>a = b[:],视图的操作，一种切片，会创建新的对象a，但是a的数据完全由b保管，他们两个的数据变化是一致的，</p></li><li><p>a = b.copy(),复制，a和b互不影响</p></li></ol><p><strong>常用的统计函数</strong></p><p>求和：t.sum(axis=None)  指定一个轴</p><p>均值：t.mean(a,axis=None)  受离群点的影响较大</p><p>中值：np.median(t,axis=None) </p><p>最大值：t.max(axis=None) </p><p>最小值：t.min(axis=None)</p><p>极值：np.ptp(t,axis=None) 即最大值和最小值只差</p><p>标准差：t.std(axis=None) </p><h3 id="FuncAnimation动态绘图"><a href="#FuncAnimation动态绘图" class="headerlink" title="FuncAnimation动态绘图"></a>FuncAnimation动态绘图</h3><p>1、函数FuncAnimation(fig,func,frames,init_func,interval,blit)是绘制动图的主要函数，其参数如下：</p><p>　　a.<code>fig</code> 绘制动图的画布名称</p><p>　　b.func自定义动画函数，即下边程序定义的函数<code>update</code></p><p>　　c.frames动画长度，一次循环包含的帧数，在函数运行时，其值会传递给函数update(n)的形参“n”</p><p>　　d.init_func自定义开始帧，即传入刚定义的函数<code>init,初始化函数</code></p><p>　　e.interval更新频率，以ms计</p><p>　　f.blit选择更新所有点，还是仅更新产生变化的点。应选择<code>True</code>，但mac用户请选择<code>False</code>，否则无法显</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> FuncAnimation</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()   <span class="comment">#生成子图，相当于fig = plt.figure(),ax = fig.add_subplot(),其中ax的函数参数表示把当前画布进行分割，例：fig.add_subplot(2,2,2).表示将画布分割为两行两列　　　　　　　　　　　　　　　　#ax在第2个子图中绘制，其中行优先，</span></span><br><span class="line">xdata, ydata = [], []      <span class="comment">#初始化两个数组</span></span><br><span class="line">ln, = ax.plot([], [], <span class="string">'r-'</span>, animated=<span class="literal">False</span>)  <span class="comment">#第三个参数表示画曲线的颜色和线型，具体参见：https://blog.csdn.net/tengqingyong/article/details/78829596</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, <span class="number">2</span>*np.pi)  <span class="comment">#设置x轴的范围pi代表3.14...圆周率，</span></span><br><span class="line">    ax.set_ylim(<span class="number">-1</span>, <span class="number">1</span>)　　　　<span class="comment">#设置y轴的范围</span></span><br><span class="line">    <span class="keyword">return</span> ln,               <span class="comment">#返回曲线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(n)</span>:</span></span><br><span class="line">    xdata.append(n)         <span class="comment">#将每次传过来的n追加到xdata中</span></span><br><span class="line">    ydata.append(np.sin(n))</span><br><span class="line">    ln.set_data(xdata, ydata)    <span class="comment">#重新设置曲线的值</span></span><br><span class="line">    <span class="keyword">return</span> ln,</span><br><span class="line"></span><br><span class="line">ani = FuncAnimation(fig, update, frames=np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">10</span>),     <span class="comment">#这里的frames在调用update函数是会将frames作为实参传递给“n”</span></span><br><span class="line">                    init_func=init, blit=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> PS:一般来说一个动图有两类函数，一类是初始化函数，另一类是需要更新的函数！！</p><h3 id="Figure构造器参数说明"><a href="#Figure构造器参数说明" class="headerlink" title="Figure构造器参数说明"></a>Figure构造器参数说明</h3><blockquote><p>class matplotlib.figure.Figure(<br>    figsize=None,     #Figure的大小，单位是英寸<br>    dpi=None,     #分辨率（每英寸的点数）<br>    facecolor=None,     #修饰的颜色<br>    edgecolor=None,     #边界颜色<br>    linewidth=0.0,     #线条宽度<br>    frameon=None,     #布尔值，是否绘制框架（Frame）<br>    subplotpars=None,     #子图的参数<br>    tight_layout=None,     #取值布尔或者字典，缺省自动布局，False 使用 <strong>subplotpars</strong>参数，True就使用<strong>tight_layout</strong>，如果是字典，则包含如下字段：<strong>pad</strong>, <strong>w_pad</strong>, <strong>h_pad</strong>, 与 <strong>rect</strong><br>    constrained_layout=None)     #True就使用constrained_layout，会自动调整plot的位置。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> pyqt </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性负载-杨明</title>
      <link href="/2019/08/25/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E6%9D%A8%E6%98%8E/"/>
      <url>/2019/08/25/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E6%9D%A8%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="关于杨明老师柔性负载的文献综述"><a href="#关于杨明老师柔性负载的文献综述" class="headerlink" title="关于杨明老师柔性负载的文献综述"></a><center>关于杨明老师柔性负载的文献综述</center></h2><p align="right">制作人：颜世伟</p><p align="right">制作时间：2019.8</p>---<h3 id="一、机械谐振建模-1"><a href="#一、机械谐振建模-1" class="headerlink" title="一、机械谐振建模 [1]"></a>一、机械谐振建模 [1]</h3><img src="https://s2.ax1x.com/2019/08/26/mWqgs0.png" width="380" height="130" alt="图片名称" align="center"><p>电机和执行机构通过传动轴系联接，传动轴系具有一定的抗扭刚度 K 和阻尼系数 Cw。当传动轴系发生扭转形变时轴系将产生转矩 Tw，此转矩对于电机来说可看作是电机的负载转矩，而对于执行机构来说可看作是驱动转矩。伺服驱动器控制电机运行，为电机的转轴提供电磁转矩 Te。在电机端电磁转矩 Te和传动轴系转矩 Tw作用于转动惯量为 J1、阻尼系数为 C1的电机转轴。在执行机构端，执行机构具有大小为 J2的等效转动惯量以及阻尼系数 C2，传动轴系转矩 Tw与负载转矩Tl共同作用于执行机构最终决定了负载转速。</p><p>系统中的阻尼系数很小，可忽略阻尼系数从而对系统模型进行化简得到  传动装置的数学表达：</p><img src="https://s2.ax1x.com/2019/08/26/mWLTAS.png" width="380" height="450" alt="图片名称" align="center"><p>实际系统模型框图：</p><img src="https://s2.ax1x.com/2019/08/26/mWOK4e.png" width="400" height="150" alt="图片名称" align="center"><p> 根据系统的传递函数画处Bode图(A:  ω1/ ωref传递函数的幅频特性曲线. B：ω2/ ω1 .  C为A+B)</p><img src="https://s2.ax1x.com/2019/08/26/mWxlIf.png" width="380" height="250" alt="图片名称" align="center"><p>可以看出闭环系统中存在一个谐振点，系统对于此频率点的响应比较强烈，存在机械谐振。并且谐振频率受系统中的机械谐振频率和振幅主要受到负载转动惯量 J2和传动轴扭转弹性系数 K 两个参数影响.</p><hr><h3 id="二、双惯量弹性伺服系统外部机械参数辨识方法综述-5"><a href="#二、双惯量弹性伺服系统外部机械参数辨识方法综述-5" class="headerlink" title="二、双惯量弹性伺服系统外部机械参数辨识方法综述[5]"></a>二、双惯量弹性伺服系统外部机械参数辨识方法综述[5]</h3><p><img src="https://s2.ax1x.com/2019/08/29/mLfhPf.jpg" alt="mLfhPf.jpg"></p><hr><h3 id="三、谐振机理分析及谐振特征快速辨识-6"><a href="#三、谐振机理分析及谐振特征快速辨识-6" class="headerlink" title="三、谐振机理分析及谐振特征快速辨识[6]"></a>三、谐振机理分析及谐振特征快速辨识[6]</h3><p><strong>目的：</strong>通过辨识的谐振频率可以确定陷波滤波器参数</p><p><strong>主要思路：</strong>首先对比连续系统开、闭环幅频特性与固有谐振特征的定量关系，确定谐振模式; 进一步针对离散系统，分析控制器刚度对离散闭环系统谐振的影响，确定离散系统持续振荡状态下谐振频率即为 NTF (共轭极点为自然振动频率点)频率。</p><p><strong>谐振原理及模型</strong></p><p>电机转速与电机电磁转矩之间的传递函数：</p><img src="https://s2.ax1x.com/2019/09/22/u92PII.png" width="380" height="70" alt="图片名称" align="center"><p>从上式看出，机械谐振点在传递函数上引入了一对共轭的零极点，共轭零点为抗谐振频率点 AＲF( anti-resonance frequency) ，共轭极点为自然振动频率点 NTF( natural torsional frequency)。</p><p><strong>系统的谐振特征</strong></p><blockquote><p> 1.开环系统的谐振(速度开环，电流闭环)</p><p>计算得系统的阶跃响应为 斜坡输出的基础上叠加 NTF 频率的振荡，振荡幅值与NTF 频率成反比。而且振荡频率值与负载转矩无关，所以在分析谐振频率时可以不考虑负载转矩对系统的影响。证明在速度开环情况下，系统会以NTF 谐振频率振荡。</p><img src="https://s2.ax1x.com/2019/10/13/uv5Yl9.png" width="380" height="170" alt="图片名称" align="center"><p>2.闭环系统的振荡(电流环近似为1)</p><p>速度控制器的传递函数为下式</p><img src="https://s2.ax1x.com/2019/10/13/uvIvDI.png" width="380" height="55" alt="图片名称" align="center"><p>其特征方程可以化简为</p><img src="https://s2.ax1x.com/2019/10/13/uvowGD.png" width="380" height="70" alt="图片名称" align="center"><p>系统的闭环带宽主要受到min(w1,w2),且min(w1,w2)&lt;wARF(共轭零点的谐振频率)。</p><p>进一步画出弹性系统 wm/ Te、开环系统及闭环系统的幅频曲线如下：</p><p><img src="https://s2.ax1x.com/2019/10/13/uvTSy9.png" alt="uvTSy9.png"></p><p>通过弹性虚脱的幅频特性可以看出：在速度闭环系统中，由于受到闭环控制作用的影响，NTF 频率大于 0 dB 的增益会被明显抑制，所以此时的谐振主要是以接近 AＲF 频率的振荡频率 fe在振动，而且该频率振动也会逐渐地趋于稳定。</p><p>带有速度输出限幅的闭环系统响应如下</p><p><img src="https://s2.ax1x.com/2019/09/22/u9g7Z9.png" alt="u9g7Z9.png"></p><p>可以看出柔性负载引入对系统的最显著影响就是降低了系统的带宽，使得系统无法进一步提高性能。振荡频率明显分为两段: 当速度调节器饱和，系统处于速度控制开环阶段，此时电机和负载侧都以 NTF 频率振荡; 当电机速度达到给定速度，速度调节器退饱和，进入速度控制闭环阶段。在对于大惯量系统控制器刚度随之较大时，该阶段就能以AＲF 谐振频率衰减振荡，直至转速达到给定。</p></blockquote><p><strong>谐振特征辨识</strong></p><p>将信号(伪随机序列信号/Chirp信号)幅值变为一倍额定电流值输入作为 q 轴给定输入系统。</p><p>再通过计算每个频率处的给定信号与激励信号的幅值比和相位差就可以得到被测系统的幅频和相频特性。系统的幅频及相频特性可按下式计算。按上述方式就可以绘制出系统的频率特性 Bode 图。</p><img src="https://s2.ax1x.com/2019/10/13/uv7lu9.png" width="410" height="120" alt="图片名称" align="center"><p><strong>结论:</strong><br>1) 闭环系统的带宽受到弹性系统的限制，加大连续系统刚度只会使系统带宽及谐振频率趋近ARF谐振频率。所以在大惯量伺服系统中，由于控制器刚度较高，可以将谐振频率近似为 ARF频率。<br>2) 由于刚度的增加可能会使离散闭环系统的稳定裕度为负，进入发散状态。由于速度限幅的作用，使系统进入非线性振荡状态。此时振荡频率为NTF 频率叠加二分之一采样频率，经过采样滤波的实际系统体现的就为 NTF 谐振频率。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 杨明, 胡浩, 徐殿国. 永磁交流伺服系统机械谐振成因及其抑制[J]. 电机与控制学报, 2012, 16(1):79-84.</p><p>[2] 杨明, 郝亮, 徐殿国. 基于自适应陷波滤波器的在线机械谐振抑制[J]. 哈尔滨工业大学学报, 2014, 46(4):63-69.</p><p>[3] 王璨, 杨明, 徐殿国. 基于PI控制的双惯量弹性系统机械谐振的抑制[J]. 电气传动, 2015(1).</p><p>[4] 杨明, 王璨, 徐殿国. 基于轴矩限幅控制的机械谐振抑制技术[J]. 电机与控制学报, 2015, 19(4):58-64.</p><p>[5] 王璨, 杨明, 栾添瑞. 双惯量弹性伺服系统外部机械参数辨识综述[J]. 中国电机工程学报, 2016, 36(3):804-817.</p><p>[6] 杨明, 郝亮, 徐殿国. 双惯量弹性负载系统机械谐振机理分析及谐振特征快速辨识[J]. 电机与控制学报, 2016, 20(04):112-120.</p><p>[7] 郎志, 杨明, 徐殿国. 双惯量弹性系统负载扰动观测器设计研究[J]. 电工技术学报, 2016(S2):90-97.</p><p>[8] Beinke  S，Wertz  H，Schutte  F，et  al．Identification  of nonlinear two-mass systems for self-commissioning speed control  of  electrical  drives[C]//Proceedings  of  the  24th Annual  Conference  of  the  IEEE  Industrial  Electronics Society．Aachen：IEEE，1998：2251-2256．</p><p>[9] GuoY J，HuangL P，Muramatsu M．Research on inertia identification  and  auto-tuning  of  speed  controller  for  AC servo  system[C]//Proceedings  of  the  Power  Conversion Conference．Osaka：IEEE，2002：896-901</p><p>[10]  Östring  M ， Gunnarsson  S ， Norrlöf  M ． Closed-loop identification of an industrial robot containing flexibilities [J]．Control Engineering Practice，2003，11(3)：291-300</p><p>[11] Östring  M．Closed  loop  identification  of  the  physical parameters  of  an  industrial  robot[C]//Proceedings  of  the 32nd  International  Symposium  on  Robotics ． Seoul ，Korea，2000． </p><p>[12]Dhaouadi  R，KuboK．Transfer  function  and  parameters identification  of  a  motor  drive  system  using  adaptive filtering[C]//Proceedings  of  the  4th  International Workshop  on  Advanced  Motion  Control．Mie：IEEE，1996：588-593．</p><p>[13]  Eker I，Vural M．Experimental online identification of a three-mass  mechanical  system[C]//Proceedings  of  2003 IEEE  Conference  on  Control  Applications．Istanbul，Turkey：IEEE，2003：60-65． </p><p>[14] Landau I D，Karimi A．An extended output error recursive algorithm for identification in closed loop[C]//Proceedings of  the  35th  IEEE  Conference  on  Decision  and Control．Kobe：IEEE，1996：1405-1410． </p><p>[15] Eker I，Vural M．Experimental online identification of a three-mass  mechanical system[C]//Proceedings  of  2003 IEEE  Conference  on  Control  Applications．Istanbul，Turkey：IEEE，2003：60-65． </p><p>[16] Landau I D，Karimi A．An extended output error recursive algorithm for identification in closed loop[C]//Proceedings of  the  35th  IEEE  Conference  on  Decision  and Control．Kobe：IEEE，1996：1405-1410．</p><p>[17] Zoubek  H，Pacas  M．A  method  for  speed-sensorless identification of two-mass-systems[C]//Proceedings of the 2010  IEEE  Energy  Conversion  Congress  and Exposition．Atlanta，GA：IEEE，2010：4461-4468．</p><p>[18] YoshiokaY ， HanamotoT ． Estimation  of  a  multimass system  using  the  LWTLS  and  a  coefficient  diagram  for vibration-controller  design[J] ． IEEE  Transactions  on Industry Applications，2008，44(2)：566-574． </p><p>[19] Villwock S，Pacas M．Application of the Welch-method for  the  identification  of  two-and  three-mass-systems [J]．IEEE Transactions on Industrial Electronics，2008，55(1)：457-466． </p>]]></content>
      
      
      
        <tags>
            
            <tag> PMSM </tag>
            
            <tag> 柔性负载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyqt基础知识</title>
      <link href="/2019/08/24/pyqt5%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/08/24/pyqt5%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><strong>pqqt基础知识汇总</strong></p><h3 id="第一个窗口"><a href="#第一个窗口" class="headerlink" title="第一个窗口"></a>第一个窗口</h3><p>1、if __name__ == “__main__“: 是代表如果这个文件是主程序这运行下面的代码，如果是被别的程序文件调用的话，则运行下面的代码。</p><p>2、__init __ 方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的 初始化 。注意，这个名称的开始和结尾都是双下划线。</p><p>3、生成实例（对象）必须以类名()，别忘记了()</p><p>4、类中的函数（方法）必须有self，是代表属于这个实例（对象）本身持有的，而外部定义的函数则不需要。</p><p>5、QApplication相当于main函数，也就是整个程序（有很多文件）的主入口函数。</p><p>​    对于一个Gui程序必须至少有一个这样的一个实例来让程序运行。</p><p>6、最后一句是调用sys库的exit退出方法，退出条件（参数）是app.exec_()也就是整个窗口关闭。</p><h3 id="Qt-Designer"><a href="#Qt-Designer" class="headerlink" title="Qt Designer"></a>Qt Designer</h3><p>1、记得在Qt Designer中窗体的layout层次可以通过对象查看器来查看，layout的一些设置可以通过属性编辑器来修该。</p><p>2、通常我们使用栅格布局作为顶层布局，将控件放置好之后可以通过右键–布局–栅格布局，将布局充满整个窗体。</p><p>3、我们可以先放入控件，然后ctrl选中多个控件，然后点击工具栏上快速布局工具进行布局。</p><p> 4、在mianwindows中默认会有个centralwidget布局也是继承自QtWidgets.QWidget，表示窗口的中央部分。</p><h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p>信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。它为高层次的事件处理自动生成所需要的附加代码。在我们所熟知的很多 GUI 工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。<br><strong>所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。</strong>当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。<strong>一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。</strong><br>你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。</p><p>说实话对于像我这样的新手来说看着就蛋疼，想学会它没办法，我们还是简化一下概念吧：<br>所有QObject类都可以使用信号槽，换句话来说继承自pyqt中的类基本上都可以使用信号槽机制。当然非QObject也是可以通过其他一些办法来使用信号槽的。</p><p>仅仅有了信号和槽是不行的，我们还需要了解：<br>信号(Signal)、槽(slot)、连接(connect)、动作事件(action)、发射(emit)、发送者、接受者等等一些列的知识。</p><ol><li>在PyQt中接受者和发送者必须是个对象（实例）！</li><li>PyQt中的控件中提供了很多信号和槽方法，大家可以多多使用Qt Designer 设计参考！</li><li>槽其实就个函数（方法），Qt5中的槽函数不在限定必须是slot，可以是普通的函数、类的普通成员函数、lambda函数等。编译期间就会检查信号与槽是否存在！</li><li><strong>信号的connect连接最好放在__init__析构函数里面</strong>，这样只会声明一次连接，如果在类方法（函数中）使用的话，要记得disconnect，否则connect会连接多次，导致程序异常。</li><li><strong>信号槽函数不用加 ()</strong>，否则可能会导致连接异常。</li></ol><h4 id="PyQt信号和槽传递额外参数"><a href="#PyQt信号和槽传递额外参数" class="headerlink" title="PyQt信号和槽传递额外参数"></a>PyQt信号和槽传递额外参数</h4><p>使用Pyqt编程过程中，经常会遇到给槽函数传递额外参数的情况。但是信号-槽机制只是指定信号如何连接到槽，信号定义的参数被传递给槽，而额外的参数（用户定义）不能直接传递。</p><p>而传递额外参数又是很有用处。你可能使用一个槽处理多个组件的信号，有时要传递额外的信息。</p><p>一种方法是使用lambda表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></span><br><span class="line">        super(MyForm, self).__init__(parent)</span><br><span class="line">        button1 = QPushButton(<span class="string">'Button 1'</span>)</span><br><span class="line">        button2 = QPushButton(<span class="string">'Button 1'</span>)</span><br><span class="line">        button1.clicked.connect(<span class="keyword">lambda</span>: self.on_button(<span class="number">1</span>))</span><br><span class="line">        button2.clicked.connect(<span class="keyword">lambda</span>: self.on_button(<span class="number">2</span>))</span><br><span class="line"> </span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        layout.addWidget(button1)</span><br><span class="line">        layout.addWidget(button2)</span><br><span class="line"> </span><br><span class="line">        main_frame = QWidget()</span><br><span class="line">        main_frame.setLayout(layout)</span><br><span class="line"> </span><br><span class="line">        self.setCentralWidget(main_frame)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_button</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        print(<span class="string">'Button &#123;0&#125; clicked'</span>.format(n))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    form = MyForm()</span><br><span class="line">    form.show()</span><br><span class="line">    app.exec_()</span><br></pre></td></tr></table></figure><p>解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用）</p><p>第2个方法是使用functools里的partial函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button1.clicked.connect(partial(self.on_button, <span class="number">1</span>))button2.clicked.connect(partial(self.on_button, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>《Rapid GUI Program with Python and QT》 P143例子。</p><h3 id="自定义信号emit及传参"><a href="#自定义信号emit及传参" class="headerlink" title="自定义信号emit及传参"></a>自定义信号emit及传参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> f1 <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets,QtCore</span><br><span class="line"><span class="keyword">import</span> sys,time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span><span class="params">(QtWidgets.QMainWindow, Ui_MainWindow)</span>:</span> <span class="comment"># 继承QWidget和Ui_MainWindow</span></span><br><span class="line">    _signal = QtCore.pyqtSignal() <span class="comment"># 定义信号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyWindow, self).__init__()</span><br><span class="line">        self.setupUi(self)          <span class="comment">#加载窗体</span></span><br><span class="line"></span><br><span class="line">        self.pushButton.clicked.connect(self.prn)     <span class="comment"># 按钮1链接到prn槽函数</span></span><br><span class="line">        <span class="comment"># self.pushButton_2.clicked.connect(self.prn)</span></span><br><span class="line">        self._signal.connect(self.mysignalslot)       <span class="comment"># 将信号连接到mysignalslot</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'打印测试'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'延时1秒'</span>)</span><br><span class="line">        self._signal.emit()     <span class="comment">#发射信号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mysignalslot</span><span class="params">(self)</span>:</span>     <span class="comment"># 自定义槽函数</span></span><br><span class="line">        print(<span class="string">'我是slot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    mywindow = MyWindow()           <span class="comment"># 创建实例</span></span><br><span class="line">    mywindow.show()                 <span class="comment"># 使用QtWidgets的show()方法</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>main.py的程序如上所示。实现功能：</p><p><img src="https://s2.ax1x.com/2019/08/25/mcs0Hg.png" alt="mcs0Hg.png"></p><p>注意：当信号与槽函数的参数数量相同时，它们参数类型要完全一致。信号与槽不能有缺省参数。 </p><p>当信号的参数与槽函数的参数数量不同时，只能是信号的参数数量多于槽函数的参数数量，且前面相同数量的参数类型应一致，信号中多余的参数会被忽略。此外，在不进行参数传递时，信号槽绑定时也是要求信号的参数数量大于等于槽函数的参数数量。这种情况一般是一个带参数的信号去绑定一个无参数的槽函数。</p><p>当然可以出传递的参数类型有很多种：str、int、list、object、float、tuple、dict等等</p><p>单个文件打开 QFileDialog.getOpenFileName()<br>多个文件打开 QFileDialog.getOpenFileNames()</p><p>文件夹选取     QFileDialog.getExistingDirectory()</p><p>文件保存         QFileDialog.getSaveFileName()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QFileDialog</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span><span class="params">(QtWidgets.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyWindow,self).__init__()</span><br><span class="line">        self.myButton = QtWidgets.QPushButton(self)</span><br><span class="line">        self.myButton.setObjectName(<span class="string">"myButton"</span>)</span><br><span class="line">        self.myButton.setText(<span class="string">"Test"</span>)</span><br><span class="line">        self.myButton.clicked.connect(self.msg)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        directory1 = QFileDialog.getExistingDirectory(self,</span><br><span class="line">                                    <span class="string">"选取文件夹"</span>,</span><br><span class="line">                                    <span class="string">"C:/"</span>)                         <span class="comment">#起始路径</span></span><br><span class="line">        print(directory1)</span><br><span class="line"> </span><br><span class="line">        fileName1, filetype = QFileDialog.getOpenFileName(self,</span><br><span class="line">                                    <span class="string">"选取文件"</span>,</span><br><span class="line">                                    <span class="string">"C:/"</span>,</span><br><span class="line">                                    <span class="string">"All Files (*);;Text Files (*.txt)"</span>) <span class="comment">#设置文件扩展名过滤,注意用双分号间隔</span></span><br><span class="line">        print(fileName1,filetype)</span><br><span class="line"> </span><br><span class="line">        files, ok1 = QFileDialog.getOpenFileNames(self,</span><br><span class="line">                                    <span class="string">"多文件选择"</span>,</span><br><span class="line">                                    <span class="string">"C:/"</span>,</span><br><span class="line">                                    <span class="string">"All Files (*);;Text Files (*.txt)"</span>)</span><br><span class="line">        print(files,ok1)</span><br><span class="line"> </span><br><span class="line">        fileName2, ok2 = QFileDialog.getSaveFileName(self,</span><br><span class="line">                                    <span class="string">"文件保存"</span>,</span><br><span class="line">                                    <span class="string">"C:/"</span>,</span><br><span class="line">                                    <span class="string">"All Files (*);;Text Files (*.txt)"</span>)</span><br><span class="line">   print(fileName2,ok2)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:  </span><br><span class="line">    <span class="keyword">import</span> sys  </span><br><span class="line">  </span><br><span class="line">    app=QtWidgets.QApplication(sys.argv)  </span><br><span class="line">    myshow=MyWindow()</span><br><span class="line">    myshow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>第一个参数parent，用于指定父组件。注意，很多Qt组件的构造函数都会有这么一个parent参数，并提供一个默认值0,这里一般填 self父类；</p><p>第三个参数dir，是对话框显示时默认打开的目录，”.”代表程序运行目录,”/“代表当前盘符下根目录，注意，这里跟平台有关，例如windows可填”C:\“等，Linux下填写”/“根目录</p><p>第四个参数Filter，是对话框后缀名过滤器，有Image File(<em>.jpg *png)就让他只能显示后缀名是jpg或者是png的文件。Text Files(</em>.txt)代表后缀名为.txt的文件。All Files(<em>)则代表是各种类型的文件。如果需要使用多个过滤器，使用<code>&quot;;;&quot;</code>分割，比如`”JPEG Files(</em>.jpg);;PNG Files(*.png)”；`</p><h3 id="各种对话框"><a href="#各种对话框" class="headerlink" title="各种对话框"></a>各种对话框</h3><p>PyQt5提供了一系列标准的对话框，常见的有：消息对话框QMessageBox、颜色对话框QColorDialog、字体对话框QFontDialog、输入对话框QInputDialog以及文件对话框QFileDialog</p><h4 id="1-颜色对话框和字体对话框"><a href="#1-颜色对话框和字体对话框" class="headerlink" title="1. 颜色对话框和字体对话框"></a>1. 颜色对话框和字体对话框</h4><p>这两种对话框分别可以让用户进行颜色和字体选择。两者用法相似，所以就放在一起讲了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget, QTextEdit, QColorDialog, QFontDialog, QPushButton, \</span><br><span class="line">                            QHBoxLayout, QVBoxLayout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Demo, self).__init__()</span><br><span class="line">        self.text_edit = QTextEdit(self)                 <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">        self.color_btn = QPushButton(<span class="string">'Color'</span>, self)      <span class="comment"># 2</span></span><br><span class="line">        self.font_btn = QPushButton(<span class="string">'Font'</span>, self)</span><br><span class="line">        self.color_btn.clicked.connect(<span class="keyword">lambda</span>: self.open_dialog_func(self.color_btn))</span><br><span class="line">        self.font_btn.clicked.connect(<span class="keyword">lambda</span>: self.open_dialog_func(self.font_btn))</span><br><span class="line"></span><br><span class="line">        self.h_layout = QHBoxLayout()</span><br><span class="line">        self.h_layout.addWidget(self.color_btn)</span><br><span class="line">        self.h_layout.addWidget(self.font_btn)</span><br><span class="line">        self.v_layout = QVBoxLayout()</span><br><span class="line">        self.v_layout.addWidget(self.text_edit)</span><br><span class="line">        self.v_layout.addLayout(self.h_layout)</span><br><span class="line">        self.setLayout(self.v_layout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_dialog_func</span><span class="params">(self, btn)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> btn == self.color_btn:                        <span class="comment"># 3</span></span><br><span class="line">            color = QColorDialog.getColor()</span><br><span class="line">            <span class="keyword">if</span> color.isValid():</span><br><span class="line">                self.text_edit.setTextColor(color)</span><br><span class="line">        <span class="keyword">else</span>:                                            <span class="comment"># 4</span></span><br><span class="line">            font, ok = QFontDialog.getFont()</span><br><span class="line">            <span class="keyword">if</span> ok:</span><br><span class="line">                self.text_edit.setFont(font)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    demo = Demo()</span><br><span class="line">    demo.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><ol><li><p>QTextEdit控件用于显示文本颜色和字体变化；</p></li><li><p>实例化两个按钮分别用于打开颜色对话框和字体对话框，然后进行信号和槽的连接；</p></li><li><p>如果是color_btn被按下的话，则调用QColorDialog的getColor()方法显示颜色对话框，当选择一种颜色后其十六进制的值会保存在color变量中，但如果点击对话框中的取消(Cancel)按钮的话，则color为无效值。通过isValid()方法判断color是否有效，若有效的话则通过setTextColor()方法设置QTextEdit的文本颜色；</p></li><li><p>如果是font_btn被按下的话，则调用QFontDialog的getFont()方法显示字体对话框，该方法返回两个值，分别为QFont和bool值，如果用户选择了一种字体并按下确定(Ok)的话，则font保存所选择的QFont值，并且ok为True。若按下取消(Cancel)的话，则bool为False。当ok为True时，调用setFont()方法设置QTextEdit的文本字体。</p></li></ol><h4 id="2-输入对话框"><a href="#2-输入对话框" class="headerlink" title="2 输入对话框"></a>2 输入对话框</h4><p>输入对话框一共有五种输入方法：</p><p><img src="https://s2.ax1x.com/2019/08/26/mRf0RU.png" alt="mRf0RU.png"></p><p>下面请看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zh22_2 <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets,QtCore</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span>  QApplication, QWidget, QInputDialog, QLineEdit, QTextEdit, QPushButton, \</span><br><span class="line">                            QGridLayout</span><br><span class="line"><span class="keyword">import</span> sys,time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span><span class="params">(QtWidgets.QMainWindow, Ui_MainWindow)</span>:</span> <span class="comment"># 继承QWidget和Ui_MainWindow</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setupUi(self)          <span class="comment">#加载窗体</span></span><br><span class="line"></span><br><span class="line">        self.name_btn.clicked.connect(self.name_f)</span><br><span class="line">        self.gender_btn.clicked.connect(self.gender_f)</span><br><span class="line">        self.age_btn.clicked.connect(self.age_f)</span><br><span class="line">        self.score_btn.clicked.connect(self.score_f)</span><br><span class="line">        self.info_btn.clicked.connect(self.info_f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_f</span><span class="params">(self)</span>:</span></span><br><span class="line">        name, ok = QInputDialog.getText(self, <span class="string">'Name Input'</span>, <span class="string">'Please enter the name:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.name_line.setText(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gender_f</span><span class="params">(self)</span>:</span></span><br><span class="line">        gender_list = [<span class="string">"Man"</span>, <span class="string">"Woman"</span>]</span><br><span class="line">        gender, ok = QInputDialog.getItem(self, <span class="string">'Geender Input'</span>, <span class="string">'Please select the gender'</span>, gender_list)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.gender_line.setText(gender)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age_f</span><span class="params">(self)</span>:</span></span><br><span class="line">        age, ok = QInputDialog.getInt(self, <span class="string">'Age Input'</span>, <span class="string">'Please enter the age:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.age_line.setText(str(age))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score_f</span><span class="params">(self)</span>:</span></span><br><span class="line">        score, ok = QInputDialog.getDouble(self, <span class="string">'Score Input'</span>, <span class="string">'Please select the score:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.score_line.setText(str(score))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_f</span><span class="params">(self)</span>:</span></span><br><span class="line">        info, ok = QInputDialog.getMultiLineText(self, <span class="string">'Info Input'</span>, <span class="string">'Please enter the info:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.info_line.insertPlainText(info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    mywindow = MyWindow()           <span class="comment"># 创建实例</span></span><br><span class="line">    mywindow.show()                 <span class="comment"># 使用QtWidgets的show()方法</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>前面就是实例化按钮、单行输入框和文本编辑框并通过布局管理器进行排列，我们重点来看下槽函数：</p><ol><li><p><strong>如果是name_btn被点击的话，则调用QInputDialog的getText(parent, str, str)方法，第一个参数为指定的父类，第二个为输入框的标题，第三个为输入框提示。方法会返回一个字符串和一个布尔值，若点击输入框的ok按钮，则变量ok就为True，接着我们调用QLineEdit的setText()方法将其文本设为所输入的内容；</strong></p></li><li><p><strong>getItem(parent, str, str, iterable, int, bool)方法需要多设置几个参数，前三个与getText()相同，第四个参数为要加入的选项内容，这里我们传入了item_list列表，可以让用户选择男性或女性。第五个参数为最初显示的选项，0代表刚开始显示第一个选项，即Female。最后一个参数是选项内容是否可编辑，这里设为False，不可编辑。</strong></p></li></ol><p>其他方法的使用都是类似的，这里就进行省略了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pyqt </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/2019/08/14/python%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/14/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个python程序"><a href="#第一个python程序" class="headerlink" title="第一个python程序"></a>第一个python程序</h2><ol><li><p>在写代码之前，请千万不要用<strong>复制-粘贴</strong>把代码从页面粘贴到你自己的电脑上。写程序也讲究一个感觉，你需要一个字母一个字母地把代码自己敲进去，在敲代码的过程中，初学者经常会敲错代码：拼写不对，大小写不对，混用中英文标点，混用空格和Tab键，所以，你需要仔细地检查、对照，才能以最快的速度掌握如何写程序。</p></li><li><p>直接运行py</p></li></ol><p>有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：</p><blockquote><p>#!/usr/bin/env python3</p><p>print(‘hello, world’)</p></blockquote><p>然后，通过命令给hello.py以执行权限：</p><blockquote><p>$ chmod a+x hello.py</p></blockquote><p>就可以直接运行hello.py了</p><hr><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><ol><li><p>空值<br>空值是Python里一个特殊的值，用<code>None</code>表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p></li><li></li></ol><p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数</p><p><code>//</code>，称为地板除，两个整数的除法仍然是整数</p><p><code>%</code>,取余</p><ol start="3"><li><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符</p></li><li><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p></li></ol><blockquote><p>‘ABC’.encode(‘ascii’)</p><p>b’ABC’</p></blockquote><blockquote><p>‘中文’.encode(‘utf-8’)</p><p>b’\xe4\xb8\xad\xe6\x96\x87’</p></blockquote><p>要计算str包含多少个字符，可以用<code>len()</code>函数</p><ol start="5"><li><p>删除list的元素，用<code>pop(i)</code>方法,<code>i</code>为索引</p><blockquote><p>classmates.pop(i)</p></blockquote></li><li><p>list = []  ; tuple = () ; dict = { ‘ xiaoming  ‘:   15  ,}</p></li><li><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除</p></li><li><p>set  set和dict类似，也是一组key的集合，但不存储value。</p></li><li><p>再议不可变对象</p><p>上面我们讲了，str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><p>而对于不可变对象，比如str，对str进行操作呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure><p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>&#39;Abc&#39;</code>，但变量<code>a</code>最后仍是<code>&#39;abc&#39;</code>，应该怎么理解呢？</p><p>我们先把代码改成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure><p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ a │─────────────────&gt;│ &apos;abc&apos; │</span><br><span class="line">└───┘                  └───────┘</span><br></pre></td></tr></table></figure><p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ a │─────────────────&gt;│ &apos;abc&apos; │</span><br><span class="line">└───┘                  └───────┘</span><br><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ b │─────────────────&gt;│ &apos;Abc&apos; │</span><br><span class="line">└───┘                  └───────┘</span><br></pre></td></tr></table></figure><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p></li><li><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>   执行这段代码，会依次打印<code>names</code>的每一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure><p>   第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>   在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p><p>   另外的，</p><p>   如果要提前结束循环，可以用<code>break</code>语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    print(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>   在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><hr><h2 id="字符串方法及注释"><a href="#字符串方法及注释" class="headerlink" title="字符串方法及注释"></a>字符串方法及注释</h2><table><thead><tr><th>capitalize()</th><th>把字符串的第一个字符改为大写</th></tr></thead><tbody><tr><td>casefold()</td><td>把整个字符串的所有字符改为小写</td></tr><tr><td>center(width)</td><td>将字符串居中，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>count(sub[, start[, end]])</td><td>返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。</td></tr><tr><td>encode(encoding=’utf-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式对字符串进行编码。</td></tr><tr><td>endswith(sub[, start[, end]])</td><td>检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。</td></tr><tr><td>expandtabs([tabsize=8])</td><td>把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。</td></tr><tr><td>find(sub[, start[, end]])</td><td>检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。</td></tr><tr><td>index(sub[, start[, end]])</td><td>跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。</td></tr><tr><td>isalnum()</td><td>如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。</td></tr><tr><td>isalpha()</td><td>如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</td></tr><tr><td>isdecimal()</td><td>如果字符串只包含十进制数字则返回 True，否则返回 False。</td></tr><tr><td>isdigit()</td><td>如果字符串只包含数字则返回 True，否则返回 False。</td></tr><tr><td>islower()</td><td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。</td></tr><tr><td>isnumeric()</td><td>如果字符串中只包含数字字符，则返回 True，否则返回 False。</td></tr><tr><td>isspace()</td><td>如果字符串中只包含空格，则返回 True，否则返回 False。</td></tr><tr><td>istitle()</td><td>如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。</td></tr><tr><td>isupper()</td><td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。</td></tr><tr><td>join(sub)</td><td>以字符串作为分隔符，插入到 sub 中所有的字符之间。</td></tr><tr><td>ljust(width)</td><td>返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td></tr><tr><td>lower()</td><td>转换字符串中所有大写字符为小写。</td></tr><tr><td>lstrip()</td><td>去掉字符串左边的所有空格</td></tr><tr><td>partition(sub)</td><td>找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’)</td></tr><tr><td>replace(old, new[, count])</td><td>把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。</td></tr><tr><td>rfind(sub[, start[, end]])</td><td>类似于 find() 方法，不过是从右边开始查找。</td></tr><tr><td>rindex(sub[, start[, end]])</td><td>类似于 index() 方法，不过是从右边开始。</td></tr><tr><td>rjust(width)</td><td>返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td></tr><tr><td>rpartition(sub)</td><td>类似于 partition() 方法，不过是从右边开始查找。</td></tr><tr><td>rstrip()</td><td>删除字符串末尾的空格。</td></tr><tr><td>split(sep=None, maxsplit=-1)</td><td>不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。</td></tr><tr><td>splitlines(([keepends]))</td><td>在输出结果里是否去掉换行符，默认为 False，不包含换行符；如果为 True，则保留换行符。。</td></tr><tr><td>startswith(prefix[, start[, end]])</td><td>检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。</td></tr><tr><td>strip([chars])</td><td>删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。</td></tr><tr><td>swapcase()</td><td>翻转字符串中的大小写。</td></tr><tr><td>title()</td><td>返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。</td></tr><tr><td>translate(table)</td><td>根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符。</td></tr><tr><td>upper()</td><td>转换字符串中的所有小写字符为大写。</td></tr><tr><td>zfill(width)</td><td>返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。</td></tr></tbody></table><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> <strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><p>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件打开模式</strong></p><table><thead><tr><th><strong>打开模式</strong></th><th><strong>执行操作</strong></th></tr></thead><tbody><tr><td>‘r’</td><td>以只读方式打开文件（默认）</td></tr><tr><td>‘w’</td><td>以写入的方式打开文件，会覆盖已存在的文件</td></tr><tr><td>‘x’</td><td>如果文件已经存在，使用此模式打开将引发异常</td></tr><tr><td>‘a’</td><td>以写入模式打开，如果文件存在，则在末尾追加写入</td></tr><tr><td>‘b’</td><td>以二进制模式打开文件</td></tr><tr><td>‘t’</td><td>以文本模式打开（默认）</td></tr><tr><td>‘+’</td><td>可读写模式（可添加到其他模式中使用）</td></tr><tr><td>‘U’</td><td>通用换行符支持</td></tr></tbody></table><p>​    <strong>文件对象方法</strong></p><table><thead><tr><th><strong>文件对象方法</strong></th><th><strong>执行操作</strong></th></tr></thead><tbody><tr><td>f.close()</td><td>关闭文件</td></tr><tr><td>f.read([size=-1])</td><td>从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回</td></tr><tr><td>f.readline([size=-1])</td><td>从文件中读取并返回一行（包括行结束符），如果有size有定义则返回size个字符</td></tr><tr><td>f.write(str)</td><td>将字符串str写入文件</td></tr><tr><td>f.writelines(seq)</td><td>向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象</td></tr><tr><td>f.seek(offset, from)</td><td>在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节</td></tr><tr><td>f.tell()</td><td>返回当前在文件中的位置</td></tr><tr><td>f.truncate([size=file.tell()])</td><td>截取文件到size个字节，默认是截取到文件指针当前位置</td></tr></tbody></table><p><strong>OS模块</strong></p><p><strong>os模块中关于文件/目录常用的函数使用方法</strong></p><table><thead><tr><th><strong>函数名</strong></th><th><strong>使用方法</strong></th></tr></thead><tbody><tr><td>getcwd()</td><td>返回当前工作目录</td></tr><tr><td>chdir(path)</td><td>改变工作目录</td></tr><tr><td>listdir(path=’.’)</td><td>列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录）</td></tr><tr><td>mkdir(path)</td><td>创建单层目录，如该目录已存在抛出异常</td></tr><tr><td>makedirs(path)</td><td>递归创建多层目录，如该目录已存在抛出异常，注意：’E:\a\b’和’E:\a\c’并不会冲突</td></tr><tr><td>remove(path)</td><td>删除文件</td></tr><tr><td>rmdir(path)</td><td>删除单层目录，如该目录非空则抛出异常</td></tr><tr><td>removedirs(path)</td><td>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常</td></tr><tr><td>rename(old, new)</td><td>将文件old重命名为new</td></tr><tr><td>system(command)</td><td>运行系统的shell命令</td></tr><tr><td>walk(top)</td><td>遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】</td></tr><tr><td><em>以下是支持路径操作中常用到的一些定义，支持所有平台</em></td><td></td></tr><tr><td>os.curdir</td><td>指代当前目录（’.’）</td></tr><tr><td>os.pardir</td><td>指代上一级目录（’..’）</td></tr><tr><td>os.sep</td><td>输出操作系统特定的路径分隔符（Win下为’\‘，Linux下为’/‘）</td></tr><tr><td>os.linesep</td><td>当前平台使用的行终止符（Win下为’\r\n’，Linux下为’\n’）</td></tr><tr><td>os.name</td><td>指代当前使用的操作系统（包括：’posix’,  ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’）</td></tr></tbody></table><p><strong><strong>os.path模块中关于路径常用的函数使用方法</strong></strong></p><table><thead><tr><th><strong>函数名</strong></th><th><strong>使用方法</strong></th></tr></thead><tbody><tr><td>basename(path)</td><td>去掉目录路径，单独返回文件名</td></tr><tr><td>dirname(path)</td><td>去掉文件名，单独返回目录路径</td></tr><tr><td>join(path1[, path2[, …]])</td><td>将path1, path2各部分组合成一个路径名</td></tr><tr><td>split(path)</td><td>分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在</td></tr><tr><td>splitext(path)</td><td>分离文件名与扩展名，返回(f_name, f_extension)元组</td></tr><tr><td>getsize(file)</td><td>返回指定文件的尺寸，单位是字节</td></tr><tr><td>getatime(file)</td><td>返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr><tr><td>getctime(file)</td><td>返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr><tr><td>getmtime(file)</td><td>返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr><tr><td><em>以下为函数返回 True 或 False</em></td><td></td></tr><tr><td>exists(path)</td><td>判断指定路径（目录或文件）是否存在</td></tr><tr><td>isabs(path)</td><td>判断指定路径是否为绝对路径</td></tr><tr><td>isdir(path)</td><td>判断指定路径是否存在且是一个目录</td></tr><tr><td>isfile(path)</td><td>判断指定路径是否存在且是一个文件</td></tr><tr><td>islink(path)</td><td>判断指定路径是否存在且是一个符号链接</td></tr><tr><td>ismount(path)</td><td>判断指定路径是否存在且是一个挂载点</td></tr><tr><td>samefile(path1, paht2)</td><td>判断path1和path2两个路径是否指向同一个文件</td></tr></tbody></table><hr><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p><strong>Python标准异常总结</strong></p><table><thead><tr><th>AssertionError</th><th>断言语句（assert）失败</th></tr></thead><tbody><tr><td>AttributeError</td><td>尝试访问未知的对象属性</td></tr><tr><td>EOFError</td><td>用户输入文件末尾标志EOF（Ctrl+d）</td></tr><tr><td>FloatingPointError</td><td>浮点计算错误</td></tr><tr><td>GeneratorExit</td><td>generator.close()方法被调用的时候</td></tr><tr><td>ImportError</td><td>导入模块失败的时候</td></tr><tr><td>IndexError</td><td>索引超出序列的范围</td></tr><tr><td>KeyError</td><td>字典中查找一个不存在的关键字</td></tr><tr><td>KeyboardInterrupt</td><td>用户输入中断键（Ctrl+c）</td></tr><tr><td>MemoryError</td><td>内存溢出（可通过删除对象释放内存）</td></tr><tr><td>NameError</td><td>尝试访问一个不存在的变量</td></tr><tr><td>NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td>OSError</td><td>操作系统产生的异常（例如打开一个不存在的文件）</td></tr><tr><td>OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td>ReferenceError</td><td>弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象</td></tr><tr><td>RuntimeError</td><td>一般的运行时错误</td></tr><tr><td>StopIteration</td><td>迭代器没有更多的值</td></tr><tr><td>SyntaxError</td><td>Python的语法错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>TabError</td><td>Tab和空格混合使用</td></tr><tr><td>SystemError</td><td>Python编译器系统错误</td></tr><tr><td>SystemExit</td><td>Python编译器进程被关闭</td></tr><tr><td>TypeError</td><td>不同类型间的无效操作</td></tr><tr><td>UnboundLocalError</td><td>访问一个未初始化的本地变量（NameError的子类）</td></tr><tr><td>UnicodeError</td><td>Unicode相关的错误（ValueError的子类）</td></tr><tr><td>UnicodeEncodeError</td><td>Unicode编码时的错误（UnicodeError的子类）</td></tr><tr><td>UnicodeDecodeError</td><td>Unicode解码时的错误（UnicodeError的子类）</td></tr><tr><td>UnicodeTranslateError</td><td>Unicode转换时的错误（UnicodeError的子类）</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>ZeroDivisionError</td><td>除数为零</td></tr></tbody></table><p><strong>以下是 Python 内置异常类的层次结构：</strong></p><p>BaseException<br>+– SystemExit<br>+– KeyboardInterrupt<br>+– GeneratorExit<br>+– Exception<br>      +– StopIteration<br>      +– ArithmeticError<br>      |    +– FloatingPointError<br>      |    +– OverflowError<br>      |    +– ZeroDivisionError<br>      +– AssertionError<br>      +– AttributeError<br>      +– BufferError<br>      +– EOFError<br>      +– ImportError<br>      +– LookupError<br>      |    +– IndexError<br>      |    +– KeyError<br>      +– MemoryError<br>      +– NameError<br>      |    +– UnboundLocalError<br>      +– OSError<br>      |    +– BlockingIOError<br>      |    +– ChildProcessError<br>      |    +– ConnectionError<br>      |    |    +– BrokenPipeError<br>      |    |    +– ConnectionAbortedError<br>      |    |    +– ConnectionRefusedError<br>      |    |    +– ConnectionResetError<br>      |    +– FileExistsError<br>      |    +– FileNotFoundError<br>      |    +– InterruptedError<br>      |    +– IsADirectoryError<br>      |    +– NotADirectoryError<br>      |    +– PermissionError<br>      |    +– ProcessLookupError<br>      |    +– TimeoutError<br>      +– ReferenceError<br>      +– RuntimeError<br>      |    +– NotImplementedError<br>      +– SyntaxError<br>      |    +– IndentationError<br>      |         +– TabError<br>      +– SystemError<br>      +– TypeError<br>      +– ValueError<br>      |    +– UnicodeError<br>      |         +– UnicodeDecodeError<br>      |         +– UnicodeEncodeError<br>      |         +– UnicodeTranslateError<br>      +– Warning<br>           +– DeprecationWarning<br>           +– PendingDeprecationWarning<br>           +– RuntimeWarning<br>           +– SyntaxWarning<br>           +– UserWarning<br>           +– FutureWarning<br>           +– ImportWarning<br>           +– UnicodeWarning<br>           +– BytesWarning<br>           +– ResourceWarning</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><strong>对象 = 属性 + 方法</strong></p><p>类是为了让对象实现量产.</p><p>self指的是<strong>类实例对象本身</strong>(注意：不是类本身)</p><p>若子类会覆盖父类的<code>__init__</code>时，可采用(1)调用父类 <code>父类.__init__(self)</code>   (2) <code>supur().__init__()</code></p><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>在Python中，如果import的语句比较长，导致后续引用不方便，可以使用as语法，比如：</p><p><code>import dir1.dir2.mod</code></p><p>那么，后续对mod的引用，都必须是dir1.dir2.mod</p><p><code>dir1.dir2.mod.X</code><br>那么，为了简化输入，可以使用as语法：</p><p><code>import dir1.dir2.mod as m</code></p><p>那么，后续对mod的引用，可以直接使用m</p><p><code>m. X</code></p><p>需要注意的是，使用as语法之后，只能通过as后面名字来访问导入的moudle</p><p><code>import mod as mm.X  # OKmod.X # Error</code></p><p>下面提供as的完整语法格式，import和from都支持：</p><p><code>import modulename as name  # 只能通过name来引用</code></p><p><code>from modulename import attrname as name  # 只能通过name来引用</code></p><h2 id="魔法方法-左右两边两个下划线"><a href="#魔法方法-左右两边两个下划线" class="headerlink" title="魔法方法(左右两边两个下划线)"></a>魔法方法(左右两边两个下划线)</h2><table><thead><tr><th><strong>魔法方法</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td></td><td><strong>基本的魔法方法</strong></td></tr><tr><td><strong>new</strong>(cls[, …])</td><td>1. <strong>new</strong> 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 <strong>init</strong> 方法 3. <strong>new</strong> 决定是否要使用该 <strong>init</strong> 方法，因为 <strong>new</strong> 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 <strong>new</strong> 没有返回实例对象，则 <strong>init</strong> 不会被调用 4. <strong>new</strong> 主要是用于继承一个不可变的类型比如一个 tuple 或者 string</td></tr><tr><td><strong>init</strong>(self[, …])</td><td>构造器，当一个实例被创建的时候调用的初始化方法</td></tr><tr><td><strong>del</strong>(self)</td><td>析构器，当一个实例被销毁的时候调用的方法</td></tr><tr><td><strong>call</strong>(self[, args…])</td><td>允许一个类的实例像函数一样被调用：x(a, b) 调用 x.<strong>call</strong>(a, b)</td></tr><tr><td><strong>len</strong>(self)</td><td>定义当被 len() 调用时的行为</td></tr><tr><td><strong>repr</strong>(self)</td><td>定义当被 repr() 调用时的行为</td></tr><tr><td><strong>str</strong>(self)</td><td>定义当被 str() 调用时的行为</td></tr><tr><td><strong>bytes</strong>(self)</td><td>定义当被 bytes() 调用时的行为</td></tr><tr><td><strong>hash</strong>(self)</td><td>定义当被 hash() 调用时的行为</td></tr><tr><td><strong>bool</strong>(self)</td><td>定义当被 bool() 调用时的行为，应该返回 True 或 False</td></tr><tr><td><strong>format</strong>(self, format_spec)</td><td>定义当被 format() 调用时的行为</td></tr><tr><td></td><td><strong>有关属性</strong></td></tr><tr><td><strong>getattr</strong>(self, name)</td><td>定义当用户试图获取一个不存在的属性时的行为</td></tr><tr><td><strong>getattribute</strong>(self, name)</td><td>定义当该类的属性被访问时的行为</td></tr><tr><td><strong>setattr</strong>(self, name, value)</td><td>定义当一个属性被设置时的行为</td></tr><tr><td><strong>delattr</strong>(self, name)</td><td>定义当一个属性被删除时的行为</td></tr><tr><td><strong>dir</strong>(self)</td><td>定义当 dir() 被调用时的行为</td></tr><tr><td><strong>get</strong>(self, instance, owner)</td><td>定义当描述符的值被取得时的行为</td></tr><tr><td><strong>set</strong>(self, instance, value)</td><td>定义当描述符的值被改变时的行为</td></tr><tr><td><strong>delete</strong>(self, instance)</td><td>定义当描述符的值被删除时的行为</td></tr><tr><td></td><td><strong>比较操作符</strong></td></tr><tr><td><strong>lt</strong>(self, other)</td><td>定义小于号的行为：x &lt; y 调用 x.<strong>lt</strong>(y)</td></tr><tr><td><strong>le</strong>(self, other)</td><td>定义小于等于号的行为：x &lt;= y 调用 x.<strong>le</strong>(y)</td></tr><tr><td><strong>eq</strong>(self, other)</td><td>定义等于号的行为：x == y 调用 x.<strong>eq</strong>(y)</td></tr><tr><td><strong>ne</strong>(self, other)</td><td>定义不等号的行为：x != y 调用 x.<strong>ne</strong>(y)</td></tr><tr><td><strong>gt</strong>(self, other)</td><td>定义大于号的行为：x &gt; y 调用 x.<strong>gt</strong>(y)</td></tr><tr><td><strong>ge</strong>(self, other)</td><td>定义大于等于号的行为：x &gt;= y 调用 x.<strong>ge</strong>(y)</td></tr><tr><td></td><td><strong>算数运算符</strong></td></tr><tr><td><strong>add</strong>(self, other)</td><td>定义加法的行为：+</td></tr><tr><td><strong>sub</strong>(self, other)</td><td>定义减法的行为：-</td></tr><tr><td><strong>mul</strong>(self, other)</td><td>定义乘法的行为：*</td></tr><tr><td><strong>truediv</strong>(self, other)</td><td>定义真除法的行为：/</td></tr><tr><td><strong>floordiv</strong>(self, other)</td><td>定义整数除法的行为：//</td></tr><tr><td><strong>mod</strong>(self, other)</td><td>定义取模算法的行为：%</td></tr><tr><td><strong>divmod</strong>(self, other)</td><td>定义当被 divmod() 调用时的行为</td></tr><tr><td><strong>pow</strong>(self, other[, modulo])</td><td>定义当被 power() 调用或 ** 运算时的行为</td></tr><tr><td><strong>lshift</strong>(self, other)</td><td>定义按位左移位的行为：&lt;&lt;</td></tr><tr><td><strong>rshift</strong>(self, other)</td><td>定义按位右移位的行为：&gt;&gt;</td></tr><tr><td><strong>and</strong>(self, other)</td><td>定义按位与操作的行为：&amp;</td></tr><tr><td><strong>xor</strong>(self, other)</td><td>定义按位异或操作的行为：^</td></tr><tr><td><strong>or</strong>(self, other)</td><td>定义按位或操作的行为：|</td></tr><tr><td></td><td><strong>反运算</strong></td></tr><tr><td><strong>radd</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rsub</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rmul</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rtruediv</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rfloordiv</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rmod</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rdivmod</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rpow</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rlshift</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rrshift</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rand</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>rxor</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>ror</strong>(self, other)</td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td></td><td><strong>增量赋值运算</strong></td></tr><tr><td><strong>iadd</strong>(self, other)</td><td>定义赋值加法的行为：+=</td></tr><tr><td><strong>isub</strong>(self, other)</td><td>定义赋值减法的行为：-=</td></tr><tr><td><strong>imul</strong>(self, other)</td><td>定义赋值乘法的行为：*=</td></tr><tr><td><strong>itruediv</strong>(self, other)</td><td>定义赋值真除法的行为：/=</td></tr><tr><td><strong>ifloordiv</strong>(self, other)</td><td>定义赋值整数除法的行为：//=</td></tr><tr><td><strong>imod</strong>(self, other)</td><td>定义赋值取模算法的行为：%=</td></tr><tr><td><strong>ipow</strong>(self, other[, modulo])</td><td>定义赋值幂运算的行为：**=</td></tr><tr><td><strong>ilshift</strong>(self, other)</td><td>定义赋值按位左移位的行为：&lt;&lt;=</td></tr><tr><td><strong>irshift</strong>(self, other)</td><td>定义赋值按位右移位的行为：&gt;&gt;=</td></tr><tr><td><strong>iand</strong>(self, other)</td><td>定义赋值按位与操作的行为：&amp;=</td></tr><tr><td><strong>ixor</strong>(self, other)</td><td>定义赋值按位异或操作的行为：^=</td></tr><tr><td><strong>ior</strong>(self, other)</td><td>定义赋值按位或操作的行为：|=</td></tr><tr><td></td><td><strong>一元操作符</strong></td></tr><tr><td><strong>pos</strong>(self)</td><td>定义正号的行为：+x</td></tr><tr><td><strong>neg</strong>(self)</td><td>定义负号的行为：-x</td></tr><tr><td><strong>abs</strong>(self)</td><td>定义当被 abs() 调用时的行为</td></tr><tr><td><strong>invert</strong>(self)</td><td>定义按位求反的行为：~x</td></tr><tr><td></td><td><strong>类型转换</strong></td></tr><tr><td><strong>complex</strong>(self)</td><td>定义当被 complex() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong>int</strong>(self)</td><td>定义当被 int() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong>float</strong>(self)</td><td>定义当被 float() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong>round</strong>(self[, n])</td><td>定义当被 round() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong>index</strong>(self)</td><td>1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 <strong>index</strong> 3. 如果 <strong>index</strong> 被定义，则 <strong>int</strong> 也需要被定义，且返回相同的值</td></tr><tr><td></td><td><strong>上下文管理（with 语句）</strong></td></tr><tr><td><strong>enter</strong>(self)</td><td>1. 定义当使用 with 语句时的初始化行为 2. <strong>enter</strong> 的返回值被 with 语句的目标或者 as 后的名字绑定</td></tr><tr><td><strong>exit</strong>(self, exc_type, exc_value, traceback)</td><td>1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作</td></tr><tr><td></td><td><strong>容器类型</strong></td></tr><tr><td><strong>len</strong>(self)</td><td>定义当被 len() 调用时的行为（返回容器中元素的个数）</td></tr><tr><td><strong>getitem</strong>(self, key)</td><td>定义获取容器中指定元素的行为，相当于 self[key]</td></tr><tr><td><strong>setitem</strong>(self, key, value)</td><td>定义设置容器中指定元素的行为，相当于 self[key] = value</td></tr><tr><td><strong>delitem</strong>(self, key)</td><td>定义删除容器中指定元素的行为，相当于 del self[key]</td></tr><tr><td><strong>iter</strong>(self)</td><td>定义当迭代容器中的元素的行为</td></tr><tr><td><strong>reversed</strong>(self)</td><td>定义当被 reversed() 调用时的行为</td></tr><tr><td><strong>contains</strong>(self, item)</td><td>定义当使用成员测试运算符（in 或 not in）时的行为</td></tr></tbody></table><h2 id="super-不是父类，而是继承顺序的下一个类"><a href="#super-不是父类，而是继承顺序的下一个类" class="headerlink" title="super()不是父类，而是继承顺序的下一个类"></a>super()不是父类，而是继承顺序的下一个类</h2><p>super()可以避免重复调用</p><p>如果childA基础Base, childB继承childA和Base，如果childB需要调用Base的<strong>init</strong>()方法时，就会导致<strong>init</strong>()被执行两次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Base create'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">childA</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'enter A '</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'leave A'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">childB</span><span class="params">(childA, Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        childA.__init__(self)</span><br><span class="line">        Base.__init__(self)</span><br><span class="line"></span><br><span class="line">b = childB()</span><br></pre></td></tr></table></figure><p>Base的<strong>init</strong>()方法被执行了两次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter A </span><br><span class="line">Base create</span><br><span class="line">leave A</span><br><span class="line">Base create</span><br></pre></td></tr></table></figure><p>使用super()是可避免重复调用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Base create'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">childA</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'enter A '</span></span><br><span class="line">        super(childA, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'leave A'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">childB</span><span class="params">(childA, Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(childB, self).__init__()</span><br><span class="line"></span><br><span class="line">b = childB()</span><br><span class="line"><span class="keyword">print</span> b.__class__.mro()</span><br><span class="line">enter A </span><br><span class="line">Base create</span><br><span class="line">leave A</span><br><span class="line">[&lt;class '__main__.childB'&gt;, &lt;class '__main__.childA'&gt;, &lt;class '__main__.Base'&gt;, &lt;type 'object'&gt;]</span><br></pre></td></tr></table></figure><h4 id="Python变量前’‘和’-‘的作用"><a href="#Python变量前’‘和’-‘的作用" class="headerlink" title="Python变量前’‘和’*‘的作用"></a>Python变量前’<em>‘和’*</em>‘的作用</h4><p>在Python的在形参前加’<em>‘和’*</em>‘表示动态形参</p><p>在形参前加’*’表示可以接受多个实参值存进数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def F(a, *b)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">F(1, 2, 3)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">1    </span><br><span class="line">(2, 3)</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><p>对于在形参前加’**’表示表示接受参数转化为字典类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def F(**a)</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">F(x=1, y=2)</span><br><span class="line"></span><br><span class="line">#&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;</span><br></pre></td></tr></table></figure><p>混合运用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def F(a, *b, **c)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line"></span><br><span class="line">F(1, 2, 3, x=4, y=5)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">1</span><br><span class="line">(2, 3)</span><br><span class="line">&#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">F</span><span class="params">(*a)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">ls = [1, 2, 3]</span><br><span class="line">F(ls)  <span class="comment">#表示列表作为一个元素传入</span></span><br><span class="line">F(*ls) <span class="comment">#表示列表元素作为多个元素传入</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">([1, 2, 3],)</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">F</span><span class="params">(**a)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">dt = dict(x=1, y=2)</span><br><span class="line">F(x=<span class="number">1</span>, y=<span class="number">2</span>) </span><br><span class="line">F(**dt)  <span class="comment">#作为字典传入</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'x': 1, 'y':2&#125;</span></span><br><span class="line"><span class="string">&#123;'x': 1, 'y':2&#125;</span></span><br><span class="line"><span class="string">函数调用时</span></span><br><span class="line"><span class="string">dt = dict(color='red', fontproperties='SimHei')</span></span><br><span class="line"><span class="string">plt.plot(**dt)  </span></span><br><span class="line"><span class="string">等价于</span></span><br><span class="line"><span class="string">plt.plot(color='red', fontproperties='SimHei')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><hr><h3 id="python迭代器详解"><a href="#python迭代器详解" class="headerlink" title="python迭代器详解"></a>python迭代器详解</h3><p><strong>迭代器</strong></p><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p><strong>1. 可迭代对象</strong></p><p>我们已经知道可以对list、tuple、str等类型的数据使用for…in…的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫<strong>迭代</strong>。</p><p><strong>但是，是否所有的数据类型都可以放到for…in…的语句中，然后让for…in…每次从中取出一条数据供我们使用，即供我们迭代吗？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">100</span>:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># int整型不是iterable，即int整型不是可以迭代的</span></span><br><span class="line"><span class="comment"># 我们自定义一个容器MyList用来存放数据，可以通过add方法向其中添加数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.container = []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.container.append(item)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>    print(num)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'MyList'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># MyList容器的对象也是不能迭代的</span></span><br></pre></td></tr></table></figure><p>我们自定义了一个容器类型MyList，在将一个存放了多个数据的MyList对象放到for…in…的语句中，发现for…in…并不能从中依次取出一条数据返回给我们，也就说我们随便封装了一个可以存放多条数据的类型却并不能被迭代使用。</p><p>我们把可以通过for…in…这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）**。</p><p><strong>2. 如何判断一个对象是否可以迭代</strong></p><p>可以使用 isinstance() 判断一个对象是否是 Iterable 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: isinstance([], Iterable)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: isinstance(&#123;&#125;, Iterable)</span><br><span class="line">Out[<span class="number">52</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: isinstance(mylist, Iterable)</span><br><span class="line">Out[<span class="number">54</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>3. 可迭代对象的本质</strong></p><p>我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为<strong>迭代器(Iterator)</strong>。</p><p>可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。</p><p>可迭代对象通过<code>__iter__</code>方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.</p><p>那么也就是说，一个具备了<code>__iter__</code>方法的对象，就是一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.container = []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.container.append(item)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">"""返回一个迭代器"""</span></span><br><span class="line"><span class="meta">... </span>            <span class="comment"># 我们暂时忽略如何构造一个迭代器对象</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(mylist, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># 这回测试发现添加了__iter__方法的mylist对象已经是一个可迭代对象了</span></span><br></pre></td></tr></table></figure><p><strong>4. iter()函数与next()函数</strong></p><p>list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。iter()函数实际上就是调用了可迭代对象的<code>__iter__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li_iter = iter(li)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(li_iter)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意，当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。**</p><p><strong>5. 如何判断一个对象是否是迭代器</strong></p><p>可以使用 isinstance() 判断一个对象是否是 Iterator 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">In [<span class="number">57</span>]: isinstance([], Iterator)</span><br><span class="line">Out[<span class="number">57</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">58</span>]: isinstance(iter([]), Iterator)</span><br><span class="line">Out[<span class="number">58</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">59</span>]: isinstance(iter(<span class="string">"abc"</span>), Iterator)</span><br><span class="line">Out[<span class="number">59</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>6. 迭代器Iterator</strong></p><p>通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的<code>__next__</code>方法（Python3中是对象的<code>__next__</code>方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的<code>__next__</code>方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可。</p><p><strong>一个实现了iter方法和next方法的对象，就是迭代器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""自定义的一个可迭代对象"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        myiterator = MyIterator(self)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""自定义的供上面可迭代对象使用的一个迭代器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mylist)</span>:</span></span><br><span class="line">        self.mylist = mylist</span><br><span class="line">        <span class="comment"># current用来记录当前访问到的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current &lt; len(self.mylist.items):</span><br><span class="line">            item = self.mylist.items[self.current]</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> mylist:</span><br><span class="line">        print(num)</span><br></pre></td></tr></table></figure><p><strong>7. for…in…循环的本质</strong></p><p>for <strong>item</strong> in <strong>Iterable</strong> 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。</p><p><strong>8. 迭代器的应用场景</strong></p><p>我们发现迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。</p><p>举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>现在我们想要通过for…in…循环来遍历迭代斐波那契数列中的前n个数。那么这个斐波那契数列我们就可以用迭代器来实现，每次迭代都通过数学计算来生成下一个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""斐波那契数列迭代器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param n: int, 指明生成数列的前n个数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n = n</span><br><span class="line">        <span class="comment"># current用来保存当前生成到数列中的第几个数了</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line">        <span class="comment"># num1用来保存前前一个数，初始值为数列中的第一个数0</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        <span class="comment"># num2用来保存前一个数，初始值为数列中的第二个数1</span></span><br><span class="line">        self.num2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""被next()函数调用来获取下一个数"""</span></span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.n:</span><br><span class="line">            num = self.num1</span><br><span class="line">            self.num1, self.num2 = self.num2, self.num1+self.num2</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""迭代器的__iter__返回自身即可"""</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fib = FibIterator(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> fib:</span><br><span class="line">        print(num, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><p><strong>9. 并不是只有for循环能接收可迭代对象</strong></p><p>除了for循环能接收可迭代对象，list、tuple等也能接收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = list(FibIterator(<span class="number">15</span>))</span><br><span class="line">print(li)</span><br><span class="line">tp = tuple(FibIterator(<span class="number">6</span>))</span><br><span class="line">print(tp)</span><br></pre></td></tr></table></figure><hr><h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><hr><h3 id="python-raise"><a href="#python-raise" class="headerlink" title="python raise"></a>python raise</h3><p>当程序出现错误，python会自动引发异常，也可以通过raise显示地引发异常。一旦执行了raise语句，raise后面的语句将不能执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP开发板灯光控制上位机</title>
      <link href="/2019/08/12/DSP%E5%BC%80%E5%8F%91%E6%9D%BF%E7%81%AF%E5%85%89%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BD%8D%E6%9C%BA/"/>
      <url>/2019/08/12/DSP%E5%BC%80%E5%8F%91%E6%9D%BF%E7%81%AF%E5%85%89%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BD%8D%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>在前几天对PYQT5的学习以后，自己试着做了一个上位机 来对DSP开发板实现LED亮灭操作。</p><p>软硬件:pycharm + PYQT5 + CCS6.0 + DSP开发板</p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>上位机界面<br><img src="https://s2.ax1x.com/2019/08/12/mSdSbj.png" alt="mSdSbj.png"></p><p>LED控制  </p><p>描述：当按下 &lt;打开1灯&gt;时 1亮、2灭。当按下 &lt;打开2灯&gt;时 2亮、1灭。</p><p><img src="https://s2.ax1x.com/2019/08/12/mSBOoj.jpg" alt="mSBOoj.jpg"></p><p><img src="https://s2.ax1x.com/2019/08/12/mSBLwQ.jpg" alt="mSBLwQ.jpg"></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>在CCS对GPIO进行写操作时(GPXDTA.bit = ) 无法成功写入，在顺华师兄建议下 改用SET CLEAR操作解决. 至于为何DAT不好用还未知？</p></li><li><p>关于串口发送 16进制问题</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>ui_demo.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Form implementation generated from reading ui file 'ui_demo_1.ui'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Created by: PyQt5 UI code generator 5.11.3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING! All changes made in this file will be lost!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui_Form</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span><span class="params">(self, Form)</span>:</span></span><br><span class="line">        Form.setObjectName(<span class="string">"Form"</span>)</span><br><span class="line">        Form.resize(<span class="number">868</span>, <span class="number">452</span>)</span><br><span class="line">        self.formGroupBox = QtWidgets.QGroupBox(Form)</span><br><span class="line">        self.formGroupBox.setGeometry(QtCore.QRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">167</span>, <span class="number">301</span>))</span><br><span class="line">        self.formGroupBox.setObjectName(<span class="string">"formGroupBox"</span>)</span><br><span class="line">        self.formLayout = QtWidgets.QFormLayout(self.formGroupBox)</span><br><span class="line">        self.formLayout.setContentsMargins(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        self.formLayout.setSpacing(<span class="number">10</span>)</span><br><span class="line">        self.formLayout.setObjectName(<span class="string">"formLayout"</span>)</span><br><span class="line">        self.s1__lb_1 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_1.setObjectName(<span class="string">"s1__lb_1"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">0</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_1)</span><br><span class="line">        self.s1__box_1 = QtWidgets.QPushButton(self.formGroupBox)</span><br><span class="line">        self.s1__box_1.setAutoRepeatInterval(<span class="number">100</span>)</span><br><span class="line">        self.s1__box_1.setDefault(<span class="literal">True</span>)</span><br><span class="line">        self.s1__box_1.setObjectName(<span class="string">"s1__box_1"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">0</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_1)</span><br><span class="line">        self.s1__lb_2 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_2.setObjectName(<span class="string">"s1__lb_2"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">1</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_2)</span><br><span class="line">        self.s1__box_2 = QtWidgets.QComboBox(self.formGroupBox)</span><br><span class="line">        self.s1__box_2.setObjectName(<span class="string">"s1__box_2"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">1</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_2)</span><br><span class="line">        self.s1__lb_3 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_3.setObjectName(<span class="string">"s1__lb_3"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">3</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_3)</span><br><span class="line">        self.s1__box_3 = QtWidgets.QComboBox(self.formGroupBox)</span><br><span class="line">        self.s1__box_3.setObjectName(<span class="string">"s1__box_3"</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_3.addItem(<span class="string">""</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">3</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_3)</span><br><span class="line">        self.s1__lb_4 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_4.setObjectName(<span class="string">"s1__lb_4"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">4</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_4)</span><br><span class="line">        self.s1__box_4 = QtWidgets.QComboBox(self.formGroupBox)</span><br><span class="line">        self.s1__box_4.setObjectName(<span class="string">"s1__box_4"</span>)</span><br><span class="line">        self.s1__box_4.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_4.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_4.addItem(<span class="string">""</span>)</span><br><span class="line">        self.s1__box_4.addItem(<span class="string">""</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">4</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_4)</span><br><span class="line">        self.s1__lb_5 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_5.setObjectName(<span class="string">"s1__lb_5"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">5</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_5)</span><br><span class="line">        self.s1__box_5 = QtWidgets.QComboBox(self.formGroupBox)</span><br><span class="line">        self.s1__box_5.setObjectName(<span class="string">"s1__box_5"</span>)</span><br><span class="line">        self.s1__box_5.addItem(<span class="string">""</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">5</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_5)</span><br><span class="line">        self.open_button = QtWidgets.QPushButton(self.formGroupBox)</span><br><span class="line">        self.open_button.setObjectName(<span class="string">"open_button"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">7</span>, QtWidgets.QFormLayout.SpanningRole, self.open_button)</span><br><span class="line">        self.close_button = QtWidgets.QPushButton(self.formGroupBox)</span><br><span class="line">        self.close_button.setObjectName(<span class="string">"close_button"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">8</span>, QtWidgets.QFormLayout.SpanningRole, self.close_button)</span><br><span class="line">        self.s1__lb_6 = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.s1__lb_6.setObjectName(<span class="string">"s1__lb_6"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">6</span>, QtWidgets.QFormLayout.LabelRole, self.s1__lb_6)</span><br><span class="line">        self.s1__box_6 = QtWidgets.QComboBox(self.formGroupBox)</span><br><span class="line">        self.s1__box_6.setObjectName(<span class="string">"s1__box_6"</span>)</span><br><span class="line">        self.s1__box_6.addItem(<span class="string">""</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">6</span>, QtWidgets.QFormLayout.FieldRole, self.s1__box_6)</span><br><span class="line">        self.state_label = QtWidgets.QLabel(self.formGroupBox)</span><br><span class="line">        self.state_label.setText(<span class="string">""</span>)</span><br><span class="line">        self.state_label.setTextFormat(QtCore.Qt.AutoText)</span><br><span class="line">        self.state_label.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        self.state_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)</span><br><span class="line">        self.state_label.setObjectName(<span class="string">"state_label"</span>)</span><br><span class="line">        self.formLayout.setWidget(<span class="number">2</span>, QtWidgets.QFormLayout.SpanningRole, self.state_label)</span><br><span class="line">        self.verticalGroupBox = QtWidgets.QGroupBox(Form)</span><br><span class="line">        self.verticalGroupBox.setGeometry(QtCore.QRect(<span class="number">210</span>, <span class="number">20</span>, <span class="number">401</span>, <span class="number">241</span>))</span><br><span class="line">        self.verticalGroupBox.setObjectName(<span class="string">"verticalGroupBox"</span>)</span><br><span class="line">        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalGroupBox)</span><br><span class="line">        self.verticalLayout.setContentsMargins(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        self.verticalLayout.setObjectName(<span class="string">"verticalLayout"</span>)</span><br><span class="line">        self.s2__receive_text = QtWidgets.QTextBrowser(self.verticalGroupBox)</span><br><span class="line">        self.s2__receive_text.setObjectName(<span class="string">"s2__receive_text"</span>)</span><br><span class="line">        self.verticalLayout.addWidget(self.s2__receive_text)</span><br><span class="line">        self.verticalGroupBox_2 = QtWidgets.QGroupBox(Form)</span><br><span class="line">        self.verticalGroupBox_2.setGeometry(QtCore.QRect(<span class="number">210</span>, <span class="number">280</span>, <span class="number">401</span>, <span class="number">101</span>))</span><br><span class="line">        self.verticalGroupBox_2.setObjectName(<span class="string">"verticalGroupBox_2"</span>)</span><br><span class="line">        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalGroupBox_2)</span><br><span class="line">        self.verticalLayout_2.setContentsMargins(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        self.verticalLayout_2.setObjectName(<span class="string">"verticalLayout_2"</span>)</span><br><span class="line">        self.s3__send_text = QtWidgets.QTextEdit(self.verticalGroupBox_2)</span><br><span class="line">        self.s3__send_text.setObjectName(<span class="string">"s3__send_text"</span>)</span><br><span class="line">        self.verticalLayout_2.addWidget(self.s3__send_text)</span><br><span class="line">        self.s3__send_button = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.s3__send_button.setGeometry(QtCore.QRect(<span class="number">620</span>, <span class="number">310</span>, <span class="number">61</span>, <span class="number">31</span>))</span><br><span class="line">        self.s3__send_button.setObjectName(<span class="string">"s3__send_button"</span>)</span><br><span class="line">        self.s3__clear_button = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.s3__clear_button.setGeometry(QtCore.QRect(<span class="number">620</span>, <span class="number">350</span>, <span class="number">61</span>, <span class="number">31</span>))</span><br><span class="line">        self.s3__clear_button.setObjectName(<span class="string">"s3__clear_button"</span>)</span><br><span class="line">        self.formGroupBox1 = QtWidgets.QGroupBox(Form)</span><br><span class="line">        self.formGroupBox1.setGeometry(QtCore.QRect(<span class="number">20</span>, <span class="number">340</span>, <span class="number">171</span>, <span class="number">101</span>))</span><br><span class="line">        self.formGroupBox1.setObjectName(<span class="string">"formGroupBox1"</span>)</span><br><span class="line">        self.formLayout_2 = QtWidgets.QFormLayout(self.formGroupBox1)</span><br><span class="line">        self.formLayout_2.setContentsMargins(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        self.formLayout_2.setSpacing(<span class="number">10</span>)</span><br><span class="line">        self.formLayout_2.setObjectName(<span class="string">"formLayout_2"</span>)</span><br><span class="line">        self.label = QtWidgets.QLabel(self.formGroupBox1)</span><br><span class="line">        self.label.setObjectName(<span class="string">"label"</span>)</span><br><span class="line">        self.formLayout_2.setWidget(<span class="number">0</span>, QtWidgets.QFormLayout.LabelRole, self.label)</span><br><span class="line">        self.label_2 = QtWidgets.QLabel(self.formGroupBox1)</span><br><span class="line">        self.label_2.setObjectName(<span class="string">"label_2"</span>)</span><br><span class="line">        self.formLayout_2.setWidget(<span class="number">1</span>, QtWidgets.QFormLayout.LabelRole, self.label_2)</span><br><span class="line">        self.lineEdit = QtWidgets.QLineEdit(self.formGroupBox1)</span><br><span class="line">        self.lineEdit.setObjectName(<span class="string">"lineEdit"</span>)</span><br><span class="line">        self.formLayout_2.setWidget(<span class="number">0</span>, QtWidgets.QFormLayout.FieldRole, self.lineEdit)</span><br><span class="line">        self.lineEdit_2 = QtWidgets.QLineEdit(self.formGroupBox1)</span><br><span class="line">        self.lineEdit_2.setObjectName(<span class="string">"lineEdit_2"</span>)</span><br><span class="line">        self.formLayout_2.setWidget(<span class="number">1</span>, QtWidgets.QFormLayout.FieldRole, self.lineEdit_2)</span><br><span class="line">        self.hex_send = QtWidgets.QCheckBox(Form)</span><br><span class="line">        self.hex_send.setGeometry(QtCore.QRect(<span class="number">620</span>, <span class="number">280</span>, <span class="number">71</span>, <span class="number">16</span>))</span><br><span class="line">        self.hex_send.setObjectName(<span class="string">"hex_send"</span>)</span><br><span class="line">        self.hex_receive = QtWidgets.QCheckBox(Form)</span><br><span class="line">        self.hex_receive.setGeometry(QtCore.QRect(<span class="number">620</span>, <span class="number">40</span>, <span class="number">71</span>, <span class="number">16</span>))</span><br><span class="line">        self.hex_receive.setObjectName(<span class="string">"hex_receive"</span>)</span><br><span class="line">        self.s2__clear_button = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.s2__clear_button.setGeometry(QtCore.QRect(<span class="number">620</span>, <span class="number">80</span>, <span class="number">61</span>, <span class="number">31</span>))</span><br><span class="line">        self.s2__clear_button.setObjectName(<span class="string">"s2__clear_button"</span>)</span><br><span class="line">        self.timer_send_cb = QtWidgets.QCheckBox(Form)</span><br><span class="line">        self.timer_send_cb.setGeometry(QtCore.QRect(<span class="number">260</span>, <span class="number">390</span>, <span class="number">71</span>, <span class="number">16</span>))</span><br><span class="line">        self.timer_send_cb.setObjectName(<span class="string">"timer_send_cb"</span>)</span><br><span class="line">        self.lineEdit_3 = QtWidgets.QLineEdit(Form)</span><br><span class="line">        self.lineEdit_3.setGeometry(QtCore.QRect(<span class="number">350</span>, <span class="number">390</span>, <span class="number">61</span>, <span class="number">20</span>))</span><br><span class="line">        self.lineEdit_3.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)</span><br><span class="line">        self.lineEdit_3.setObjectName(<span class="string">"lineEdit_3"</span>)</span><br><span class="line">        self.dw = QtWidgets.QLabel(Form)</span><br><span class="line">        self.dw.setGeometry(QtCore.QRect(<span class="number">420</span>, <span class="number">390</span>, <span class="number">54</span>, <span class="number">20</span>))</span><br><span class="line">        self.dw.setObjectName(<span class="string">"dw"</span>)</span><br><span class="line">        self.line = QtWidgets.QFrame(Form)</span><br><span class="line">        self.line.setGeometry(QtCore.QRect(<span class="number">700</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">351</span>))</span><br><span class="line">        self.line.setFrameShape(QtWidgets.QFrame.VLine)</span><br><span class="line">        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)</span><br><span class="line">        self.line.setObjectName(<span class="string">"line"</span>)</span><br><span class="line">        self.s4__open1_button = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.s4__open1_button.setGeometry(QtCore.QRect(<span class="number">740</span>, <span class="number">160</span>, <span class="number">61</span>, <span class="number">31</span>))</span><br><span class="line">        self.s4__open1_button.setObjectName(<span class="string">"s4__open1_button"</span>)</span><br><span class="line">        self.s4__open2_button = QtWidgets.QPushButton(Form)</span><br><span class="line">        self.s4__open2_button.setGeometry(QtCore.QRect(<span class="number">740</span>, <span class="number">210</span>, <span class="number">61</span>, <span class="number">31</span>))</span><br><span class="line">        self.s4__open2_button.setObjectName(<span class="string">"s4__open2_button"</span>)</span><br><span class="line">        self.verticalGroupBox.raise_()</span><br><span class="line">        self.verticalGroupBox_2.raise_()</span><br><span class="line">        self.formGroupBox.raise_()</span><br><span class="line">        self.s3__send_button.raise_()</span><br><span class="line">        self.s3__clear_button.raise_()</span><br><span class="line">        self.formGroupBox.raise_()</span><br><span class="line">        self.hex_send.raise_()</span><br><span class="line">        self.hex_receive.raise_()</span><br><span class="line">        self.s2__clear_button.raise_()</span><br><span class="line">        self.timer_send_cb.raise_()</span><br><span class="line">        self.lineEdit_3.raise_()</span><br><span class="line">        self.dw.raise_()</span><br><span class="line">        self.line.raise_()</span><br><span class="line">        self.s4__open1_button.raise_()</span><br><span class="line">        self.s4__open2_button.raise_()</span><br><span class="line"></span><br><span class="line">        self.retranslateUi(Form)</span><br><span class="line">        QtCore.QMetaObject.connectSlotsByName(Form)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retranslateUi</span><span class="params">(self, Form)</span>:</span></span><br><span class="line">        _translate = QtCore.QCoreApplication.translate</span><br><span class="line">        Form.setWindowTitle(_translate(<span class="string">"Form"</span>, <span class="string">"Form"</span>))</span><br><span class="line">        self.formGroupBox.setTitle(_translate(<span class="string">"Form"</span>, <span class="string">"串口设置"</span>))</span><br><span class="line">        self.s1__lb_1.setText(_translate(<span class="string">"Form"</span>, <span class="string">"串口检测："</span>))</span><br><span class="line">        self.s1__box_1.setText(_translate(<span class="string">"Form"</span>, <span class="string">"检测串口"</span>))</span><br><span class="line">        self.s1__lb_2.setText(_translate(<span class="string">"Form"</span>, <span class="string">"串口选择："</span>))</span><br><span class="line">        self.s1__lb_3.setText(_translate(<span class="string">"Form"</span>, <span class="string">"波特率："</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">0</span>, _translate(<span class="string">"Form"</span>, <span class="string">"115200"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">1</span>, _translate(<span class="string">"Form"</span>, <span class="string">"2400"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">2</span>, _translate(<span class="string">"Form"</span>, <span class="string">"4800"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">3</span>, _translate(<span class="string">"Form"</span>, <span class="string">"9600"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">4</span>, _translate(<span class="string">"Form"</span>, <span class="string">"14400"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">5</span>, _translate(<span class="string">"Form"</span>, <span class="string">"19200"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">6</span>, _translate(<span class="string">"Form"</span>, <span class="string">"38400"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">7</span>, _translate(<span class="string">"Form"</span>, <span class="string">"57600"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">8</span>, _translate(<span class="string">"Form"</span>, <span class="string">"76800"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">9</span>, _translate(<span class="string">"Form"</span>, <span class="string">"12800"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">10</span>, _translate(<span class="string">"Form"</span>, <span class="string">"230400"</span>))</span><br><span class="line">        self.s1__box_3.setItemText(<span class="number">11</span>, _translate(<span class="string">"Form"</span>, <span class="string">"460800"</span>))</span><br><span class="line">        self.s1__lb_4.setText(_translate(<span class="string">"Form"</span>, <span class="string">"数据位："</span>))</span><br><span class="line">        self.s1__box_4.setItemText(<span class="number">0</span>, _translate(<span class="string">"Form"</span>, <span class="string">"8"</span>))</span><br><span class="line">        self.s1__box_4.setItemText(<span class="number">1</span>, _translate(<span class="string">"Form"</span>, <span class="string">"7"</span>))</span><br><span class="line">        self.s1__box_4.setItemText(<span class="number">2</span>, _translate(<span class="string">"Form"</span>, <span class="string">"6"</span>))</span><br><span class="line">        self.s1__box_4.setItemText(<span class="number">3</span>, _translate(<span class="string">"Form"</span>, <span class="string">"5"</span>))</span><br><span class="line">        self.s1__lb_5.setText(_translate(<span class="string">"Form"</span>, <span class="string">"校验位："</span>))</span><br><span class="line">        self.s1__box_5.setItemText(<span class="number">0</span>, _translate(<span class="string">"Form"</span>, <span class="string">"N"</span>))</span><br><span class="line">        self.open_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"打开串口"</span>))</span><br><span class="line">        self.close_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"关闭串口"</span>))</span><br><span class="line">        self.s1__lb_6.setText(_translate(<span class="string">"Form"</span>, <span class="string">"停止位："</span>))</span><br><span class="line">        self.s1__box_6.setItemText(<span class="number">0</span>, _translate(<span class="string">"Form"</span>, <span class="string">"1"</span>))</span><br><span class="line">        self.verticalGroupBox.setTitle(_translate(<span class="string">"Form"</span>, <span class="string">"接受区"</span>))</span><br><span class="line">        self.verticalGroupBox_2.setTitle(_translate(<span class="string">"Form"</span>, <span class="string">"发送区"</span>))</span><br><span class="line">        self.s3__send_text.setHtml(_translate(<span class="string">"Form"</span>, <span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\"&gt;\n"</span></span><br><span class="line"><span class="string">"&lt;html&gt;&lt;head&gt;&lt;meta name=\"qrichtext\" content=\"1\" /&gt;&lt;style type=\"text/css\"&gt;\n"</span></span><br><span class="line"><span class="string">"p, li &#123; white-space: pre-wrap; &#125;\n"</span></span><br><span class="line"><span class="string">"&lt;/style&gt;&lt;/head&gt;&lt;body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\"&gt;\n"</span></span><br><span class="line"><span class="string">"&lt;p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"&gt;123456&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>))</span><br><span class="line">        self.s3__send_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"发送"</span>))</span><br><span class="line">        self.s3__clear_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"清除"</span>))</span><br><span class="line">        self.formGroupBox1.setTitle(_translate(<span class="string">"Form"</span>, <span class="string">"串口状态"</span>))</span><br><span class="line">        self.label.setText(_translate(<span class="string">"Form"</span>, <span class="string">"已接收："</span>))</span><br><span class="line">        self.label_2.setText(_translate(<span class="string">"Form"</span>, <span class="string">"已发送："</span>))</span><br><span class="line">        self.hex_send.setText(_translate(<span class="string">"Form"</span>, <span class="string">"Hex发送"</span>))</span><br><span class="line">        self.hex_receive.setText(_translate(<span class="string">"Form"</span>, <span class="string">"Hex接收"</span>))</span><br><span class="line">        self.s2__clear_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"清除"</span>))</span><br><span class="line">        self.timer_send_cb.setText(_translate(<span class="string">"Form"</span>, <span class="string">"定时发送"</span>))</span><br><span class="line">        self.lineEdit_3.setText(_translate(<span class="string">"Form"</span>, <span class="string">"1000"</span>))</span><br><span class="line">        self.dw.setText(_translate(<span class="string">"Form"</span>, <span class="string">"ms/次"</span>))</span><br><span class="line">        self.s4__open1_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"打开1灯"</span>))</span><br><span class="line">        self.s4__open2_button.setText(_translate(<span class="string">"Form"</span>, <span class="string">"打开2灯"</span>))</span><br></pre></td></tr></table></figure><blockquote><p>ui_demo.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMessageBox</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QTimer</span><br><span class="line"><span class="keyword">from</span> ui_demo_1 <span class="keyword">import</span> Ui_Form</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pyqt5_Serial</span><span class="params">(QtWidgets.QWidget, Ui_Form)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Pyqt5_Serial, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.init()</span><br><span class="line">        self.setWindowTitle(<span class="string">"串口小助手"</span>)</span><br><span class="line">        self.ser = serial.Serial()</span><br><span class="line">        self.port_check()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收数据和发送数据数目置零</span></span><br><span class="line">        self.data_num_received = <span class="number">0</span></span><br><span class="line">        self.lineEdit.setText(str(self.data_num_received))</span><br><span class="line">        self.data_num_sended = <span class="number">0</span></span><br><span class="line">        self.lineEdit_2.setText(str(self.data_num_sended))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 串口检测按钮</span></span><br><span class="line">        self.s1__box_1.clicked.connect(self.port_check)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 串口信息显示</span></span><br><span class="line">        self.s1__box_2.currentTextChanged.connect(self.port_imf)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开串口按钮</span></span><br><span class="line">        self.open_button.clicked.connect(self.port_open)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭串口按钮</span></span><br><span class="line">        self.close_button.clicked.connect(self.port_close)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送数据按钮</span></span><br><span class="line">        self.s3__send_button.clicked.connect(self.data_send)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定时发送数据</span></span><br><span class="line">        self.timer_send = QTimer()</span><br><span class="line">        self.timer_send.timeout.connect(self.data_send)</span><br><span class="line">        self.timer_send_cb.stateChanged.connect(self.data_send_timer)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定时器接收数据</span></span><br><span class="line">        self.timer = QTimer(self)</span><br><span class="line">        self.timer.timeout.connect(self.data_receive)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清除发送窗口</span></span><br><span class="line">        self.s3__clear_button.clicked.connect(self.send_data_clear)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清除接收窗口</span></span><br><span class="line">        self.s2__clear_button.clicked.connect(self.receive_data_clear)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开1灯</span></span><br><span class="line">        self.s4__open1_button.clicked.connect(self.open_led1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开2灯</span></span><br><span class="line">        self.s4__open2_button.clicked.connect(self.open_led2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串口检测</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_check</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 检测所有存在的串口，将信息存储在字典中</span></span><br><span class="line">        self.Com_Dict = &#123;&#125;</span><br><span class="line">        port_list = list(serial.tools.list_ports.comports())</span><br><span class="line">        self.s1__box_2.clear()</span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> port_list:</span><br><span class="line">            self.Com_Dict[<span class="string">"%s"</span> % port[<span class="number">0</span>]] = <span class="string">"%s"</span> % port[<span class="number">1</span>]</span><br><span class="line">            self.s1__box_2.addItem(port[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(self.Com_Dict) == <span class="number">0</span>:</span><br><span class="line">            self.state_label.setText(<span class="string">" 无串口"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串口信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_imf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 显示选定的串口的详细信息</span></span><br><span class="line">        imf_s = self.s1__box_2.currentText()</span><br><span class="line">        <span class="keyword">if</span> imf_s != <span class="string">""</span>:</span><br><span class="line">            self.state_label.setText(self.Com_Dict[self.s1__box_2.currentText()])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开串口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_open</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ser.port = self.s1__box_2.currentText()</span><br><span class="line">        self.ser.baudrate = int(self.s1__box_3.currentText())</span><br><span class="line">        self.ser.bytesize = int(self.s1__box_4.currentText())</span><br><span class="line">        self.ser.stopbits = int(self.s1__box_6.currentText())</span><br><span class="line">        self.ser.parity = self.s1__box_5.currentText()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.ser.open()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            QMessageBox.critical(self, <span class="string">"Port Error"</span>, <span class="string">"此串口不能被打开！"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开串口接收定时器，周期为2ms</span></span><br><span class="line">        self.timer.start(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.ser.isOpen():</span><br><span class="line">            self.open_button.setEnabled(<span class="literal">False</span>)</span><br><span class="line">            self.close_button.setEnabled(<span class="literal">True</span>)</span><br><span class="line">            self.formGroupBox1.setTitle(<span class="string">"串口状态（已开启）"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭串口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer.stop()</span><br><span class="line">        self.timer_send.stop()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.ser.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        self.open_button.setEnabled(<span class="literal">True</span>)</span><br><span class="line">        self.close_button.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.lineEdit_3.setEnabled(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 接收数据和发送数据数目置零</span></span><br><span class="line">        self.data_num_received = <span class="number">0</span></span><br><span class="line">        self.lineEdit.setText(str(self.data_num_received))</span><br><span class="line">        self.data_num_sended = <span class="number">0</span></span><br><span class="line">        self.lineEdit_2.setText(str(self.data_num_sended))</span><br><span class="line">        self.formGroupBox1.setTitle(<span class="string">"串口状态（已关闭）"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_send</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.ser.isOpen():</span><br><span class="line">            input_s = self.s3__send_text.toPlainText()</span><br><span class="line">            <span class="keyword">if</span> input_s != <span class="string">""</span>:</span><br><span class="line">                <span class="comment"># 非空字符串</span></span><br><span class="line">                <span class="keyword">if</span> self.hex_send.isChecked():</span><br><span class="line">                    <span class="comment"># hex发送</span></span><br><span class="line">                    input_s = input_s.strip()</span><br><span class="line">                    send_list = []</span><br><span class="line">                    <span class="keyword">while</span> input_s != <span class="string">''</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            num = int(input_s[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">                        <span class="keyword">except</span> ValueError:</span><br><span class="line">                            QMessageBox.critical(self, <span class="string">'wrong data'</span>, <span class="string">'请输入十六进制数据，以空格分开!'</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                        input_s = input_s[<span class="number">2</span>:].strip()</span><br><span class="line">                        send_list.append(num)</span><br><span class="line">                    input_s = bytes(send_list)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># ascii发送</span></span><br><span class="line">                    input_s = (input_s + <span class="string">'\r\n'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">                num = self.ser.write(input_s)</span><br><span class="line">                self.data_num_sended += num</span><br><span class="line">                self.lineEdit_2.setText(str(self.data_num_sended))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_receive</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num = self.ser.inWaiting()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.port_close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            data = self.ser.read(num)</span><br><span class="line">            num = len(data)</span><br><span class="line">            <span class="comment"># hex显示</span></span><br><span class="line">            <span class="keyword">if</span> self.hex_receive.checkState():</span><br><span class="line">                out_s = <span class="string">''</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data)):</span><br><span class="line">                    out_s = out_s + <span class="string">'&#123;:02X&#125;'</span>.format(data[i]) + <span class="string">' '</span></span><br><span class="line">                self.s2__receive_text.insertPlainText(out_s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 串口接收到的字符串为b'123',要转化成unicode字符串才能输出到窗口中去</span></span><br><span class="line">                self.s2__receive_text.insertPlainText(data.decode(<span class="string">'iso-8859-1'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 统计接收字符的数量</span></span><br><span class="line">            self.data_num_received += num</span><br><span class="line">            self.lineEdit.setText(str(self.data_num_received))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取到text光标</span></span><br><span class="line">            textCursor = self.s2__receive_text.textCursor()</span><br><span class="line">            <span class="comment"># 滚动到底部</span></span><br><span class="line">            textCursor.movePosition(textCursor.End)</span><br><span class="line">            <span class="comment"># 设置光标到text中去</span></span><br><span class="line">            self.s2__receive_text.setTextCursor(textCursor)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定时发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_send_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.timer_send_cb.isChecked():</span><br><span class="line">            self.timer_send.start(int(self.lineEdit_3.text()))</span><br><span class="line">            self.lineEdit_3.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.timer_send.stop()</span><br><span class="line">            self.lineEdit_3.setEnabled(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除显示</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data_clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s3__send_text.setText(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_data_clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s2__receive_text.setText(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_led1</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        input_s = <span class="string">'1'</span></span><br><span class="line">        input_s = input_s.strip()</span><br><span class="line">        send_list = []</span><br><span class="line">        <span class="keyword">while</span> input_s != <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                num = int(input_s[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                QMessageBox.critical(self, <span class="string">'wrong data'</span>, <span class="string">'请输入十六进制数据，以空格分开!'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            input_s = input_s[<span class="number">2</span>:].strip()</span><br><span class="line">            send_list.append(num)</span><br><span class="line">        input_s = bytes(send_list)</span><br><span class="line"></span><br><span class="line">        num = self.ser.write(input_s)</span><br><span class="line">        self.data_num_sended += num</span><br><span class="line">        self.lineEdit_2.setText(str(self.data_num_sended))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_led2</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        input_s = <span class="string">'2'</span></span><br><span class="line">        input_s = input_s.strip()</span><br><span class="line">        send_list = []</span><br><span class="line">        <span class="keyword">while</span> input_s != <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                num = int(input_s[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                QMessageBox.critical(self, <span class="string">'wrong data'</span>, <span class="string">'请输入十六进制数据，以空格分开!'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            input_s = input_s[<span class="number">2</span>:].strip()</span><br><span class="line">            send_list.append(num)</span><br><span class="line">        input_s = bytes(send_list)</span><br><span class="line"></span><br><span class="line">        num = self.ser.write(input_s)</span><br><span class="line">        self.data_num_sended += num</span><br><span class="line">        self.lineEdit_2.setText(str(self.data_num_sended))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    myshow = Pyqt5_Serial()</span><br><span class="line">    myshow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><blockquote><p>CCS源代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DSP2833x_Device.h"</span>     <span class="comment">// DSP2833x 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DSP2833x_Examples.h"</span>   <span class="comment">// DSP2833x 例子相关头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************函数声明************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_echoback_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_xmit</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_msg</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="comment">/**********************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前，声明本文件中的相关函数；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configtestled</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************宏定义************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitDIR()                                          \</span></span><br><span class="line">                     EALLOW;                               \</span><br><span class="line">                     GpioCtrlRegs.GPBPUD.bit.GPIO49 = <span class="number">0</span>;   \</span><br><span class="line">                     GpioCtrlRegs.GPBDIR.bit.GPIO49 = <span class="number">1</span>;   \</span><br><span class="line">                     GpioDataRegs.GPBCLEAR.bit.GPIO49 = <span class="number">1</span>; \</span><br><span class="line">                     EDIS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RX_EN       GpioDataRegs.GPBCLEAR.bit.GPIO49 = 1;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TX_EN       GpioDataRegs.GPBSET.bit.GPIO49 = 1;</span></span><br><span class="line"><span class="comment">/**********************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Uint16 ReceivedChar;   <span class="comment">//变量定义</span></span><br><span class="line">    <span class="keyword">char</span> *msg;             <span class="comment">//指针</span></span><br><span class="line"><span class="comment">// 步骤 1. 初始化系统控制:</span></span><br><span class="line"><span class="comment">// 设置PLL, WatchDog, 使能外设时钟</span></span><br><span class="line"><span class="comment">// 下面这个函数可以从DSP2833x_SysCtrl.c文件中找到..</span></span><br><span class="line">   InitSysCtrl();</span><br><span class="line">   InitScibGpio();</span><br><span class="line"><span class="comment">// 步骤 2. 初始化通用输入输出多路复用器GPIO:</span></span><br><span class="line"><span class="comment">// 这个函数在DSP2833x_Gpio.c源文件中被定义了</span></span><br><span class="line"><span class="comment">// 这个函数使GPIO控制类寄存器初始化到默认状态</span></span><br><span class="line"><span class="comment">// InitGpio();  // 本例不用此子函数</span></span><br><span class="line">   InitDIR();</span><br><span class="line"><span class="comment">// 本例使用下面的GPIO配置</span></span><br><span class="line">   configtestled();</span><br><span class="line"><span class="comment">// 总线初始化函数</span></span><br><span class="line">   InitXintf16Gpio();<span class="comment">//zq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 3. 清除所有中断初始化中断向量表:</span></span><br><span class="line"><span class="comment">// 禁止CPU全局中断</span></span><br><span class="line">   DINT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化PIE控制寄存器到他们的默认状态.</span></span><br><span class="line"><span class="comment">// 这个默认状态就是禁止PIE中断及清除所有PIE中断标志</span></span><br><span class="line"><span class="comment">// 这个函数放在DSP2833x_PieCtrl.c源文件里</span></span><br><span class="line">   InitPieCtrl();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止CPU中断和清除所有CPU中断标志</span></span><br><span class="line">   IER = <span class="number">0x0000</span>;</span><br><span class="line">   IFR = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化PIE中断向量表，并使其指向中断服务子程序（ISR）</span></span><br><span class="line"><span class="comment">// 这些中断服务子程序被放在了DSP280x_DefaultIsr.c源文件中</span></span><br><span class="line"><span class="comment">// 这个函数放在了DSP2833x_PieVect.c源文件里面.</span></span><br><span class="line">   InitPieVectTable();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤 4. 初始化片内外设:</span></span><br><span class="line"><span class="comment">// 这个函数可以在DSP280x_CpuTimers.c源文件中找到</span></span><br><span class="line"><span class="comment">//   InitCpuTimers();   // 这个例子仅初始化了Cpu定时器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 5. 用户特定的代码</span></span><br><span class="line">   scib_echoback_init();</span><br><span class="line"></span><br><span class="line">   msg = <span class="string">"\r\n\nled control\0"</span>;  <span class="comment">//发送语句</span></span><br><span class="line">   scib_msg(msg);                    <span class="comment">//发送函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   msg = <span class="string">"\r\n \n\0"</span>;  <span class="comment">//发送语句</span></span><br><span class="line">   scib_msg(msg);                    <span class="comment">//发送函数</span></span><br><span class="line"></span><br><span class="line">  GpioDataRegs.GPASET.bit.GPIO1 = <span class="number">1</span>;</span><br><span class="line">  GpioDataRegs.GPASET.bit.GPIO2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">   &#123;</span><br><span class="line">      msg = <span class="string">"\r\n \0"</span>;  <span class="comment">//发送语句</span></span><br><span class="line">      scib_msg(msg);                      <span class="comment">//发送函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//等待接收到数据，否则在此循环</span></span><br><span class="line">      <span class="keyword">while</span>(ScibRegs.SCIRXST.bit.RXRDY !=<span class="number">1</span>) &#123; &#125; <span class="comment">// wait for XRDY =1 for empty state</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//把接收BUF里的数据赋值给ReceivedChar</span></span><br><span class="line">      ReceivedChar = ScibRegs.SCIRXBUF.all;</span><br><span class="line">      msg = <span class="string">"  led open \0"</span>;           <span class="comment">//发送语句</span></span><br><span class="line">      scib_msg(msg);                    <span class="comment">//发送函数</span></span><br><span class="line">      scib_xmit(ReceivedChar);          <span class="comment">//发送ReceivedChar</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(ScibRegs.SCIRXBUF.all == <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      GpioDataRegs.GPACLEAR.bit.GPIO1 = <span class="number">1</span>;</span><br><span class="line">      GpioDataRegs.GPASET.bit.GPIO2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      msg = <span class="string">"1"</span>;</span><br><span class="line">      scib_msg(msg);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ScibRegs.SCIRXBUF.all == <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    GpioDataRegs.GPACLEAR.bit.GPIO2 = <span class="number">1</span>;</span><br><span class="line">        GpioDataRegs.GPASET.bit.GPIO1 = <span class="number">1</span>;</span><br><span class="line">      msg = <span class="string">"2"</span>;</span><br><span class="line">      scib_msg(msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configtestled</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">//GPIO初始化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   EALLOW;</span><br><span class="line">   GpioCtrlRegs.GPAMUX1.bit.GPIO1 = <span class="number">0</span>; <span class="comment">// GPIO0复用为GPIO功能</span></span><br><span class="line">   GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="number">1</span>;  <span class="comment">// GPIO0设置为输出</span></span><br><span class="line">   GpioCtrlRegs.GPAMUX1.bit.GPIO2 = <span class="number">0</span>; <span class="comment">// GPIO1复用为GPIO功能</span></span><br><span class="line">   GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="number">1</span>;  <span class="comment">// GPIO1设置为输出</span></span><br><span class="line"></span><br><span class="line">   EDIS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_echoback_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note: Clocks were turned on to the SCIA peripheral</span></span><br><span class="line">    <span class="comment">// in the InitSysCtrl() function</span></span><br><span class="line"><span class="comment">//SCI的工作模式和参数需要用户在后面的学习中，深入的了解一个寄存器底层相关的资料了，多看看芯片手册和寄存器的意思。</span></span><br><span class="line">    <span class="comment">//因为28335的寄存器太多了，所以在以后的学习过程中，就不会对寄存器进行详细的注释了。</span></span><br><span class="line">    ScibRegs.SCICTL1.bit.SWRESET =<span class="number">0</span>;</span><br><span class="line"> ScibRegs.SCICCR.all =<span class="number">0x0007</span>;   <span class="comment">// 1 stop bit,  No loopback</span></span><br><span class="line">                                   <span class="comment">// No parity,8 char bits,</span></span><br><span class="line">                                   <span class="comment">// async mode, idle-line protocol</span></span><br><span class="line">ScibRegs.SCICTL1.all =<span class="number">0x0003</span>;  <span class="comment">// enable TX, RX, internal SCICLK,</span></span><br><span class="line">                                   <span class="comment">// Disable RX ERR, SLEEP, TXWAKE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (CPU_FRQ_150MHZ)</span></span><br><span class="line">      ScibRegs.SCIHBAUD    =<span class="number">0x0001</span>;  <span class="comment">// 9600 baud @LSPCLK = 37.5MHz.</span></span><br><span class="line">      ScibRegs.SCILBAUD    =<span class="number">0x00E7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (CPU_FRQ_100MHZ)</span></span><br><span class="line">          ScibRegs.SCIHBAUD    =<span class="number">0x0001</span>;  <span class="comment">// 9600 baud @LSPCLK = 20MHz.</span></span><br><span class="line">          ScibRegs.SCILBAUD    =<span class="number">0x0044</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ScibRegs.SCICTL1.all =<span class="number">0x0023</span>;  <span class="comment">// Relinquish SCI from Reset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Transmit a character from the SCI</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_xmit</span><span class="params">(<span class="keyword">int</span> a)</span>              <span class="comment">//发送字节的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ScibRegs.SCICTL2.bit.TXRDY == <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ScibRegs.SCITXBUF=a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scib_msg</span><span class="params">(<span class="keyword">char</span> * msg)</span>          <span class="comment">//发送数组的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">TX_EN;</span><br><span class="line">    <span class="keyword">while</span>(msg[i] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        scib_xmit(msg[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">RX_EN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===========================================================================</span></span><br><span class="line"><span class="comment">// No more.</span></span><br><span class="line"><span class="comment">//===========================================================================</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/ColinFred/Pyserial-Demo" target="_blank" rel="noopener">参考的串口程序</a></p><p>[2] 王硕,孙洋洋.PyQt5快速开发与实战[M].电子工业出版社:北京,2017</p>]]></content>
      
      
      
        <tags>
            
            <tag> 上位机 </tag>
            
            <tag> DSP开发板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP基础知识一览</title>
      <link href="/2019/08/10/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88/"/>
      <url>/2019/08/10/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="CCS编程基础"><a href="#CCS编程基础" class="headerlink" title="CCS编程基础"></a>CCS编程基础</h2><p>CCS开发环境已经为我们封装好了许多片内外设寄存器的结构体，我们只需要包含相应的官方的头文件就可以使用了，那么它的内部具体是如何实现的呢？</p><p>下面来一个典型的例子：</p><h3 id="1-使用结构体和联合体"><a href="#1-使用结构体和联合体" class="headerlink" title="1.使用结构体和联合体"></a>1.使用结构体和联合体</h3><p><strong>A.用struct定义位域的作用：在DSP2833x_Sci.h中有一段:</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">SCICCR_BITS</span> &#123;</span>        <span class="comment">// bit    description</span></span><br><span class="line">   Uint16 SCICHAR:<span class="number">3</span>;         <span class="comment">// 2:0    Character length control</span></span><br><span class="line">   Uint16 ADDRIDLE_MODE:<span class="number">1</span>;   <span class="comment">// 3      ADDR/IDLE Mode control</span></span><br><span class="line">   Uint16 LOOPBKENA:<span class="number">1</span>;       <span class="comment">// 4      Loop Back enable</span></span><br><span class="line">   Uint16 PARITYENA:<span class="number">1</span>;       <span class="comment">// 5      Parity enable</span></span><br><span class="line">   Uint16 PARITY:<span class="number">1</span>;          <span class="comment">// 6      Even or Odd Parity</span></span><br><span class="line">   Uint16 STOPBITS:<span class="number">1</span>;        <span class="comment">// 7      Number of Stop Bits</span></span><br><span class="line">   Uint16 rsvd1:<span class="number">8</span>;           <span class="comment">// 15:8   reserved 保留</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> SCICCR_REG &#123;</span><br><span class="line">   Uint16              all;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SCICCR_BITS</span>  <span class="title">bit</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Uint16 SCICHAR:3 表示定义SCICHAR，它占一个字节中的3位；<strong>*注意：必须以4字节对齐！观察上面的SCICCR_BITS的定义也会发现前面定义了3+1+1+1+1+1=8位=1字节</strong></p><p><strong>B.再来看union的作用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> SCICCR_REG&#123;</span><br><span class="line">      Uint16     all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">SCICCR_BITS</span> <span class="title">bit</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义有什么效果？<br>当我想操作SCICCR_BITS中的每一位时，只需定义union SCICCR_REG reg即可</p><p>我们可以整体操作，如：reg.all = 0x0011;</p><p>我们可以操作其中一位：reg.bit.PARITY = 0;</p><p>还记得c语言中union中的共享同一个内存空间地址么？</p><h3 id="2-使用cmd文件进行数据段与存储器空间映射"><a href="#2-使用cmd文件进行数据段与存储器空间映射" class="headerlink" title="2.使用cmd文件进行数据段与存储器空间映射"></a>2.使用cmd文件进行数据段与存储器空间映射</h3><p>既然官方已经帮我们做好了上面的一切，上面的东西肯定可以直接使用，那么为什么可以直接使用呢？</p><p>定义一个上面的变量就可以访问到真正硬件上的寄存器了吗？肯定不行！</p><p>我们需要将上面的变量和实际硬件的寄存器存储空间绑定，怎么绑定，通过cmd文件。</p><p>下面是官方DSP2833x_GlobalVariableDefs.c中的一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">"ScicRegsFile"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(ScicRegs,<span class="meta-string">"ScicRegsFile"</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">SCI_REGS</span> <span class="title">ScicRegs</span>;</span></span><br></pre></td></tr></table></figure><p>官方定义了ScicRegs来操作串口SCI-C的相关的寄存器，但是肯定没法直接使用，还没有做绑定；</p><p>使用#pragma DATA_SECTION可以将变量与数据段绑定，变量和数据段是自己定义的，只需要将他们绑定即可；</p><p>这样绑定显然还不行，还需要通过cmd文件数据段映射到硬件的寄存器地址空间中去！</p><p>查看DSP2833x_Headers_nonBIOS.cmd文件我们发现其中有这样几行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line"> PAGE <span class="number">0</span>:    <span class="comment">/* Program Memory */</span></span><br><span class="line"> </span><br><span class="line"> PAGE <span class="number">1</span>:    <span class="comment">/* Data Memory */</span> </span><br><span class="line">   </span><br><span class="line">   ADC         : origin = <span class="number">0x007100</span>, length = <span class="number">0x000020</span>     <span class="comment">/* ADC registers */</span></span><br><span class="line">   SCIB        : origin = <span class="number">0x007750</span>, length = <span class="number">0x000010</span>     <span class="comment">/* SCI-B registers */</span></span><br><span class="line">   SCIC        : origin = <span class="number">0x007770</span>, length = <span class="number">0x000010</span>     <span class="comment">/* SCI-C registers */</span>   </span><br><span class="line">   I2CA        : origin = <span class="number">0x007900</span>, length = <span class="number">0x000040</span>     <span class="comment">/* I2C-A registers */</span> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   AdcRegsFile       : &gt; ADC,         PAGE = <span class="number">1</span></span><br><span class="line">   ScibRegsFile      : &gt; SCIB,        PAGE = <span class="number">1</span></span><br><span class="line">   ScicRegsFile      : &gt; SCIC,        PAGE = <span class="number">1</span></span><br><span class="line">   I2caRegsFile      : &gt; I2CA,        PAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MEMORY代表内存空间，PAGE0是程序空间， PAGE1是数据空间；</p><p>(还记得第一课的介绍么？28335采样的哈佛总线结构，程序与数据分开了~)</p><p>SECTIONS代表需要映射的段；</p><p>通过上面的映射后，操作ScicRegs就可以实际操作串口了，目的也就达到了；</p><hr><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>TMS320F28335上有一个基于PLL电路的片上时钟模块，如图1所示，为CPU及外设提供时钟有两种方式：</p><blockquote><p>一种是用外部的时钟源，将其连接到X1引脚上或者XCLKIN引脚上，X2接地；<br>另一种是使用振荡器产生时钟，用30MHz的晶体和两个20PF的电容组成的电路分别连接到X1和X2引脚上，XCLKIN引脚接地。</p></blockquote><p>我们常用第二种来产生时钟。此时钟将通过一个内部PLL锁相环电路，进行倍频。由于F28335的最大工作频率是150M，所以倍频值最大是5。其中倍频值由PLLCR的低四位和PLLSTS的第7、8位来决定。其详细的倍频值可以参照TMS320F28335的Datasheet。</p><p><img src="https://s2.ax1x.com/2019/08/10/eXpGTJ.png" alt="eXpGTJ.png"></p><p>三种时钟输入的接法:</p><p><img src="https://s2.ax1x.com/2019/08/10/eXpr0e.png" alt="eXpr0e.png"></p><p>如果我们希望DSP工作在某一个频率下，我们就可以对Uint16 val, Uint16 divsel两个参数进行设定。说白了就相当于乘10，除2 (30*10/2 = 150MHZ)</p><hr><h2 id="GPIO引脚"><a href="#GPIO引脚" class="headerlink" title="GPIO引脚"></a>GPIO引脚</h2><p><strong>GPIO（General-Purpose Input/Output）——通用输入/输出口</strong></p><p>DSP28335 GPIO模块分为三类IO口：PORTA(0-31),PORTB(32-63),PORTC(64-87) 对GPIO模块的设置主要通过三类寄存器来完成，分别是：控制寄存器、数据寄存器、中断寄存器。</p><p><strong>1、控制寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  GPxCTRL;    <span class="comment">// GPIO x Control Register (GPIO0 to 31)</span></span><br><span class="line">              <span class="comment">//设置采样窗周期T=2*GPXCTRL*Tsysclk；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxQSEL1;   <span class="comment">// GPIO x Qualifier Select 1 Register (GPIO0 to 15)(32-47)            </span></span><br><span class="line">  GPxQSEL2;   <span class="comment">// GPIO x Qualifier Select 2 Register (GPIO16 to 31)(48-63)</span></span><br><span class="line">              <span class="comment">//每两位控制一个引脚，确定是3周期采样还是6周期采样或者不用采样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxMUX1;    <span class="comment">// GPIO x Mux 1 Register (GPIO0 to 15)(32-47)(64-79)</span></span><br><span class="line"></span><br><span class="line">  GPxMUX2;    <span class="comment">// GPIO x Mux 2 Register (GPIO16 to 31)(48-63)(80-95)</span></span><br><span class="line">              <span class="comment">//配置各个引脚的功能，0：I/O功能，1：外设功能。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  GPxDIR;     <span class="comment">// GPIO x Direction Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">              <span class="comment">//配置每个引脚是输入还是输出，0：数字量输入；1：数字量输出。</span></span><br><span class="line">  GPxPUD;     <span class="comment">// GPIO x Pull Up Disable Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">              <span class="comment">//使能或禁止内部上拉 0：开启上拉，1：禁止上拉</span></span><br></pre></td></tr></table></figure><p><strong>2、数据寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  GPxDAT;     <span class="comment">// GPIO Data Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line">  GPxSET;     <span class="comment">// GPIO Data Set Register (GPIO0 to 31)(32-63)(64-95)——置位</span></span><br><span class="line"></span><br><span class="line">  GPxCLEAR;   <span class="comment">// GPIO Data Clear Register (GPIO0 to 31)(32-63)(64-95)</span></span><br><span class="line"></span><br><span class="line">  GPxTOGGLE;  <span class="comment">// GPIO Data Toggle Register (GPIO0 to 31)(32-63)(64-95)—反转</span></span><br></pre></td></tr></table></figure><p><strong>3、中断寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   GPIOXINT1SEL; <span class="comment">// XINT1 GPIO Input Selection</span></span><br><span class="line">   GPIOXINT2SEL; <span class="comment">// XINT2 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXNMISEL;  <span class="comment">// XNMI_Xint13 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT3SEL; <span class="comment">// XINT3 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT4SEL; <span class="comment">// XINT4 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT5SEL; <span class="comment">// XINT5 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT6SEL; <span class="comment">// XINT6 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOXINT7SEL; <span class="comment">// XINT7 GPIO Input Selection</span></span><br><span class="line"></span><br><span class="line">   GPIOLPMSEL;   <span class="comment">// Low power modes GP I/O input select</span></span><br></pre></td></tr></table></figure><blockquote><p>可以对GPIO0-63进行外部中断设置；</p></blockquote><p>具体定义在DSP28335Gpio.h中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_CTRL_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPACTRL_REG  GPACTRL;   <span class="comment">// GPIO A Control Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA1_REG     GPAQSEL1;  <span class="comment">// GPIO A Qualifier Select 1 Register (GPIO0 to 15)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA2_REG     GPAQSEL2;  <span class="comment">// GPIO A Qualifier Select 2 Register (GPIO16 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA1_REG     GPAMUX1;   <span class="comment">// GPIO A Mux 1 Register (GPIO0 to 15)</span></span><br><span class="line">   <span class="keyword">union</span>  GPA2_REG     GPAMUX2;   <span class="comment">// GPIO A Mux 2 Register (GPIO16 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG   GPADIR;    <span class="comment">// GPIO A Direction Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG   GPAPUD;    <span class="comment">// GPIO A Pull Up Disable Register (GPIO0 to 31)</span></span><br><span class="line">   Uint32              rsvd1;</span><br><span class="line">   <span class="keyword">union</span>  GPBCTRL_REG  GPBCTRL;   <span class="comment">// GPIO B Control Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB1_REG     GPBQSEL1;  <span class="comment">// GPIO B Qualifier Select 1 Register (GPIO32 to 47)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB2_REG     GPBQSEL2;  <span class="comment">// GPIO B Qualifier Select 2 Register (GPIO48 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB1_REG     GPBMUX1;   <span class="comment">// GPIO B Mux 1 Register (GPIO32 to 47)</span></span><br><span class="line">   <span class="keyword">union</span>  GPB2_REG     GPBMUX2;   <span class="comment">// GPIO B Mux 2 Register (GPIO48 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG   GPBDIR;    <span class="comment">// GPIO B Direction Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG   GPBPUD;    <span class="comment">// GPIO B Pull Up Disable Register (GPIO32 to 63)</span></span><br><span class="line">   Uint16              rsvd2[<span class="number">8</span>];</span><br><span class="line">   <span class="keyword">union</span>  GPC1_REG     GPCMUX1;   <span class="comment">// GPIO C Mux 1 Register (GPIO64 to 79)</span></span><br><span class="line">   <span class="keyword">union</span>  GPC2_REG     GPCMUX2;   <span class="comment">// GPIO C Mux 2 Register (GPIO80 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG   GPCDIR;    <span class="comment">// GPIO C Direction Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG   GPCPUD;    <span class="comment">// GPIO C Pull Up Disable Register (GPIO64 to 95)</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_DATA_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPADAT;       <span class="comment">// GPIO Data Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPASET;       <span class="comment">// GPIO Data Set Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPACLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO0 to 31)</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPATOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO0 to 31) </span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBDAT;       <span class="comment">// GPIO Data Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBSET;       <span class="comment">// GPIO Data Set Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBCLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPBDAT_REG       GPBTOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO32 to 63)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCDAT;       <span class="comment">// GPIO Data Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCSET;       <span class="comment">// GPIO Data Set Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCCLEAR;     <span class="comment">// GPIO Data Clear Register (GPIO64 to 95)</span></span><br><span class="line">   <span class="keyword">union</span>  GPCDAT_REG       GPCTOGGLE;    <span class="comment">// GPIO Data Toggle Register (GPIO64 to 95)</span></span><br><span class="line">   Uint16                  rsvd1[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_INT_REGS</span> &#123;</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT1SEL; <span class="comment">// XINT1 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT2SEL; <span class="comment">// XINT2 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXNMISEL;  <span class="comment">// XNMI_Xint13 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT3SEL; <span class="comment">// XINT3 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT4SEL; <span class="comment">// XINT4 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT5SEL; <span class="comment">// XINT5 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT6SEL; <span class="comment">// XINT6 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPIOXINT_REG     GPIOXINT7SEL; <span class="comment">// XINT7 GPIO Input Selection</span></span><br><span class="line">   <span class="keyword">union</span>  GPADAT_REG       GPIOLPMSEL;   <span class="comment">// Low power modes GP I/O input select</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：GPIO相关寄存器介绍</strong></p><blockquote><p>1、GPxMUX寄存器（功能选择寄存器）</p><p>每个I/O口都有一个功能选择寄存器，功能选择寄存器主要用于选择I/O工作在特殊功能还是通用数组I/O模式。在复位时，所有GPIO配置成通用数字模式。</p><p>1）如果GPxMUX.bit = 0，配置成通用数字I/O功能；</p><p>2）如果GPxMUX.bit = 1   2  3，配置成特殊外设功能口（如SCI、CAN）；</p><p>I/O的输入功能和外设的输入通道总是被使能的，输出通道是通用数组I/O和特殊外设复用的。如果引脚配置成通用数组I/O功能，相应的外设功能将被禁止。</p><p>2、GPxDIR（方向控制寄存器）</p><p>每个I/O口都有数据方向控制寄存器，数据方向控制寄存器用于设置通用数字I/O为输入还是输出口，在复位时，引脚的默认状态为输入状态。</p><p>1）如果GPxDIR.bit = 0，引脚设置为通用数字量输入；</p><p>2）如果GPxDIR.bit = 1，引脚设置为通用数字量输出；</p><p>复位时，GPxMUX和GPxDIR默认值都为0，所以在复位时，引脚的默认状态为数字I/O输入。</p><p>3、GPxDAT寄存器（数据寄存器）</p><p>每个I/O口都有一个数据寄存器，数据寄存器是可读可写寄存器。</p><p>1）I/O设置为输出功能时，如果GPxDAT.bit = 0，那么操作将会使相应的引脚拉低；</p><p>2）I/O口设置为输入功能时，如果GPxDAT.bit = 0，反映相应的引脚状态为低电平；</p><p>3）I/O口设置为输出功能时，如果GPxDAT.bit = 1，那么操作将会使相应的引脚拉高；</p><p>4）I/O口设置为输入功能时，如果GPxDAT.bit = 1，反映相应的引脚状态为高电平。</p><p>需要说明的是，当用户试图改变一个数字I/O的状态时，不要改变另一个I/O的引脚状态。</p><p>4、GOxSET寄存器（置位寄存器）</p><p>每个I/O口都有一个置位寄存器，置位寄存器是只写寄存器，任何读操作都返回0，如果相应的引脚配置成数据量输出，写1后相应的引脚会置高，写0时没有反映。</p><p> 1）如果GPxSET.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxSET.bit = 1，那么操作将会使引脚置高。</p><p>5、GPxCLEAR寄存器（清除寄存器）</p><p>每个I/O口都有一个清除寄存器，清除寄存器是只写寄存器，任何读操作都返回0。</p><p>1）如果GPxCLEAR.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxCLEAR.bit = 1，将相应的引脚置成低电平。</p><p>6、GPxTOGGLE寄存器（取反触发寄存器）</p><p>每个I/O口都有一个取反触发寄存器，该寄存器是只写寄存器，任何读操作都返回0。</p><p>1）如果GPxTOGGLE.bit = 0，没有影响；</p><p>2）引脚设置为输出时，如果GPxTOGGLE.bit = 1，那么操作将使相应的引脚取反。</p></blockquote><hr><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>1.中断系统</strong></p><p>   在这里我们要十分清楚DSP的中断系统。C28XX一共有16个中断源，其中有2个不可屏蔽的中断RESET和NMI、定时器1和定时器2分别使用中断13和14。这样还有12个中断都直接连接到外设中断扩展模块PIE上。说的简单一点就是PIE通过12根线与28335核的12个中断线相连。而PIE的另外一侧有12*8根线分别连接到外设，如AD、SPI、EXINT等等。</p><p>   PIE共管理12*8=96个外部中断。这12组大中断由28335核的中断寄存器IER来控制，即IER确定每个中断到底属于哪一组大中断（如IER |= M_INT12; 说明我们要用第12组的中断，但是第12组里面的什么中断CPU并不知道需要再由PIEIER确定）。</p><p>   接下来再由PIE模块中的寄存器PIEIER中的低8确定该中断是这一组的第几个中断，这些配置都要告诉CPU（我们不难想象到PIEIER共有12总即从PIEIER1-PIEIER12）。另外，PIE模块还有中断标志寄存器PIEIFR，同样它的低8位是来自外部中断的8个标志位，同样CPU的IFR寄存器是中断组的标志寄存器。由此看来，CPU的所有中断寄存器控制12组的中断，PIE的所有中断寄存器控制每组内8个的中断。除此之外，我们用到哪一个外部中断，相应的还有外部中断的寄存器，需要注意的就是<strong>外部中断的标志要自己通过软件来清零</strong>。而<strong>PIE和CPU的中断标志寄存器由硬件来清零。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EALLOW;  <span class="comment">// This is needed to write to EALLOW protected registers </span></span><br><span class="line">PieVectTable.XINT2 = &amp;ISRExint;          <span class="comment">//告诉中断入口地址</span></span><br><span class="line">EDIS;    <span class="comment">// This is needed to disable write to EALLOW protected registers</span></span><br><span class="line">PieCtrlRegs.PIECTRL.bit.ENPIE = <span class="number">1</span>;       <span class="comment">// Enable the PIE block使能PIE</span></span><br><span class="line">PieCtrlRegs.PIEIER1.bit.INTx5= <span class="number">1</span>;        <span class="comment">//使能第一组中的中断5</span></span><br><span class="line">IER |= M_INT1;                           <span class="comment">// Enable CPU 第一组中断</span></span><br><span class="line">EINT;                                    <span class="comment">// Enable Global interrupt INTM</span></span><br><span class="line">ERTM;                                    <span class="comment">// Enable Global realtime interrupt DBGM</span></span><br></pre></td></tr></table></figure><p>也就是说，12组中的每个中断都要完成上面的相同配置，剩下的才是去配置自己的中断。如我们提到的EXINT，即外面来个低电平我们就进入中断，完成我们的程序。在这里要介绍一下，DSP的GPIO口都可以配置为外部中断口，其配置方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO54 = <span class="number">0</span>; <span class="comment">//选择他们是GPIO口</span></span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO55 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO56 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX2.bit.GPIO57 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO54 = <span class="number">0</span>;<span class="comment">//选择他们都是输入口</span></span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO55 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO56 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBDIR.bit.GPIO57 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO54= <span class="number">0</span>;<span class="comment">//使GPIO时钟和系统时钟一样 且支持GPIO</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO55= <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO56= <span class="number">0</span>;<span class="comment">//配置输入口权限，对于选择为输入口的需配置GPACTRL,GPBCTRL,GPAQSEL1</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL2.bit.GPIO57= <span class="number">0</span>;<span class="comment">//GPAQSEL2, GPBQSEL1, and GPBQSEL2寄存器所有输入信号与CPU输出系统时钟同步；</span></span><br><span class="line"> </span><br><span class="line">GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = <span class="number">54</span>;<span class="comment">//中断3选择GPIO</span></span><br><span class="line">GpioIntRegs.GPIOXINT4SEL.bit.GPIOSEL = <span class="number">55</span>;</span><br><span class="line">GpioIntRegs.GPIOXINT5SEL.bit.GPIOSEL = <span class="number">56</span>;</span><br><span class="line">GpioIntRegs.GPIOXINT6SEL.bit.GPIOSEL = <span class="number">57</span>; </span><br><span class="line"> </span><br><span class="line">XIntruptRegs.XINT3CR.bit.POLARITY= <span class="number">0</span>;<span class="comment">//触发模式为下降沿触发</span></span><br><span class="line">XIntruptRegs.XINT4CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line">XIntruptRegs.XINT5CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line">XIntruptRegs.XINT6CR.bit.POLARITY= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">XIntruptRegs.XINT3CR.bit.ENABLE = <span class="number">1</span>;<span class="comment">//使能中断</span></span><br><span class="line">XIntruptRegs.XINT4CR.bit.ENABLE = <span class="number">1</span>;</span><br><span class="line">XIntruptRegs.XINT5CR.bit.ENABLE = <span class="number">1</span>;</span><br><span class="line">XIntruptRegs.XINT6CR.bit.ENABLE = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意一点就是外部中断1和2只能对GPIO0—GPIO31配置；外部中断3和4、5、6、7只对GPIO32—GPIO63配置。</p><p>GPIO分为A(0-31)、B(32-63)、C(64-87);C组的不能配置为外部中断；</p><p><strong>2.如何开启某个中断？</strong></p><p>设置中断向量。例如：<code>PieVectTable.ADCINT = &amp;adc_isr;</code>等<br>打开PIE控制器。<code>PieCtrlRegs.PIECTRL.bit.ENPIE = 1;</code><br>使能PIE中对应外设的中断（相应group的相应pin）。例如：<code>PieCtrlRegs.PIEIER1.bit.INTx8 = 1; PieCtrlRegs.PIEIER1.bit.INTx6 = 1;</code>等<br>使能CPU的相应中断<code>（INT1~INT12）IER |= M_INT1;</code><br>使能CPU响应中断EINT、ERTM;;</p><p><strong>3.中断标志有几级？作用是什么？</strong></p><p>中断标志主要有三级CPU（有16个标志位）、PIE（有12组每组有12个标志位）和外设（有的外设没有）。</p><p>标志位在中断发生后锁存中断状态，即表示中断发生。在CPU响应中断后，会自动清除cpu级别的标志位IFR bit，同时将INTM bit 置位，以防止其它中断的发生；</p><p>CPU在从PIE中取中断向量时PIE会自动清除PIE级别的标志位PIEIFRx.y。所以在进入中断处理程序后除了外设所有中断位都已经清除。</p><p>而中断处理程序中需要清除PIEACKx和外设的中断标志位（如果有的话）。</p><p>在CPU响应一个中断后，在进入ISR的时候，默认会关断全局中断，即在执行中断服务程序时，不会有其他中断来打断CPU，包括本次的中断事件。另外，如果外设的中断标志位不清除，不会循环进入这个中断服务函数，这个外设中断被阻断了。所以只有清除外设的中断服务程序，才能响应下一次的外设中断。PIEACK同理，如果没有PIEACK，这组所有中断都被阻断。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://www.ti.com/lit/ds/symlink/tms320f28335.pdf" target="_blank" rel="noopener">TMS320F2833x Datasheet</a></p><p>[2] <a href="https://blog.csdn.net/scottly1" target="_blank" rel="noopener">风雨也无晴 CSDN</a></p><p>[3] <a href="http://blog.sina.com.cn/s/blog_a7c071b30102wp2c.html" target="_blank" rel="noopener">GPIO blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP28335 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP 串口接口及通信通信</title>
      <link href="/2019/08/09/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/08/09/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="对串口通信进行简单知识点梳理"><a href="#对串口通信进行简单知识点梳理" class="headerlink" title="对串口通信进行简单知识点梳理"></a>对串口通信进行简单知识点梳理</h2><p>串行通信可以分为两大类：</p><p>同步通信：典型 I2C,SPI</p><p>异步通信：典型 SCI(serial communication interface,串行通信接口)</p><blockquote><p>进行串口异步通信接口，一般可以看作UART口(Universal Asynchronous Receiver Transmitter：通用异步收发器/异步串行通信口)</p></blockquote><blockquote><p>UART、COM指物理接口形式(硬件), TTL、RS232、RS485 指电平标准(电信号)</p></blockquote><hr><h2 id="SCI-串口"><a href="#SCI-串口" class="headerlink" title="SCI 串口"></a>SCI 串口</h2><p>先来补充一个概念:FIFO（First Input First Output），即先进先出队列。</p><h3 id="SCI模块介绍"><a href="#SCI模块介绍" class="headerlink" title="SCI模块介绍"></a>SCI模块介绍</h3><p>TMS320F28335内部有三个SCI模块，SCIA、SCIB、SCIC。</p><p>每一个SCI模块都有一个接收器和发送器，SCI的接收器和发送器各有一个16级的FIFO(First In First Out先入先出)队列，它们都还有自己独立的使能位和中断位；可以工作在半双工或全双工模式。</p><p><strong>1. SCI的CPU 接口</strong><br>SCI 模块具有两个引脚， SCITXDA 和 SCIRXDA，分别实现发送数据和接收数据的功能，这两个引脚对应于 GPIOF 模块的第4和第5位，在编程初始化的时候，需要将GPIOFMUX 寄存器的第4和第5位置为1，才能使得这两个引脚具有发送和接收的功能，否则就是普通的I/O引脚。外部晶振通 PLL 模块产生了CPU 的系统时钟SYSCLKOUT，然后SYSCLKOUT经过低速预定标器之后输出低速时钟LSPCLK 供给SCI。要保证SCI的正常运行，系统控制模块下必须使能SCI的时钟，也就是在系统初始化函数中需要将外设时钟控制寄存器PCLKCR的SCIAENCLK位置1。从下图，我们可以清楚的看到SCIA可以产生两个中断，SCIRXINTA 和SCITXINTA，即发送中断和接收中断。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOLCtK.png" alt="eOLCtK.png"></p><p><strong>2. SCI相关寄存器</strong></p><p>SCICR：SCI通信参数设置寄存器，设置数据位，停止位，奇偶校验位。</p><p>SCICTL1：使能SCI的发送接收功能 <strong>注：SW RESET需置1</strong></p><p>SCILBAUD、SCIHBAUD：通信速率（波特率）的设置。</p><p>SCICTL2：使能接收发送中断，以及发送中断标志位。</p><p>SCIRXST：接收相关标志位。</p><p>SCIRXBUF：8位发送缓存寄存器</p><p>SCITXBUF：8位接收缓存寄存器。</p><p>SCI中断配置：</p><p>SCI的中断采用三级中断管理。分别是SCI外设中断，PIE中断，CPU中断。SCIA的PIE中断是第九组，分别是INT９.１和INT９.２.PIE中断的配置在前面已经说过了，此处不多说。<strong>注意：在中断不要忘记将PIEACK写１清除。</strong></p><p>SCI的FIFO模式：</p><p>FIFO：先入先出队列。SCI采用这种模式时，接收或者发送完指定字节数量的数据后，才进入中断处理。这样可以节省了CPU的使用效率，CPU不用每次接收完一个字节的数据后就进入中断处理。</p><p>相关寄存器：</p><p>SCIFFTX：配置发送的数据量，使能SCI的FIFO模式，使能中断等</p><p>SCIFFRX：配置接收的数据量，使能接收中断等。</p><p>在学习FIFO模式时，遇到一个问题，就是接收完指定数量字节的数据后，总是重复进入两次发送中断，一次找不到原因。下面贴出代码，希望各位读者不吝赐教。</p><p><strong>3. SCI 模块发送和接收数据的工作原理</strong></p><p>SCI 模块的工作原理如下图所示，之所以SCI 能工作于全双工模式，是因为它有独立的数据发送器和数据接收器，这样能够保证SCI既能够同时进行，也能够独立进行发送和接收的操作。</p><p>SCI 发送数据的过程如下：如下图右半部分所示， 在FIFO功能使能的情况下， 首先，发送数据缓冲寄存器SCITXBUF从TX FIFO 中获取由 CPU 加载的需要发送的数据，然后 SCITXBUF将数据传输给发送移位寄存器TXSHF， 如果SCI的发送功能使能， TXSHF 则将接收到的数据逐位逐位的移到 SCITXD 引脚上。</p><p>SCI接收数据的过程如下：如X下图的左半部分所示，首先，接收移位寄存器 RXSHF 逐位逐位的接收来自于 SCIRXD 引脚的数据， 如果 SCI 的接收功能使能， RXSHF 将这些数据传输给接收缓冲寄存器 SCIRXBUF，CPU 就能从 SCIRXBUF 读取外部发送来的数据。当然，如果 FIFO 功能使能的话， SCIRXBUF 会将数据加载到RX FIFO 的队列中， CPU 再从FIFO 的队列读取数据。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOL09U.png" alt="eOL09U.png"></p><p><strong>4. SCI数据格式</strong></p><p>在 SCI 中，通信协议体现在 SCI 的数据格式上。 通常将 SCI 的数据格式称之为可编程的数据格式，原因就是可以通过 SCI 的通信控制寄存器 SCICCR 来进行设置，规定通信过程中所使用的数据格式。 </p><p>在<strong>空闲线模式</strong>下， SCI 发送或者接收一帧的数据格式如图 4 所示，其中 LSB 是数据的最低位， MSB 是数据的最高位。</p><p><img src="https://s2.ax1x.com/2019/08/10/eOOCbn.png" alt="eOOCbn.png"></p><blockquote><p>使用 SCICCR 进行数据格式编程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SciaRegs.SCICCR.bit.SCICHAR=<span class="number">8</span>;</span><br><span class="line"><span class="comment">//选择数据长度，为 8 个数据位</span></span><br><span class="line">SciaRegs.SCICCR.bit.PARITYENA=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//开启极性功能，值为 0 的时候取消极性功能</span></span><br><span class="line">SciaRegs.SCICCR.bit.PARITY=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//在开启极性功能的前提下，该位值为 0 时选择偶极性，值为 1 时选择奇极性</span></span><br><span class="line">SciaRegs.SCICCR.bit.STOPBITS=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//选择停止位，该位为 0 时有 1 个停止位，该位为 1 时有 2 个停止位</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，上述这几个语句，我们也可以合并成如下的语句：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SciaRegs.SCICCR.all=<span class="number">0x13</span>;</span><br></pre></td></tr></table></figure><p><strong>5. SCI通信波特率</strong></p><p>所谓的波特率就是指每秒所能发送的位数。<br>SCI波特率设置寄存器SCIHBAUD和SCILBAUD，0-15是高字节与低字节连在一起，构成16位波特率设置寄存器BRR。BRR = SCIHBAUD + SCILBAUD</p><p>如果1&lt;= BRR &lt;=65535，那么SCI波特率=LSPCLK / ( (BRR+1) * 8 )，由此，可以带入你需要的波特率，既可以得到BRR的值；<br>如果BRR = 0，那么SCI波特率=LSPCLK/ 16</p><p> 我们举例来进行说明。例如外部晶振位 30M，经过 PLL 之后 SYSCLKOUT 为 150MHz，然后，当低速预定标器 LOSPCP 的值为 2 的时候， SYSCLKOUT 经过低速预定标器之后产生&gt;低速外设时钟 LSPCLK 为 37.5MHz，也就是说 SCI 的时钟为 37.5MHz。如果我们需要 SCI 的波特率为 19200，则将 LSPCLK 和波特率的数值代入式 1，便可得到BRR=243.14，由于寄存器都是正整数，所以省略掉小数后可以得到 BRR=243。将 243 转换成 16 进制是 0xF3，因此 SCIHBAUD 的值为 0， SCIHBAUD 的值为 0XF3。由于省略了小数，将会产生 0.06%的误差。 当 LSPCLK 为 37.5M 时，对于 SCI 常见的波特率，其寄存器的值如下表所示：</p><p><img src="https://s2.ax1x.com/2019/08/10/eOXO1S.png" alt="eOXO1S.png"></p><p><strong>6. 串口SCI编程</strong></p><p><strong>A.</strong></p><blockquote><p>先初始化IO管脚 (以SCI-A为例，SCI-B、SCI-C的初始化方法一样，就是照着改对应的管脚就行)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSciaGpio</span><span class="params">()</span> <span class="comment">//初始化SCIA的GPIO管脚为例子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EALLOW;</span><br><span class="line"><span class="comment">//根据硬件设计决定采用GPIO28/29和GPIO35/36中的哪一组。这里以35/36为例</span></span><br><span class="line"><span class="comment">//定义管脚为上拉</span></span><br><span class="line">GpioCtrlRegs.GPBPUD.bit.GPIO36 = <span class="number">0</span>;</span><br><span class="line">GpioCtrlRegs.GPBPUD.bit.GPIO35 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义管脚为异步输入</span></span><br><span class="line">GpioCtrlRegs.GPBQSEL1.bit.GPIO36 = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//配置管脚为SCI功能管脚</span></span><br><span class="line">GpioCtrlRegs.GPBMUX1.bit.GPIO36 = <span class="number">1</span>;</span><br><span class="line">GpioCtrlRegs.GPBMUX1.bit.GPIO35 = <span class="number">1</span>;</span><br><span class="line">EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B.</strong></p><blockquote><p>SCI初始化配置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scia_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SciaRegs.SCICCR.all =<span class="number">0x0007</span>; <span class="comment">// 1 stop bit, No loopback</span></span><br><span class="line"><span class="comment">// No parity,8 char bits,</span></span><br><span class="line"><span class="comment">// async mode, idle-line protocol</span></span><br><span class="line">SciaRegs.SCICTL1.all =<span class="number">0x0003</span>; <span class="comment">// enable TX, RX, internal SCICLK,</span></span><br><span class="line"><span class="comment">// Disable RX ERR, SLEEP, TXWAKE</span></span><br><span class="line">SciaRegs.SCICTL2.bit.TXINTENA =<span class="number">1</span>; <span class="comment">//发送中断使能</span></span><br><span class="line">SciaRegs.SCICTL2.bit.RXBKINTENA =<span class="number">1</span>;<span class="comment">//接收中断使能</span></span><br><span class="line">SciaRegs.SCIHBAUD =<span class="number">0x0001</span>; <span class="comment">// 9600 baud @LSPCLK = 37.5MHz.</span></span><br><span class="line">SciaRegs.SCILBAUD =<span class="number">0x00E7</span>;</span><br><span class="line">SciaRegs.SCICTL1.all =<span class="number">0x0023</span>; <span class="comment">// Relinquish SCI from Reset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C.</strong></p><blockquote><p>接着进行中断的配置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EALLOW; <span class="comment">// This is needed to write to EALLOW protected registers</span></span><br><span class="line">PieVectTable.SCIRXINTA = &amp;sciaRxIsr;</span><br><span class="line">PieVectTable.SCITXINTA = &amp;sciaTxIsr;</span><br><span class="line">PieVectTable.SCIRXINTB = &amp;scibRxIsr;</span><br><span class="line">PieVectTable.SCITXINTB = &amp;scibTxIsr;</span><br><span class="line">EDIS; <span class="comment">// This is needed to disable write to EALLOW protected registers</span></span><br></pre></td></tr></table></figure><p><strong>D.</strong></p><blockquote><p>上面是将SCIA和SCIB的中断服务程序连到PIE的中断表中，发生中断就会跑到你的ISR去了，下面是开中断：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PieCtrlRegs.PIECTRL.bit.ENPIE = <span class="number">1</span>; <span class="comment">// Enable the PIE block</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx1=<span class="number">1</span>; <span class="comment">// PIE Group 9, int1</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx2=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT2</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx3=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT3</span></span><br><span class="line">PieCtrlRegs.PIEIER9.bit.INTx4=<span class="number">1</span>; <span class="comment">// PIE Group 9, INT4</span></span><br><span class="line">IER = <span class="number">0x100</span>; <span class="comment">// Enable CPU INT</span></span><br><span class="line">EINT;</span><br></pre></td></tr></table></figure><p>这样串口基本就OK了。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/forever5325/p/9590141.html" target="_blank" rel="noopener">接口及协议总结</a><br>[2] <a href="https://blog.csdn.net/LSG_Down/article/details/80898638" target="_blank" rel="noopener">SCI通信</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 上位机 </tag>
            
            <tag> DSP28335 </tag>
            
            <tag> 串口通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP电机平台上位机编写(Python+pyqt)</title>
      <link href="/2019/08/06/DSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
      <url>/2019/08/06/DSP%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><strong>准备给DSP电机平台增加一个电机转速调节的上位机。</strong></p><blockquote><p><strong>目的：</strong></p><p>1.学习python，并利用它做点东西</p><p>2.对串口通信有更加深刻的了解</p></blockquote><blockquote><p><strong>计划步骤：</strong></p><p>1.先把Python的基础知识有大体了解</p><p>2.学习pyqt并绘制上位机界面</p><p>3.做好串口通信的工作</p></blockquote><h1 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h1><p>环境搭建参考： <a href="http://www.roselady.vip/a/cangjingge/boke/2018/0227/691.html" target="_blank" rel="noopener">环境搭建</a></p><p>再由.ui转成.py时，再最后添加：<a href="https://jingyan.baidu.com/article/656db918264acbe380249c50.html" target="_blank" rel="noopener">参考</a></p><p>Ui_MainWindow 要和前面类名一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span><span class="params">(QtWidgets.QMainWindow, Ui_MainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyWindow, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    mywindow = MyWindow()</span><br><span class="line">    mywindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h1 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h1><hr><p>未完待续~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> 上位机 </tag>
            
            <tag> Python </tag>
            
            <tag> pyqt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性负载-肖曦</title>
      <link href="/2019/08/05/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E8%82%96%E6%9B%A6/"/>
      <url>/2019/08/05/%E6%9F%94%E6%80%A7%E8%B4%9F%E8%BD%BD-%E8%82%96%E6%9B%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="关于肖老师柔性负载的文献综述"><a href="#关于肖老师柔性负载的文献综述" class="headerlink" title="关于肖老师柔性负载的文献综述"></a><center>关于肖老师柔性负载的文献综述</center></h2><h3 id="一、柔性负载建模–中心刚体-悬臂梁系统-欧拉-伯努利梁-5"><a href="#一、柔性负载建模–中心刚体-悬臂梁系统-欧拉-伯努利梁-5" class="headerlink" title="一、柔性负载建模–中心刚体-悬臂梁系统(欧拉-伯努利梁)[5]"></a>一、柔性负载建模–中心刚体-悬臂梁系统(欧拉-伯努利梁)<sup>[5]</sup></h3><p>应用于 工业机器人中的柔性机械臂。单柔性连杆伺服驱动系统如下图所示。图中：u(x,t)为挠性负载在x处的挠度；θm(t)为伺服电机转轴的转角；Ta为伺服电机驱动转矩。</p><img src="https://s2.ax1x.com/2019/08/05/eRZ4G4.png" width="400" height="200" alt="图片名称" align="center"><hr><h3 id="二、PMSM驱动柔性负载相关公式：-2"><a href="#二、PMSM驱动柔性负载相关公式：-2" class="headerlink" title="二、PMSM驱动柔性负载相关公式：[2]"></a>二、PMSM驱动柔性负载相关公式：<sup>[2]</sup></h3><p>在对柔性负载建模后，</p><blockquote><p>该系统的传递函数如下:(Ta表示电磁转矩，参数Ω 表示系统谐振频率， 而 Fa 则可以表示每一阶模态频率的谐振程度，通过系统模型和参数可以很容易地观察系统谐振状况。)(一般选取一阶模态，即Fa，Ω均为标量)</p><img src="https://s2.ax1x.com/2019/08/05/eRuIk6.png" width="300" height="80" alt="图片名称" align="center"></blockquote><blockquote><p>转速环和电流环传递函数</p><img src="https://s2.ax1x.com/2019/08/06/eh7EY8.png" width="380" height="230" alt="图片名称" align="center"><img src="https://s2.ax1x.com/2019/08/20/mYwrBd.png" width height="60" alt="图片名称" align="center"></blockquote><blockquote><p>系统控制框图</p><p><img src="https://s2.ax1x.com/2019/08/06/eh7VfS.png" alt="eh7VfS.png"></p></blockquote><h4 id="1-电流环特征–柔性负载影响小"><a href="#1-电流环特征–柔性负载影响小" class="headerlink" title="(1)电流环特征–柔性负载影响小"></a>(1)电流环特征–柔性负载影响小</h4><blockquote><p>刚性电流环开环传递函数</p><img src="https://s2.ax1x.com/2019/08/13/mC5YtI.png" width="380" height="120" alt="图片名称" align="center"></blockquote><p>与上面的 柔性负载 电流环传递函数相比，其差别主要在分母的第三项。故可以对其分母第三项单独分析。</p><p>但是，由于柔性负载的振动频率与电流环带宽差别较大，因而，柔性对 PMSM 电流环的<u>影响较小</u>.</p><h4 id="2-转速环环特征–柔性负载影响大"><a href="#2-转速环环特征–柔性负载影响大" class="headerlink" title="(2)转速环环特征–柔性负载影响大"></a>(2)转速环环特征–柔性负载<u>影响大</u></h4><blockquote><p>刚性负载 转速外环控制框图</p><img src="https://s2.ax1x.com/2019/08/13/mCO7UU.png" width="300" height="100" alt="图片名称" align="center"></blockquote><blockquote><p>柔性负载 转速外环控制框图（在不考虑电流环影响下，由系统框体可得）</p><img src="https://s2.ax1x.com/2019/08/13/mCOyE8.png" width="500" height="100" alt="图片名称" align="center"></blockquote><blockquote><p>转速环开环伯德图</p><img src="https://s2.ax1x.com/2019/08/13/mCOzb6.png" width="450" height="250" alt="图片名称" align="center"></blockquote><p>结论：</p><ol><li><p>在 PMSM 直接驱动柔性负载系统中，负载柔性对系统电流环影响较小，<strong>对转速环影响较大</strong>。</p></li><li><p>需要在 柔性负载振荡频率处 进行<strong>谐振补偿</strong></p></li></ol><hr><h3 id="三、柔性负载常用控制方法"><a href="#三、柔性负载常用控制方法" class="headerlink" title="三、柔性负载常用控制方法"></a>三、柔性负载常用控制方法</h3><p><img src="https://s2.ax1x.com/2019/08/21/mUXidS.png" alt="mUXidS.png"></p><h4 id="转速环设计"><a href="#转速环设计" class="headerlink" title="转速环设计"></a>转速环设计</h4><h4 id="1-PI设计-3"><a href="#1-PI设计-3" class="headerlink" title="(1)PI设计[3]"></a>(1)PI设计<sup>[3]</sup></h4><blockquote><p>转速环的开环传递函数(II型系统) （系统谐振模态幅值 η ）</p><img src="https://s2.ax1x.com/2019/08/15/mVpHYj.png" width="500" height="250" alt="图片名称" align="center"></blockquote><p>在不考虑电流内环的影响，采用PI调节器 。转速外环的控制框图如下</p><img src="https://s2.ax1x.com/2019/08/13/mCXxzj.png" width="400" height="80" alt="图片名称" align="center"><h4 id="2-状态反馈-PI-调节器控制-4"><a href="#2-状态反馈-PI-调节器控制-4" class="headerlink" title="(2)状态反馈 + PI 调节器控制[4]"></a>(2)状态反馈 + PI 调节器控制<sup>[4]</sup></h4><p> 在PI调节器的基础上，估计系统谐振模态幅值 η 和 负载转矩 T<sub>L</sub></p><img src="https://s2.ax1x.com/2019/08/15/mV9Ijx.png" width="500" height="250" alt="图片名称" align="center"><p>其中 G<sub>FF</sub>(s)是W<sub>m</sub>与 T<sub>L</sub> 解耦得到</p><p>并存在 k<sub>1</sub>、k<sub>2</sub>、k<sub>P</sub>、k<sub>I</sub> 四个可调参数，因而四个极点能够任意配置.</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]丁有爽,肖曦.基于负载位置反馈的永磁同步电机驱动柔性负载谐振抑制方法[J].电工技术学报,2017,32(11):96-110.</p><p>[2]丁有爽,肖曦.永磁同步电机直接驱动柔性负载控制方法[J].电工技术学报,2017,32(04):123-132.</p><p>[3]丁有爽,肖曦.基于极点配置的永磁同步电机驱动柔性负载PI调节器参数确定方法[J].中国电机工程学报,2017,37(04):1225-1239.</p><p>[4]丁有爽,肖曦.基于状态反馈和转矩补偿的永磁同步电机驱动柔性负载控制方法[J].中国电机工程学报,2017,37(13):3892-3900.</p><p>[5]丁有爽,肖曦.伺服系统柔性负载建模方法研究[J].中国电机工程学报,2016,36(03):818-827.</p><p>[6] Hori Y，Sawada H，Chun Y．Slow resonance ratio control for vibration suppression and disturbance rejection in torsional system[J]．IEEE Transactions on Industrial Electronics，1999，46(1)：162-168 </p>]]></content>
      
      
      
        <tags>
            
            <tag> PMSM </tag>
            
            <tag> 柔性负载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于加入站内搜索</title>
      <link href="/2019/08/02/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/2019/08/02/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>今天按照网上的加入本站搜索功能 无论如何都加不进去，后来在查看 NEXT给的官方解读中看到解决方法<br>网址如下，查看Local Search方法</p><blockquote><p><a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/search-services</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于DSP平台双UDE 参数调试</title>
      <link href="/2019/08/02/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95/"/>
      <url>/2019/08/02/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E5%8F%8CUDE%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>1.挑选了几组典型数据画图，这里面的滤波器参数都是随意设置的（因为现在还无法确定kp和alpha之间的关系）</strong></p></li><li><p><strong>2.xx_xxx3.fig 中红色为实际数值 蓝色为指令，绿色为经过滤波器的输出结果(画图程序在最后)。</strong></p></li></ul><ul><li><p><strong>3.图中的时间 10000点 = 5s</strong></p></li><li><p><strong>4.Main_twoloop190801.c为源程序。</strong></p></li><li><p><strong>5.文件夹中</strong></p><p>  01-07为电流环调试过程,<br>  08-11为速度环调试过程,<br>  12 给了一个比较极端的速度环滤波器参数。</p></li></ul><blockquote><p>数据对应参数：</p></blockquote><table><thead><tr><th align="center"></th><th align="center">spd_Factor</th><th align="center">spd_kp</th><th align="center">spd_ki</th><th align="center">iq_Factor</th><th align="center">iq_kp</th><th align="center">iq_ki</th></tr></thead><tbody><tr><td align="center">01参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">1.0</td><td align="center">0.0025</td></tr><tr><td align="center">05参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.1</td><td align="center">0.0025</td></tr><tr><td align="center">06参数</td><td align="center">0.1667</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr><tr><td align="center">10参数</td><td align="center">0.1667</td><td align="center">3.0</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr><tr><td align="center">12参数</td><td align="center">0.0007</td><td align="center">0.8</td><td align="center">0.0015</td><td align="center">0.007</td><td align="center">2.5</td><td align="center">0.0025</td></tr></tbody></table><ul><li><p><strong>6.画图函数</strong></p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,spd,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,spdr<span class="number">-5</span>,<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,spdc<span class="number">-5</span>,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line">grid on</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,iq,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,iqr,<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,iqc,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,<span class="number">1</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> PMSM </tag>
            
            <tag> UDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不懂的知识点 查阅 汇总</title>
      <link href="/2019/08/01/%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/08/01/%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="单工、半双工和全双工的区别"><a href="#单工、半双工和全双工的区别" class="headerlink" title="单工、半双工和全双工的区别"></a>单工、半双工和全双工的区别</h2><ul><li>一、单工<br>1、数据只在一个方向上传输，不能实现双方通信。</li></ul><p>2、栗子：电视、广播。</p><ul><li>二、半双工<br>1、允许数据在两个方向上传输，但是同一时间数据只能在一个方向上传输，其实际上是切换的单工。</li></ul><p>2、栗子：对讲机。</p><ul><li>三、全双工<br>1、允许数据在两个方向上同时传输。</li></ul><p>2、栗子：手机通话。</p><hr><h2 id="TCP-IP-（传输控制协议）Transmission-Control-Protocol"><a href="#TCP-IP-（传输控制协议）Transmission-Control-Protocol" class="headerlink" title="TCP/IP （传输控制协议）Transmission Control Protocol"></a>TCP/IP （传输控制协议）Transmission Control Protocol</h2><ul><li><p>TCP 用于应用程序之间的通信。<br>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p></li><li><p>IP 用于计算机之间的通信。<br>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p></li><li><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。<br>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。<br>IP 负责计算机之间的通信。<br>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。<br>IP 负责将包发送至接受者。</p></li></ul><hr><h2 id="api-（应用程序编程接口）"><a href="#api-（应用程序编程接口）" class="headerlink" title="api （应用程序编程接口）"></a>api （应用程序编程接口）</h2><p>API 是一套明确定义的各种软件组件之间的通信方法。</p><hr><h3 id="http、MQTT、CoAP"><a href="#http、MQTT、CoAP" class="headerlink" title="http、MQTT、CoAP"></a>http、MQTT、CoAP</h3><p>HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。<strong>支持长连接！适用于抄表</strong></p><blockquote><p><img src="https://s2.ax1x.com/2019/08/03/eDkio6.png" alt="eDkio6.png"></p></blockquote><p>CoAP 由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。 IETF的CoRE工作组提出了一种基于REST架构的CoAP协议;是一种在物联网世界的类web协议。<strong>不支持长连接 基于UDO 可靠性不高 适用于智能家居</strong></p><p><img src="https://s2.ax1x.com/2019/08/03/eDk8fS.png" alt="eDk8fS.png"></p><hr><h2 id="OSI七层模型-TCP-IP五层模型："><a href="#OSI七层模型-TCP-IP五层模型：" class="headerlink" title="OSI七层模型/TCP/IP五层模型："></a>OSI七层模型/TCP/IP五层模型：</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>(整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。)</p><ul><li>&lt;1&gt;    应用层</li></ul><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p><blockquote><p>实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询&gt; 价单，等等。</p></blockquote><ul><li>&lt;2&gt;表示层</li></ul><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><blockquote><p>由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p></blockquote><ul><li>&lt;3&gt;会话</li></ul><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><blockquote><p>会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p></blockquote><ul><li>&lt;4&gt;传输层</li></ul><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的， <strong>TCP UDP</strong> 就是在这一层。端口号既是这里的“端”。</p><blockquote><p>传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p></blockquote><ul><li>&lt;5&gt;网络层</li></ul><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p><blockquote><p>网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p></blockquote><ul><li>&lt;6&gt;数据链路层 </li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p><blockquote><p>这个没找到合适的例子</p></blockquote><ul><li>&lt;7&gt; 物理层  </li></ul><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><blockquote><p>快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p></blockquote><p>[<img src="https://s2.ax1x.com/2019/08/02/e0sspV.png" alt="e0sspV.png"></p><hr><h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><p> TCP/IP五层协议和OSI的七层协议对应关系如下。 在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。<br><img src="https://s2.ax1x.com/2019/08/02/e0sHXD.png" alt="e0sHXD.png"><br> 在每一层实现的协议也各不同，即每一层的服务也不同。下图列出了每层主要的协议。<br><img src="https://s2.ax1x.com/2019/08/02/e0sqne.png" alt="e0sqne.png"></p><hr><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p>  鉴权（authentication）是指验证用户是否拥有访问系统的权利。</p><hr><h2 id="CIG、IOCM、DM-Server、Mongo-DB"><a href="#CIG、IOCM、DM-Server、Mongo-DB" class="headerlink" title="CIG、IOCM、DM Server、Mongo DB"></a>CIG、IOCM、DM Server、Mongo DB</h2><p>CIG (Cell Interconnection Gateway) 信元互连网关</p><hr><h2 id="color-red-未完待续"><a href="#color-red-未完待续" class="headerlink" title="$\color{red}{未完待续~~}$"></a><strong>$\color{red}{未完待续~~}$</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交流电机前言讲座考试总结</title>
      <link href="/2019/07/29/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/29/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>简单的做一下知识点梳理。</p><h1 id="电机的控制问题"><a href="#电机的控制问题" class="headerlink" title="电机的控制问题"></a>电机的控制问题</h1><p><img src="https://s2.ax1x.com/2019/07/27/eMwp1H.png" alt="eMwp1H.png"></p><h1 id="交流电机"><a href="#交流电机" class="headerlink" title="交流电机"></a>交流电机</h1><p><img src="https://s2.ax1x.com/2019/07/27/eMdBtS.png" alt="eMdBtS.png"></p><h1 id="同步电机"><a href="#同步电机" class="headerlink" title="同步电机"></a>同步电机</h1><p><a href="https://imgchr.com/i/e881Jg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/29/e881Jg.png" alt="e881Jg.png"></a></p><h1 id="附赠：电机的应用"><a href="#附赠：电机的应用" class="headerlink" title="附赠：电机的应用"></a>附赠：电机的应用</h1><p><img src="https://s2.ax1x.com/2019/07/28/e1kE8g.jpg" alt="e1kE8g.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kmKs.jpg" alt="e1kmKs.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kV2Q.jpg" alt="e1kV2Q.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1knrn.jpg" alt="e1knrn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kZvj.jpg" alt="e1kZvj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kubq.jpg" alt="e1kubq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kMV0.jpg" alt="e1kMV0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kQaV.jpg" alt="e1kQaV.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kl5T.jpg" alt="e1kl5T.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k3PU.jpg" alt="e1k3PU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k8GF.jpg" alt="e1k8GF.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kG24.jpg" alt="e1kG24.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kJxJ.jpg" alt="e1kJxJ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ktM9.jpg" alt="e1ktM9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kNrR.jpg" alt="e1kNrR.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kUq1.jpg" alt="e1kUq1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kdVx.jpg" alt="e1kdVx.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kwa6.jpg" alt="e1kwa6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k0IK.jpg" alt="e1k0IK.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kDPO.jpg" alt="e1kDPO.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1krGD.jpg" alt="e1krGD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ksRe.jpg" alt="e1ksRe.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kyxH.jpg" alt="e1kyxH.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kcMd.jpg" alt="e1kcMd.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kgsA.jpg" alt="e1kgsA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k2qI.jpg" alt="e1k2qI.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kWZt.jpg" alt="e1kWZt.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kfdP.jpg" alt="e1kfdP.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1khIf.jpg" alt="e1khIf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1k5i8.jpg" alt="e1k5i8.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kIJS.jpg" alt="e1kIJS.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1koRg.jpg" alt="e1koRg.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kTzQ.jpg" alt="e1kTzQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kHMj.jpg" alt="e1kHMj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kbss.jpg" alt="e1kbss.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kqLn.jpg" alt="e1kqLn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kOZq.jpg" alt="e1kOZq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kXd0.jpg" alt="e1kXd0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kxiT.jpg" alt="e1kxiT.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1kzJU.jpg" alt="e1kzJU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Apz4.jpg" alt="e1Apz4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ACQJ.jpg" alt="e1ACQJ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1APy9.jpg" alt="e1APy9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ake1.jpg" alt="e1Ake1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AEo6.jpg" alt="e1AEo6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AmWD.jpg" alt="e1AmWD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AKQH.jpg" alt="e1AKQH.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AQOA.jpg" alt="e1AQOA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A1eI.jpg" alt="e1A1eI.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AJFf.jpg" alt="e1AJFf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AUSg.jpg" alt="e1AUSg.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AalQ.jpg" alt="e1AalQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AwOs.jpg" alt="e1AwOs.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ABmn.jpg" alt="e1ABmn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ADwq.jpg" alt="e1ADwq.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ArT0.jpg" alt="e1ArT0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A6YT.jpg" alt="e1A6YT.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AcfU.jpg" alt="e1AcfU.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A2pF.jpg" alt="e1A2pF.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ARl4.jpg" alt="e1ARl4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AW6J.jpg" alt="e1AW6J.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AfX9.jpg" alt="e1AfX9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A4mR.jpg" alt="e1A4mR.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A501.jpg" alt="e1A501.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AITx.jpg" alt="e1AITx.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ATk6.jpg" alt="e1ATk6.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1A7tK.jpg" alt="e1A7tK.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AHfO.jpg" alt="e1AHfO.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AqpD.jpg" alt="e1AqpD.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AL1e.jpg" alt="e1AL1e.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AO6H.jpg" alt="e1AO6H.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AXXd.jpg" alt="e1AXXd.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1AvnA.jpg" alt="e1AvnA.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Az7t.jpg" alt="e1Az7t.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EpAP.jpg" alt="e1EpAP.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1E9tf.jpg" alt="e1E9tf.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1ECh8.jpg" alt="e1ECh8.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ei9S.jpg" alt="e1Ei9S.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EF1g.jpg" alt="e1EF1g.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EkcQ.jpg" alt="e1EkcQ.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EAXj.jpg" alt="e1EAXj.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EVns.jpg" alt="e1EVns.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EZBn.jpg" alt="e1EZBn.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1Ee7q.jpg" alt="e1Ee7q.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EnA0.jpg" alt="e1EnA0.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EuNV.jpg" alt="e1EuNV.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EQ9U.jpg" alt="e1EQ9U.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1E1c4.jpg" alt="e1E1c4.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EGu9.jpg" alt="e1EGu9.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EYH1.jpg" alt="e1EYH1.jpg"><br><img src="https://s2.ax1x.com/2019/07/28/e1EUN6.jpg" alt="e1EUN6.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PMSM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于404问题及感谢</title>
      <link href="/2019/07/24/%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2/"/>
      <url>/2019/07/24/%E5%85%B3%E4%BA%8E404%E9%97%AE%E9%A2%98%E5%8F%8A%E6%84%9F%E8%B0%A2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>CNAME里面是写xxx.github.io</p></li><li><p>解析域名的时候最好用CNAME并 解析到 xxx.github.io</p></li><li><p>GitHub 仓库里的Setting 最好也改成<a href="http://www.xxx.xxx" target="_blank" rel="noopener">www.xxx.xxx</a></p></li></ol><p><strong>顺便感谢一下搭建博客参考网站</strong></p><p><a href="https://www.bilibili.com/video/av44544186" title="CodeSheep" target="_blank" rel="noopener">UP：CodeSheep</a></p><p><a href="https://www.bilibili.com/video/av23913382" title="吃饱睡觉的猫" target="_blank" rel="noopener">UP：吃饱睡觉的猫</a></p><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial" title="遇见西门" target="_blank" rel="noopener"> 遇见西门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于dsp平台电流环解耦</title>
      <link href="/2019/07/23/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6/"/>
      <url>/2019/07/23/%E5%85%B3%E4%BA%8EDSP%E5%B9%B3%E5%8F%B0%E7%94%B5%E6%B5%81%E7%8E%AF%E8%A7%A3%E8%80%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>120V电压 400rpm的给定电流</strong></p><p>应该加的补偿值</p><p>​<br><code>ttt = 0.00105 \* \_IQmpy(pi_id.Fbk,pi_spd.Fbk) \* 4500 \* 9 /(volt1.DcBusVolt\*409.9) + 0.065 \* pi_spd.Fbk \* 4500 /(volt1.DcBusVolt\*409.9);</code></p><p>下面是解耦后应该的公式.</p><p>​<code>ipark1.Qs = pi_iq.Out + ttt;​</code></p><p>在未解耦的时候，测得ipark1.Qs = 0.515 . 换算成真实的电压值为(乘当前的电流值) 0.515 * 120 V=61.8V</p><p>测得ttt = 0.22 . 换算成真实的电压值为26.4V.</p><p>ttt的主要成份是反电势 ​<code>flux\*we=0.1552\*400\*4\*3.14/30=26.0V​</code></p><p>所以证明电流环解耦 程序是正确的.</p><p><img src="https://s2.ax1x.com/2019/07/24/eAzypd.png" alt="解耦前后对比"></p><p>实验结果 （右为解耦）</p>]]></content>
      
      
      
        <tags>
            
            <tag> DSP平台 </tag>
            
            <tag> PMSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first generage blog</title>
      <link href="/2019/07/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>第一个博客 杠杠滴</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
