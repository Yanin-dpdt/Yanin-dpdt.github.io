<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/faviconY.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="推荐系统基础推荐系统简介推荐的概念 信息过滤系统 解决 信息过载 用户需求不明确的问题 利用一定的规则将物品排序 展示给需求不明确的用户   推荐 搜索区别 推荐个性化较强，用户被动的接受，希望能够提供持续的服务 搜索个性化弱，用户主动搜索，快速满足用户的需求   推荐和 web项目区别 构建稳定的信息流通通道 推荐 信息过滤系统 web 对结果有明确预期 推荐 结果是概率问题    Lambda">
<meta name="keywords" content="python,spark">
<meta property="og:type" content="article">
<meta property="og:title" content="推荐系统知识学习">
<meta property="og:url" content="http://yoursite.com/2020/03/16/头条推荐系统/index.html">
<meta property="og:site_name" content="颜">
<meta property="og:description" content="推荐系统基础推荐系统简介推荐的概念 信息过滤系统 解决 信息过载 用户需求不明确的问题 利用一定的规则将物品排序 展示给需求不明确的用户   推荐 搜索区别 推荐个性化较强，用户被动的接受，希望能够提供持续的服务 搜索个性化弱，用户主动搜索，快速满足用户的需求   推荐和 web项目区别 构建稳定的信息流通通道 推荐 信息过滤系统 web 对结果有明确预期 推荐 结果是概率问题    Lambda">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/18/8DnuIf.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/18/8DlFu4.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/18/8D1mZj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/8cChRJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/8cPgOI.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/8cijKA.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/8cFpUf.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/8cFi8g.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/19/8r3IJI.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/19/8r3xFs.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/828fEV.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/823Ofg.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/20/828fEV.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/21/8R24bt.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/21/8R2T58.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/22/84zHbj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qBJOS.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qBwYn.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qBrlV.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qBfYR.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qB5Sx.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qD5Nj.png">
<meta property="og:image" content="http://yoursite.com/img/LFM%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/24/8qDWDS.png">
<meta property="og:updated_time" content="2020-03-24T08:03:00.483Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="推荐系统知识学习">
<meta name="twitter:description" content="推荐系统基础推荐系统简介推荐的概念 信息过滤系统 解决 信息过载 用户需求不明确的问题 利用一定的规则将物品排序 展示给需求不明确的用户   推荐 搜索区别 推荐个性化较强，用户被动的接受，希望能够提供持续的服务 搜索个性化弱，用户主动搜索，快速满足用户的需求   推荐和 web项目区别 构建稳定的信息流通通道 推荐 信息过滤系统 web 对结果有明确预期 推荐 结果是概率问题    Lambda">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/03/18/8DnuIf.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2020/03/16/头条推荐系统/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>推荐系统知识学习 | 颜</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">颜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">控制、PMSM、Python、...</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/头条推荐系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shiwei-Yan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="颜">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">推荐系统知识学习

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-16T00:00:00+08:00">2020-03-16</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-24 16:03:00" itemprop="dateModified" datetime="2020-03-24T16:03:00+08:00">2020-03-24</time>
              </span>
            
          

          

          
            
            
          

          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
                 阅读次数： 
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">56k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">50 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="推荐系统基础"><a href="#推荐系统基础" class="headerlink" title="推荐系统基础"></a>推荐系统基础</h1><h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><h3 id="推荐的概念"><a href="#推荐的概念" class="headerlink" title="推荐的概念"></a>推荐的概念</h3><ul>
<li>信息过滤系统 解决 信息过载 用户需求不明确的问题<ul>
<li>利用一定的规则将物品排序 展示给需求不明确的用户</li>
</ul>
</li>
<li>推荐 搜索区别<ul>
<li>推荐个性化较强，用户被动的接受，希望能够提供持续的服务</li>
<li>搜索个性化弱，用户主动搜索，快速满足用户的需求</li>
</ul>
</li>
<li>推荐和 web项目区别<ul>
<li>构建稳定的信息流通通道</li>
<li>推荐 信息过滤系统</li>
<li>web 对结果有明确预期</li>
<li>推荐 结果是概率问题</li>
</ul>
</li>
</ul>
<h3 id="Lambda-架构介绍"><a href="#Lambda-架构介绍" class="headerlink" title="Lambda 架构介绍"></a>Lambda 架构介绍</h3><p><img src="https://s1.ax1x.com/2020/03/18/8DnuIf.png" alt="8DnuIf.png"></p>
<ul>
<li>离线计算和实时计算共同提供服务的问题</li>
<li>离线计算优缺点<ul>
<li>优点 能够处理的数据量可以很大 比如pb级别</li>
<li>缺点 速度比较慢 分钟级别的延迟</li>
</ul>
</li>
<li>实时计算<ul>
<li>优点 响应快 来一条数据处理一条 ms级别响应</li>
<li>缺点 处理的数据量小一些</li>
</ul>
</li>
<li>离线计算的框架<ul>
<li>hadoop hdfs mapreduce</li>
<li>spark core , spark sql</li>
<li>hive</li>
</ul>
</li>
<li>实时计算框架<ul>
<li>spark streaming</li>
<li>storm</li>
<li>flink</li>
</ul>
</li>
<li>消息中间件<ul>
<li>flume 日志采集系统</li>
<li>kafka 消息队列</li>
</ul>
</li>
<li>存储相关<ul>
<li>hbase nosql数据库</li>
<li>hive  sql操作hdfs数据</li>
</ul>
</li>
</ul>
<h3 id="推荐算法架构"><a href="#推荐算法架构" class="headerlink" title="推荐算法架构"></a>推荐算法架构</h3><ul>
<li><p>召回</p>
<ul>
<li><p>协同过滤  算相似度 memory base</p>
</li>
<li><p>基于模型的 model base  矩阵分解</p>
</li>
<li><p>基于内容</p>
<ul>
<li>分词</li>
<li>词权重（提取关键词） tf-idf</li>
<li>word2Vec 词向量</li>
<li>物品向量</li>
</ul>
</li>
</ul>
</li>
<li><p>排序</p>
<ul>
<li>逻辑回归</li>
</ul>
</li>
<li><p>策略调整</p>
</li>
</ul>
<p>  整体流程</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8DlFu4.jpg" alt="8DlFu4.jpg"></p>
<p>lambda内</p>
<p><img src="https://s1.ax1x.com/2020/03/18/8D1mZj.png" alt="8D1mZj.png"></p>
<h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul>
<li>推荐模型构建流程</li>
<li>推荐算法概述</li>
<li>基于协同过滤的推荐算法</li>
<li>协同过滤实现</li>
</ul>
<h3 id="一-推荐模型构建流程"><a href="#一-推荐模型构建流程" class="headerlink" title="一 推荐模型构建流程"></a>一 推荐模型构建流程</h3><p>Data(数据)-&gt;Features(特征)-&gt;ML Algorithm(机器学习算法)-&gt;Prediction Output(预测输出)</p>
<ul>
<li>数据清洗/数据处理</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/03/20/8cChRJ.png" alt="8cChRJ.png"></p>
<ul>
<li><p>数据来源</p>
<ul>
<li>显性数据<ul>
<li>Rating 打分</li>
<li>Comments 评论/评价</li>
</ul>
</li>
<li>隐形数据<ul>
<li> Order history 历史订单</li>
<li> Cart events    加购物车</li>
<li> Page views    页面浏览</li>
<li> Click-thru      点击</li>
<li> Search log     搜索记录</li>
</ul>
</li>
</ul>
</li>
<li><p>数据量/数据能否满足要求</p>
</li>
<li><p>特征工程</p>
</li>
<li><p>从数据中筛选特征</p>
<ul>
<li>一个给定的商品，可能被拥有类似品味或需求的用户购买</li>
<li>使用用户行为数据描述商品</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/03/20/8cPgOI.png" alt="8cPgOI.png"></p>
<ul>
<li><p>用数据表示特征</p>
<ul>
<li><p>将所有用户行为合并在一起 ，形成一个user-item 矩阵</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cijKA.png" alt="8cijKA.png">选择合适的算法</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/03/20/8cFpUf.png" alt="8cFpUf.png"></p>
<ul>
<li><p>产生推荐结果</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cFi8g.png" alt="8cFi8g.png"></p>
</li>
</ul>
<h3 id="二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）"><a href="#二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）" class="headerlink" title="二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）"></a>二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</h3><h4 id="协同过滤-CF-思路介绍"><a href="#协同过滤-CF-思路介绍" class="headerlink" title="协同过滤(CF)思路介绍"></a>协同过滤(CF)思路介绍</h4><ul>
<li><p>CF <strong>物以类聚人以群分</strong></p>
</li>
<li><p>做协同过滤的话 首先特征工程把 用户-物品的评分矩阵创建出来</p>
</li>
<li><p>基于用户的协同过滤</p>
<p><img src="https://s1.ax1x.com/2020/03/19/8r3IJI.png" alt="8r3IJI.png"></p>
<ul>
<li>给用户A 找到最相似的N个用户</li>
<li>N个用户消费过哪些物品</li>
<li>N个用户消费过的物品中-A用户消费过的就是推荐结果</li>
</ul>
</li>
<li><p>基于物品的协同过滤</p>
<p><img src="https://s1.ax1x.com/2020/03/19/8r3xFs.png" alt="8r3xFs.png"></p>
<ul>
<li>给物品A 找到最相似的N个物品</li>
<li>A用户消费记录 找到这些物品的相似物品</li>
<li>从这些相似物品先去重-A用户消费过的就是推荐结果</li>
</ul>
</li>
</ul>
<h3 id="三-相似度计算-Similarity-Calculation"><a href="#三-相似度计算-Similarity-Calculation" class="headerlink" title="三 相似度计算(Similarity Calculation)"></a>三 相似度计算(Similarity Calculation)</h3><h4 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul>
<li>余弦相似度、皮尔逊相关系数<ul>
<li>向量的夹角余弦值</li>
<li>皮尔逊会对向量的每一个分量做中心化</li>
<li>余弦只考虑方向 不考虑向量长度</li>
<li>如果评分数据是连续的数值比较适合中余弦、皮尔逊计算相似度</li>
</ul>
</li>
<li>杰卡德相似度<ul>
<li>交集/并集</li>
<li>计算评分是0 1 布尔值的相似度</li>
</ul>
</li>
</ul>
<h4 id="使用不同相似度计算方式实现协同过滤"><a href="#使用不同相似度计算方式实现协同过滤" class="headerlink" title="使用不同相似度计算方式实现协同过滤"></a>使用不同相似度计算方式实现协同过滤</h4><ul>
<li><p>如果 买/没买 点/没点数据 0/1 适合使用<strong>杰卡德相似度</strong></p>
<ul>
<li>from sklearn.metrics import jaccard_similarity_score</li>
<li>jaccard_similarity_score(df[‘Item A’],df[‘Item B’])</li>
<li>from sklearn.metrics.pairwise import pairwise_distances</li>
<li>user_similar = 1-pairwise_distances(df,metric=’jaccard’)</li>
</ul>
</li>
<li><p>一般用评分去做协同过滤 推荐使用<strong>皮尔逊相关系数</strong>(sim是交集除并集)</p>
<ul>
<li><p>评分预测</p>
</li>
<li><p>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$</p>
</li>
</ul>
</li>
<li><p>基于用户和基于物品的协同过滤 严格上说，属于两种算法，实践中可以都做出来，对比效果，选择最靠谱的</p>
</li>
</ul>
<h3 id="协同过滤推荐算法代码实现："><a href="#协同过滤推荐算法代码实现：" class="headerlink" title="协同过滤推荐算法代码实现："></a>协同过滤推荐算法代码实现：</h3><ul>
<li><p>构建数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>],</span><br><span class="line">    [<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="string">"buy"</span>,<span class="literal">None</span>,<span class="string">"buy"</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算时我们数据通常都需要对数据进行处理，或者编码，目的是为了便于我们对数据进行运算处理，比如这里是比较简单的情形，我们用1、0分别来表示用户的是否购买过该物品，则我们的数据集其实应该是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了数据集，接下来我们就可以进行相似度的计算，不过对于相似度的计算其实是有很多专门的相似度计算方法的，比如余弦相似度、皮尔逊相关系数、杰卡德相似度等等。这里我们选择使用杰卡德相似系数[0,1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接计算某两项的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line"><span class="comment"># 计算Item A 和Item B的相似度</span></span><br><span class="line">print(jaccard_similarity_score(df[<span class="string">"Item A"</span>], df[<span class="string">"Item B"</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数(相似度=1-距离)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">print(item_similar)</span><br></pre></td></tr></table></figure>

<p>有了两两的相似度，接下来就可以筛选TOP-N相似结果，并进行推荐了</p>
</li>
<li><p>User-Based CF</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line">topN_users = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> user_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = user_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = list(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_users[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Top2相似用户："</span>)</span><br><span class="line">pprint(topN_users)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user, sim_users <span class="keyword">in</span> topN_users.items():</span><br><span class="line">    rs_result = set()    <span class="comment"># 存储推荐结果</span></span><br><span class="line">    <span class="keyword">for</span> sim_user <span class="keyword">in</span> sim_users:</span><br><span class="line">        <span class="comment"># 构建初始的推荐结果</span></span><br><span class="line">        <span class="comment">#dropna()的使用  b=a.dropna()，则直接将a中的nan值给删除掉了</span></span><br><span class="line">        <span class="comment"># 使用loc:只能指定行列索引的名字</span></span><br><span class="line">        <span class="comment"># 使用iloc可以通过索引的下标去获取</span></span><br><span class="line">        <span class="comment"># 使用ix进行下表和名称组合做引</span></span><br><span class="line">        rs_result = rs_result.union(set(df.ix[sim_user].replace(<span class="number">0</span>,np.nan).dropna().index))</span><br><span class="line">    <span class="comment"># 过滤掉已经购买过的物品</span></span><br><span class="line">    rs_result -= set(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line">print(<span class="string">"最终推荐结果："</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Item-Based CF</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">"jaccard"</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">print(item_similar)</span><br><span class="line"></span><br><span class="line">topN_items = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> item_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = item_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = list(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_items[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Top2相似物品："</span>)</span><br><span class="line">pprint(topN_items)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> df.index:    <span class="comment"># 遍历所有用户</span></span><br><span class="line">    rs_result = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index:   <span class="comment"># 取出每个用户当前已购物品列表</span></span><br><span class="line">        <span class="comment"># 根据每个物品找出最相似的TOP-N物品，构建初始推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(topN_items[item])</span><br><span class="line">    <span class="comment"># 过滤掉用户已购的物品</span></span><br><span class="line">    rs_result -= set(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    <span class="comment"># 添加到结果中</span></span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"></span><br><span class="line">print(<span class="string">"最终推荐结果："</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>关于协同过滤推荐算法使用的数据集</strong></p>
<p>在前面的demo中，我们只是使用用户对物品的一个购买记录，类似也可以是比如浏览点击记录、收听记录等等。这样数据我们预测的结果其实相当于是在预测用户是否对某物品感兴趣，对于喜好程度不能很好的预测。</p>
<p>因此在协同过滤推荐算法中其实会更多的利用用户对物品的“评分”数据来进行预测，通过评分数据集，我们可以预测用户对于他没有评分过的物品的评分。其实现原理和思想和都是一样的，只是使用的数据集是用户-物品的评分数据。</p>
<p><strong>关于用户-物品评分矩阵</strong></p>
<p>用户-物品的评分矩阵，根据评分矩阵的稀疏程度会有不同的解决方案</p>
<ul>
<li><p>稠密评分矩阵</p>
<p><img src="https://s1.ax1x.com/2020/03/20/828fEV.png" alt="828fEV.png"></p>
</li>
<li><p>稀疏评分矩阵</p>
<p><img src="https://s1.ax1x.com/2020/03/20/823Ofg.png" alt="823Ofg.png"></p>
</li>
</ul>
<p>这里先介绍稠密评分矩阵的处理，稀疏矩阵的处理相对会复杂一些，我们到后面再来介绍。</p>
<h4 id="使用协同过滤推荐算法对用户进行评分预测"><a href="#使用协同过滤推荐算法对用户进行评分预测" class="headerlink" title="使用协同过滤推荐算法对用户进行评分预测"></a>使用协同过滤推荐算法对用户进行评分预测</h4><ul>
<li><p>数据集：</p>
<p><img src="https://s1.ax1x.com/2020/03/20/828fEV.png" alt="828fEV.png"></p>
<p><strong>目的：预测用户1对物品E的评分</strong></p>
</li>
<li><p>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p>
<blockquote>
<p>pandas中corr方法可直接用于计算皮尔逊相关系数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line">print(user_similar.round(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line">print(item_similar.round(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 运行结果：</span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  1.0000  0.8528  0.7071  0.0000 -0.7921</span><br><span class="line">User2  0.8528  1.0000  0.4677  0.4900 -0.9001</span><br><span class="line">User3  0.7071  0.4677  1.0000 -0.1612 -0.4666</span><br><span class="line">User4  0.0000  0.4900 -0.1612  1.0000 -0.6415</span><br><span class="line">User5 -0.7921 -0.9001 -0.4666 -0.6415  1.0000</span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  1.0000 -0.4767 -0.1231  0.5322  0.9695</span><br><span class="line">Item B -0.4767  1.0000  0.6455 -0.3101 -0.4781</span><br><span class="line">Item C -0.1231  0.6455  1.0000 -0.7206 -0.4276</span><br><span class="line">Item D  0.5322 -0.3101 -0.7206  1.0000  0.5817</span><br><span class="line">Item E  0.9695 -0.4781 -0.4276  0.5817  1.0000</span><br></pre></td></tr></table></figure>

<p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p>
<p><strong>注意：</strong>我们在预测评分时，往往是通过与其有正相关的用户或物品进行预测，如果不存在正相关的情况，那么将无法做出预测。这一点尤其是在稀疏评分矩阵中尤为常见，因为稀疏评分矩阵中很难得出正相关系数。</p>
</li>
<li><p><strong>评分预测：</strong></p>
<p><strong>User-Based CF 评分预测：使用用户间的相似度进行预测</strong></p>
<p>关于评分预测的方法也有比较多的方案，下面介绍一种效果比较好的方案，该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测：<br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$<br>我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p>
<p>​<br>$$<br>pred(u_1, i_5) =\cfrac{0.85<em>3+0.71</em>5}{0.85+0.71} = 3.91<br>$$<br>最终预测出用户1对物品5的评分为3.91</p>
<p><strong>Item-Based CF 评分预测：使用物品间的相似度进行预测</strong></p>
<p>这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测<br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{j\in I_{rated}}sim(i,j)<em>r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}<br>$$<br>我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下：<br>$$<br>pred(u_1, i_5) = \cfrac {0.97</em>5+0.58*4}{0.97+0.58} = 4.63<br>$$<br>对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法，各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估，因此在实现推荐系统时这两种算法往往都是需要去实现的，然后对产生的推荐效果进行评估分析选出更优方案。</p>
</li>
</ul>
<h3 id="基于模型的方法–解决用户和物品矩阵比较稀疏的情况"><a href="#基于模型的方法–解决用户和物品矩阵比较稀疏的情况" class="headerlink" title="基于模型的方法–解决用户和物品矩阵比较稀疏的情况"></a>基于模型的方法–解决用户和物品矩阵比较稀疏的情况</h3><ul>
<li><p>思想</p>
<ul>
<li>通过机器学习算法，在数据中找出模式，并将用户与物品间的互动方式模式化</li>
<li>基于模型的协同过滤方式是构建协同过滤更高级的算法</li>
</ul>
</li>
<li><p>近邻模型的问题</p>
<ul>
<li>物品之间存在相关性, 信息量并不随着向量维度增加而线性增加</li>
<li>矩阵元素稀疏, 计算结果不稳定,增减一个向量维度, 导致近邻结果差异很大的情况存在</li>
</ul>
</li>
<li><p>算法分类</p>
<ul>
<li>基于图的模型</li>
<li><strong>基于矩阵分解的方法</strong></li>
</ul>
</li>
<li><p>基于图的模型</p>
<ul>
<li>基于邻域的模型看做基于图的模型的简单形式</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/03/21/8R24bt.png" alt="8R24bt.png"></p>
<ul>
<li>原理<ul>
<li>将用户的行为数据表示为二分图</li>
<li>基于二分图为用户进行推荐</li>
<li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li>
</ul>
</li>
</ul>
</li>
<li><p>基于矩阵分解的模型–降维</p>
<ul>
<li><p>原理</p>
<ul>
<li><p>根据用户与物品的潜在表现，我们就可以预测用户对未评分的物品的喜爱程度</p>
</li>
<li><p>把原来的大矩阵, 近似分解成两个小矩阵的乘积, 在实际推荐计算时不再使用大矩阵, 而是使用分解得到的两个小矩阵  </p>
</li>
<li><p>用户-物品评分矩阵A是M X N维, 即一共有M个用户, n个物品 我们选一个很小的数 K (K&lt;&lt; M, K&lt;&lt;N)</p>
</li>
<li><p>通过计算得到两个矩阵U V  U是M * K矩阵 , 矩阵V是 N * K</p>
<p>$U_{m<em>k} V^{T}_{n</em>k} 约等于 A_{m*n}$</p>
<p>类似这样的计算过程就是矩阵分解</p>
</li>
</ul>
</li>
<li><p>基于矩阵分解的方法</p>
<ul>
<li>ALS交替最小二乘<ul>
<li>ALS-WR(加权正则化交替最小二乘法): alternating-least-squares with weighted-λ –regularization</li>
<li>将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户做商品推荐了。</li>
</ul>
</li>
<li>SVD奇异值分解矩阵</li>
</ul>
</li>
</ul>
</li>
<li><p>ALS方法–交替最小二乘法来优化损失</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8R2T58.png" alt="8R2T58.png"></p>
<ul>
<li>ALS的矩阵分解算法常应用于推荐系统中，将用户(user)对商品(item)的评分矩阵，分解为用户对商品隐含特征的偏好矩阵，和商品在隐含特征上的映射矩阵。</li>
<li>与传统的矩阵分解SVD方法来分解矩阵R(R∈ℝm×n)不同的是，ALS(alternating least squares)希望找到两个低维矩阵，以 R̃ =XY 来逼近矩阵R，其中 ，X∈ℝm×d，Y∈ℝd×n，这样，将问题的复杂度由O(m<em>n)转换为O((m+n)</em>d)。</li>
<li>计算X和Y过程：首先用一个小于1的随机数初始化Y，并根据公式求X，此时就可以得到初始的XY矩阵了，根据平方差和得到的X，重新计算并覆盖Y，计算差平方和，反复进行以上两步的计算，直到差平方和小于一个预设的数，或者迭代次数满足要求则停止</li>
</ul>
</li>
</ul>
<h2 id="四-推荐系统评估"><a href="#四-推荐系统评估" class="headerlink" title="四 推荐系统评估"></a>四 推荐系统评估</h2><ul>
<li><p>好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢</p>
</li>
<li><p>显示反馈和隐式反馈</p>
<table>
  <tr>
    <th></th>
    <th>显式反馈</th>
    <th>隐式反馈</th>
  </tr>
  <tr>
 <td> 例子 </td>
 <td> 电影/书籍评分 
 是否喜欢这个推荐 </td>
 <td> 播放/点击 评论 下载 购买 </td>
  </tr>
  <tr>
    <td> 准确性 </td>
    <td> 高 </td>
    <td> 低 </td>
  </tr>
  <tr>
    <td> 数量 </td>
    <td> 少 </td>
    <td> 多 </td>
  </tr>
  <tr>
    <td> 获取成本 </td>
    <td> 高 </td>
    <td> 低 </td>
  </tr>
</table>
</li>
<li><p>常用评估指标</p>
<p>• 准确性  • 信任度<br>• 满意度  • 实时性<br>• 覆盖率  • 鲁棒性<br>• 多样性  • 可扩展性<br>• 新颖性  • 商业⽬标<br>• 惊喜度  • ⽤户留存</p>
<ul>
<li><p>准确性 (理论角度) Netflix 美国录像带租赁</p>
<ul>
<li>评分预测–线性回归<ul>
<li>RMSE   MAE</li>
</ul>
</li>
<li>topN推荐<ul>
<li>召回率 精准率</li>
</ul>
</li>
</ul>
</li>
<li><p>准确性 (业务角度)</p>
</li>
<li><p>覆盖度</p>
<ul>
<li>信息熵 对于推荐越大越好</li>
<li>覆盖率</li>
</ul>
</li>
<li><p>多样性&amp;新颖性&amp;惊喜性</p>
<ul>
<li>多样性：推荐列表中两两物品的不相似性。（相似性如何度量？</li>
<li>新颖性：未曾关注的类别、作者；推荐结果的平均流⾏度</li>
<li>惊喜性：历史不相似（惊）但很满意（喜）</li>
<li>往往需要牺牲准确性</li>
<li>使⽤历史⾏为预测⽤户对某个物品的喜爱程度</li>
<li>系统过度强调实时性</li>
</ul>
</li>
<li><p>Exploitation &amp; Exploration 探索与利用问题</p>
<ul>
<li>Exploitation(开发 利用)：选择现在可能最佳的⽅案</li>
<li>Exploration(探测 搜索)：选择现在不确定的⼀些⽅案，但未来可能会有⾼收益的⽅案</li>
<li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化<br>长期的⽬标</li>
</ul>
</li>
<li><p>EE问题实践</p>
<ul>
<li>兴趣扩展: 相似话题, 搭配推荐</li>
<li>人群算法: userCF 用户聚类</li>
<li>平衡个性化推荐和热门推荐比例</li>
<li>随机丢弃用户行为历史</li>
<li>随机扰动模型参数</li>
</ul>
</li>
<li><p>EE可能带来的问题</p>
<ul>
<li>探索伤害用户体验, 可能导致用户流失</li>
<li>探索带来的长期收益(留存率)评估周期长, KPI压力大</li>
<li>如何平衡实时兴趣和长期兴趣</li>
<li>如何平衡短期产品体验和长期系统生态</li>
<li>如何平衡大众口味和小众需求</li>
</ul>
</li>
<li><p>评估方法</p>
<ul>
<li>问卷调查: 成本高</li>
<li>离线评估:<ul>
<li>只能在用户看到过的候选集上做评估, 且跟线上真实效果存在偏差</li>
<li>只能评估少数指标</li>
<li>速度快, 不损害用户体验</li>
</ul>
</li>
<li>在线评估: 灰度发布 &amp; A/B测试 50% 全量上线</li>
<li>实践: 离线评估和在线评估结合, 定期做问卷调查</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五-推荐系统的冷启动问题"><a href="#五-推荐系统的冷启动问题" class="headerlink" title="五 推荐系统的冷启动问题"></a>五 推荐系统的冷启动问题</h3><ul>
<li><p>推荐系统冷启动概念</p>
<ul>
<li>⽤户冷启动：如何为新⽤户做个性化推荐</li>
<li>物品冷启动：如何将新物品推荐给⽤户（协同过滤）</li>
<li>系统冷启动：⽤户冷启动+物品冷启动</li>
<li>本质是推荐系统依赖历史数据，没有历史数据⽆法预测⽤户偏好</li>
</ul>
</li>
<li><p>用户冷启动</p>
<ul>
<li><p>1.收集⽤户特征</p>
<ul>
<li><p>⽤户注册信息：性别、年龄、地域</p>
</li>
<li><p>设备信息：定位、⼿机型号、app列表</p>
</li>
<li><p>社交信息、推⼴素材、安装来源</p>
</li>
</ul>
</li>
<li><p>2 引导用户填写兴趣</p>
</li>
<li><p>3 使用其它站点的行为数据, 例如腾讯视频&amp;QQ音乐 今日头条&amp;抖音</p>
</li>
<li><p>4 新老用户推荐策略的差异</p>
<ul>
<li>新⽤户在冷启动阶段更倾向于热门排⾏榜，⽼⽤户会更加需要长尾推荐</li>
<li>Explore Exploit⼒度</li>
<li>使⽤单独的特征和模型预估</li>
</ul>
</li>
<li><p>举例 性别与电视剧的关系</p>
</li>
</ul>
</li>
<li><p>物品冷启动</p>
<ul>
<li>给物品打标签–构建物品画像</li>
<li>利用物品的内容信息，将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。</li>
</ul>
</li>
<li><p>系统冷启动</p>
<ul>
<li>基于内容的推荐 系统早期</li>
<li>基于内容的推荐逐渐过渡到协同过滤</li>
<li>基于内容的推荐和协同过滤的推荐结果都计算出来 加权求和得到最终推荐结果</li>
</ul>
</li>
</ul>
<h2 id="案例–基于协同过滤的电影推荐"><a href="#案例–基于协同过滤的电影推荐" class="headerlink" title="案例–基于协同过滤的电影推荐"></a>案例–基于协同过滤的电影推荐</h2><p>前面我们已经基本掌握了协同过滤推荐算法，以及其中两种最基本的实现方案：User-Based CF和Item-Based CF，下面我们将利用真是的数据来进行实战演练。</p>
<p>案例需求 演示效果</p>
<p>分析案例</p>
<h4 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h4><p><a href="https://grouplens.org/datasets/movielens/latest/" target="_blank" rel="noopener">MovieLens Latest Datasets Small</a></p>
<p>建议下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip" target="_blank" rel="noopener">ml-latest-small.zip</a>，数据量小，便于我们单机使用和运行</p>
<p>目标：根据<code>ml-latest-small/ratings.csv</code>（用户-电影评分数据），分别实现User-Based CF和Item-Based CF，并进行电影评分的预测，然后为用户实现电影推荐</p>
<h4 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h4><ul>
<li><p>加载ratings.csv，并转换为用户-电影评分矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">"./datasets/ml-latest-small/ratings.csv"</span></span><br><span class="line">CACHE_DIR = <span class="string">"./datasets/cache/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(data_path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 数据集缓存地址</span></span><br><span class="line">    cache_path = os.path.join(CACHE_DIR, <span class="string">"ratings_matrix.cache"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"开始加载数据集..."</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache_path):    <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">        print(<span class="string">"加载缓存中..."</span>)</span><br><span class="line">        ratings_matrix = pd.read_pickle(cache_path) <span class="comment"># 转换成pickle加快操作</span></span><br><span class="line">        print(<span class="string">"从缓存加载数据集完毕"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"加载新数据中..."</span>)</span><br><span class="line">        <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">        dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">        <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">        ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>)) <span class="comment"># 读取前三列</span></span><br><span class="line">        <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">        ratings_matrix = ratings.pivot_table(index=[<span class="string">"userId"</span>], columns=[<span class="string">"movieId"</span>], values=<span class="string">"rating"</span>)</span><br><span class="line">        <span class="comment"># 存入缓存文件</span></span><br><span class="line">        ratings_matrix.to_pickle(cache_path)</span><br><span class="line">        print(<span class="string">"数据集加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span>  ratings_matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(<a href="https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html</a>) 透视表知识点补充</p>
<h4 id="相似度计算-1"><a href="#相似度计算-1" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul>
<li><p>计算用户或物品两两相似度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span><span class="params">(ratings_matrix, based=<span class="string">"user"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param based: "user" or "item"</span></span><br><span class="line"><span class="string">    :return: 相似度矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"user_similarity.cache"</span>)</span><br><span class="line">    item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"item_similarity.cache"</span>)</span><br><span class="line">    <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">    <span class="comment"># 用户相似度</span></span><br><span class="line">    <span class="keyword">if</span> based == <span class="string">"user"</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">            print(<span class="string">"正从缓存加载用户相似度矩阵"</span>)</span><br><span class="line">            similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"开始计算用户相似度矩阵"</span>)</span><br><span class="line">            similarity = ratings_matrix.T.corr()</span><br><span class="line">            similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> based == <span class="string">"item"</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">            print(<span class="string">"正从缓存加载物品相似度矩阵"</span>)</span><br><span class="line">            similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"开始计算物品相似度矩阵"</span>)</span><br><span class="line">            similarity = ratings_matrix.corr()</span><br><span class="line">            similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Unhandled 'based' Value: %s"</span>%based)</span><br><span class="line">    print(<span class="string">"相似度矩阵计算/加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    print(user_similar)</span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"item"</span>)</span><br><span class="line">    print(item_similar)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上实现，仅用于实验阶段，因为工业上、或生产环境中，数据量是远超过我们本例中使用的数据量的，而pandas是无法支撑起大批量数据的运算的，因此工业上通常会使用spark、mapReduce等分布式计算框架来实现，我们后面的课程中也是建立在此基础上进行实践的。</p>
<p>但是正如前面所说，推荐算法的思想和理念都是统一的，不论使用什么平台工具、有多大的数据体量，其背后的实现原理都是不变的。</p>
<p>所以在本节，大家要深刻去学习的是推荐算法的业务流程，以及在具体的业务场景中，如本例的电影推荐，如何实现出推荐算法，并产生推荐结果。</p>
<h2 id="案例–算法实现：User-Based-CF-预测评分"><a href="#案例–算法实现：User-Based-CF-预测评分" class="headerlink" title="案例–算法实现：User-Based CF 预测评分"></a>案例–算法实现：User-Based CF 预测评分</h2><p><strong>评分预测公式：</strong><br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}<br>$$</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><p>实现评分预测方法：<code>predict</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(uid, iid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分..."</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">    similar_users = user_similar[uid].drop([uid]).dropna()</span><br><span class="line">    <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">    similar_users = similar_users.where(similar_users&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;没有相似的用户"</span> % uid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">    ids = set(ratings_matrix[iid].dropna().index)&amp;set(similar_users.index)</span><br><span class="line">    finally_similar_users = similar_users.ix[list(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">        <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">        sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">        <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">        sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">"预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f"</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> round(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, user_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, user_similar)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现预测全部评分方法：<code>predict_all</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(uid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加过滤规则</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span><span class="params">(uid, item_ids, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(uid, ratings_matrix, user_similar, filter_rule=None)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常："unhot","rated",["unhot","rated"],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"unhot"</span>:</span><br><span class="line">        <span class="string">'''过滤非热门电影'''</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"rated"</span>:</span><br><span class="line">        <span class="string">'''过滤用户评分过的电影'''</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> isinstance(filter_rule, list) <span class="keyword">and</span> set(filter_rule) == set([<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">        <span class="string">'''过滤非热门和用户已经评分过的电影'''</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = set(ids1)&amp;set(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"无效的过滤参数"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据预测评分为指定用户进行TOP-N推荐：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span><span class="params">(k)</span>:</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>])</span><br><span class="line">    <span class="keyword">return</span> sorted(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="案例–算法实现：Item-Based-CF-预测评分"><a href="#案例–算法实现：Item-Based-CF-预测评分" class="headerlink" title="案例–算法实现：Item-Based CF 预测评分"></a>案例–算法实现：Item-Based CF 预测评分</h2><p><strong>评分预测公式：</strong><br>$$<br>pred(u,i)=\hat{r}<em>{ui}=\cfrac{\sum</em>{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}<br>$$<br>(与U-B一样)</p>
<h3 id="Model-Based-协同过滤算法"><a href="#Model-Based-协同过滤算法" class="headerlink" title="Model-Based 协同过滤算法"></a>Model-Based 协同过滤算法</h3><p>随着机器学习技术的逐渐发展与完善，推荐系统也逐渐运用机器学习的思想来进行推荐。将机器学习应用到推荐系统中的方案真是不胜枚举。以下对Model-Based CF算法做一个大致的分类：</p>
<ul>
<li>基于分类算法、回归算法、聚类算法</li>
<li>基于矩阵分解的推荐</li>
<li>基于神经网络算法</li>
<li>基于图模型算法</li>
</ul>
<p>接下来我们重点学习以下几种应用较多的方案：</p>
<ul>
<li><strong>基于K最近邻的协同过滤推荐</strong></li>
<li><strong>基于回归模型的协同过滤推荐</strong></li>
<li><strong>基于矩阵分解的协同过滤推荐</strong></li>
</ul>
<h2 id="基于K最近邻的协同过滤推荐"><a href="#基于K最近邻的协同过滤推荐" class="headerlink" title="基于K最近邻的协同过滤推荐"></a>基于K最近邻的协同过滤推荐</h2><p>基于K最近邻的协同过滤推荐其实本质上就是MemoryBased CF，只不过在选取近邻的时候，加上K最近邻的限制。</p>
<p>这里我们直接根据MemoryBased CF的代码实现</p>
<p>修改以下地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollaborativeFiltering</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    based = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k=<span class="number">40</span>, rules=None, use_cache=False, standard=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param k: 取K个最近邻来进行预测</span></span><br><span class="line"><span class="string">        :param rules: 过滤规则，四选一，否则将抛异常："unhot", "rated", ["unhot","rated"], None</span></span><br><span class="line"><span class="string">        :param use_cache: 相似度计算结果是否开启缓存</span></span><br><span class="line"><span class="string">        :param standard: 评分标准化方法，None表示不使用、mean表示均值中心化、zscore表示Z-Score标准化</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.k = <span class="number">40</span></span><br><span class="line">        self.rules = rules</span><br><span class="line">        self.use_cache = use_cache</span><br><span class="line">        self.standard = standard</span><br></pre></td></tr></table></figure>

<p>修改所有的选取近邻的地方的代码，根据相似度来选取K个最近邻</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">similar_users = self.similar[uid].drop([uid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br><span class="line"></span><br><span class="line">similar_items = self.similar[iid].drop([iid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br></pre></td></tr></table></figure>

<p>  <strong>最终代码汇总</strong></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">"../datasets/ml-latest-small/ratings.csv"</span></span><br><span class="line">CACHE_DIR = <span class="string">"../datasets/cache/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollaborativeFiltering</span><span class="params">(object)</span>:</span></span><br><span class="line">    based = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k=<span class="number">40</span>, rules=None, use_cache=False, standard=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param k: 取K个最近邻来进行预测</span></span><br><span class="line"><span class="string">        :param rules: 过滤规则，四选一，否则将抛异常："unhot", "rated", ["unhot","rated"], None</span></span><br><span class="line"><span class="string">        :param use_cache: 相似度计算结果是否开启缓存</span></span><br><span class="line"><span class="string">        :param standard: 评分标准化方法，None表示不使用、mean表示均值中心化、zscore表示Z-Score标准化</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.k = <span class="number">40</span></span><br><span class="line">        self.rules = rules</span><br><span class="line">        self.use_cache = use_cache</span><br><span class="line">        self.standard = standard</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self, data_path)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        加载数据</span></span><br><span class="line"><span class="string">        :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">        :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">        :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 数据集缓存地址</span></span><br><span class="line">        cache_path = os.path.join(CACHE_DIR, <span class="string">"ratings_matrix.cache"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"开始加载数据集..."</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(cache_path):  <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">            print(<span class="string">"加载缓存中..."</span>)</span><br><span class="line">            ratings_matrix = pd.read_pickle(cache_path)  <span class="comment"># 转换成pickle加快操作</span></span><br><span class="line">            print(<span class="string">"从缓存加载数据集完毕"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"加载新数据中..."</span>)</span><br><span class="line">            <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">            dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">            <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">            ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))  <span class="comment"># 读取前三列</span></span><br><span class="line">            <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">            ratings_matrix = ratings.pivot_table(index=[<span class="string">"userId"</span>], columns=[<span class="string">"movieId"</span>], values=<span class="string">"rating"</span>)</span><br><span class="line">            <span class="comment"># 存入缓存文件</span></span><br><span class="line">            ratings_matrix.to_pickle(cache_path)</span><br><span class="line">            print(<span class="string">"数据集加载完毕"</span>)</span><br><span class="line">        <span class="keyword">return</span> ratings_matrix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相似度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span><span class="params">(self, ratings_matrix, based=<span class="string">"user"</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        :param based: "user" or "item"</span></span><br><span class="line"><span class="string">        :return: 相似度矩阵</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"user_similarity.cache"</span>)</span><br><span class="line">        item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"item_similarity.cache"</span>)</span><br><span class="line">        <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">        <span class="comment"># 用户相似度</span></span><br><span class="line">        <span class="keyword">if</span> based == <span class="string">"user"</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">                print(<span class="string">"正从缓存加载用户相似度矩阵"</span>)</span><br><span class="line">                similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"开始计算用户相似度矩阵"</span>)</span><br><span class="line">                similarity = ratings_matrix.T.corr()</span><br><span class="line">                similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> based == <span class="string">"item"</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">                print(<span class="string">"正从缓存加载物品相似度矩阵"</span>)</span><br><span class="line">                similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"开始计算物品相似度矩阵"</span>)</span><br><span class="line">                similarity = ratings_matrix.corr()</span><br><span class="line">                similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unhandled 'based' Value: %s"</span> % based)</span><br><span class="line">        print(<span class="string">"相似度矩阵计算/加载完毕"</span>)</span><br><span class="line">        <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户指定商品的评分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">        :param uid: 用户ID</span></span><br><span class="line"><span class="string">        :param iid: 物品ID</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">        :return: 预测的评分值</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        print(<span class="string">"开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分..."</span> % (uid, iid))</span><br><span class="line">        <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">        similar_users = user_similar[uid].drop([uid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:self.k]</span><br><span class="line">        <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">        similar_users = similar_users.where(similar_users &gt; <span class="number">0</span>).dropna()</span><br><span class="line">        <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;没有相似的用户"</span> % uid)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">        <span class="comment"># (其中就是筛选出来的用户以下条件:1.是uid的近邻用户 2. 且这些用户对iid有评分)</span></span><br><span class="line">        ids = set(ratings_matrix[iid].dropna().index) &amp; set(similar_users.index)</span><br><span class="line">        finally_similar_users = similar_users.ix[list(ids)]  <span class="comment"># ids内是索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">        sum_up = <span class="number">0</span>  <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">        sum_down = <span class="number">0</span>  <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">        <span class="comment"># iteritems()与itemgetter()函数作用(https://www.cnblogs.com/SpringFull/p/10168533.html)</span></span><br><span class="line">        <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">            <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">            sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">            <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">            sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">            <span class="comment"># 计算分子的值</span></span><br><span class="line">            sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">            <span class="comment"># 计算分母的值</span></span><br><span class="line">            sum_down += similarity</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">        predict_rating = sum_up / sum_down</span><br><span class="line">        print(<span class="string">"预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f"</span> % (uid, iid, predict_rating))</span><br><span class="line">        <span class="keyword">return</span> round(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="comment"># def predict_all(uid, ratings_matrix, user_similar):</span></span><br><span class="line">    <span class="comment">#     '''</span></span><br><span class="line">    <span class="comment">#     预测全部评分</span></span><br><span class="line">    <span class="comment">#     :param uid: 用户id</span></span><br><span class="line">    <span class="comment">#     :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line">    <span class="comment">#     :param user_similar: 用户两两间的相似度</span></span><br><span class="line">    <span class="comment">#     :return: 生成器，逐个返回预测评分</span></span><br><span class="line">    <span class="comment">#     '''</span></span><br><span class="line">    <span class="comment">#     # 准备要预测的物品的id列表</span></span><br><span class="line">    <span class="comment">#     item_ids = ratings_matrix.columns</span></span><br><span class="line">    <span class="comment">#     # 逐个预测</span></span><br><span class="line">    <span class="comment">#     for iid in item_ids:</span></span><br><span class="line">    <span class="comment">#         try:</span></span><br><span class="line">    <span class="comment">#             rating = predict(uid, iid, ratings_matrix, user_similar)</span></span><br><span class="line">    <span class="comment">#         except Exception as e:</span></span><br><span class="line">    <span class="comment">#             print(e)</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             yield uid, iid, rating</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加过滤条件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span><span class="params">(self, uid, item_ids, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测全部评分</span></span><br><span class="line"><span class="string">        :param uid: 用户id</span></span><br><span class="line"><span class="string">        :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">        :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 逐个预测</span></span><br><span class="line">        <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                rating = self.predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_all</span><span class="params">(self, uid, ratings_matrix, user_similar, filter_rule=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">        :param uid: 用户ID</span></span><br><span class="line"><span class="string">        :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">        :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">        :param filter_rule: 过滤规则，只能是四选一，否则将抛异常："unhot","rated",["unhot","rated"],None</span></span><br><span class="line"><span class="string">        :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">            item_ids = ratings_matrix.columns</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"unhot"</span>:</span><br><span class="line">            <span class="string">'''过滤非热门电影'''</span></span><br><span class="line">            <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">            count = ratings_matrix.count()</span><br><span class="line">            <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">            item_ids = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, str) <span class="keyword">and</span> filter_rule == <span class="string">"rated"</span>:</span><br><span class="line">            <span class="string">'''过滤用户评分过的电影'''</span></span><br><span class="line">            <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">            user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">            <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">            _ = user_ratings &lt; <span class="number">6</span>  <span class="comment"># 这里的 _ 存的是判断结果(T/F)</span></span><br><span class="line">            item_ids = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="keyword">elif</span> isinstance(filter_rule, list) <span class="keyword">and</span> set(filter_rule) == set([<span class="string">"unhot"</span>, <span class="string">"rated"</span>]):</span><br><span class="line">            <span class="string">'''过滤非热门和用户已经评分过的电影'''</span></span><br><span class="line">            count = ratings_matrix.count()</span><br><span class="line">            ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">            user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">            _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">            ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">            <span class="comment"># 取二者交集</span></span><br><span class="line">            item_ids = set(ids1) &amp; set(ids2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无效的过滤参数"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> self._predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据预测评分为指定用户进行TOP-N推荐</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span><span class="params">(self, result, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(result, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    U_I = CollaborativeFiltering(k=<span class="number">5</span>, rules=<span class="string">'unhot'</span>, use_cache=<span class="literal">False</span>, standard=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 1.数据集加载</span></span><br><span class="line">    ratings_matrix = U_I.load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.相似度计算-皮尔逊相似系数</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># print(user_similar)</span></span><br><span class="line">    <span class="comment"># item_similar = compute_pearson_similarity(ratings_matrix, based="item")</span></span><br><span class="line">    <span class="comment"># print(item_similar)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 预测给定用户对给定物品的评分值</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># # 预测用户1对物品1的评分</span></span><br><span class="line">    <span class="comment"># predict(1, 1, ratings_matrix, user_similar)</span></span><br><span class="line">    <span class="comment"># # 预测用户1对物品2的评分</span></span><br><span class="line">    <span class="comment"># predict(1, 2, ratings_matrix, user_similar)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 预测全部评分</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment"># for i in predict_all(1, ratings_matrix, user_similar):</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 添加过滤规则后,预测指定用户的全部商品评分</span></span><br><span class="line">    <span class="comment"># user_similar = compute_pearson_similarity(ratings_matrix, based="user")</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># for result in predict_all(1, ratings_matrix, user_similar, filter_rule=["unhot", "rated"]):</span></span><br><span class="line">    <span class="comment">#     print(result)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6.根据预测评分为指定用户进行TOP-N推荐</span></span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">    user_similar = U_I.compute_pearson_similarity(ratings_matrix, based=<span class="string">"user"</span>)</span><br><span class="line">    result = U_I.predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">"unhot"</span>, <span class="string">"rated"</span>])</span><br><span class="line">    top_k = U_I.top_k_rs_result(result, <span class="number">20</span>)</span><br><span class="line">    pprint(top_k)</span><br></pre></td></tr></table></figure>

<p>但由于我们的原始数据较少，这里我们的KNN方法的效果会比纯粹的MemoryBasedCF要差</p>
<h2 id="基于回归模型的协同过滤推荐"><a href="#基于回归模型的协同过滤推荐" class="headerlink" title="基于回归模型的协同过滤推荐"></a>基于回归模型的协同过滤推荐</h2><p>如果我们将评分看作是一个连续的值而不是离散的值，那么就可以借助线性回归思想来预测目标用户对某物品的评分。其中一种实现策略被称为Baseline（基准预测）。</p>
<h4 id="Baseline：基准预测"><a href="#Baseline：基准预测" class="headerlink" title="Baseline：基准预测"></a>Baseline：基准预测</h4><p>Baseline设计思想基于以下的假设：</p>
<ul>
<li>有些用户的评分普遍高于其他用户，有些用户的评分普遍低于其他用户。比如有些用户天生愿意给别人好评，心慈手软，比较好说话，而有的人就比较苛刻，总是评分不超过3分（5分满分）</li>
<li>一些物品的评分普遍高于其他物品，一些物品的评分普遍低于其他物品。比如一些物品一被生产便决定了它的地位，有的比较受人们欢迎，有的则被人嫌弃。</li>
</ul>
<p>这个用户或物品普遍高于或低于平均值的差值，我们称为偏置(bias)</p>
<p><strong>Baseline目标：</strong></p>
<ul>
<li>找出每个用户普遍高于或低于他人的偏置值 $b_u$</li>
<li>找出每件物品普遍高于或低于其他物品的偏置值$b_i$</li>
<li>我们的目标也就转化为寻找最优的$b_u$和$b_i$</li>
</ul>
<p>使用Baseline的算法思想预测评分的步骤如下：</p>
<ul>
<li><p>计算所有电影的平均评分$\mu$（即全局平均评分）</p>
</li>
<li><p>计算每个用户评分与平均评分$\mu$的偏置值$b_u$</p>
</li>
<li><p>计算每部电影所接受的评分与平均评分$\mu$的偏置值$b_i$</p>
</li>
<li><p>预测用户对电影的评分：<br>$$<br>\hat{r}<em>{ui} = b</em>{ui} = \mu + b_u + b_i<br>$$</p>
</li>
</ul>
<p>举例：</p>
<p>​    比如我们想通过Baseline来预测用户A对电影“阿甘正传”的评分，那么首先计算出整个评分数据集的平均评分$\mu$是3.5分；而用户A是一个比较苛刻的用户，他的评分比较严格，普遍比平均评分低0.5分，即用户A的偏置值$b_i$是-0.5；而电影“阿甘正传”是一部比较热门而且备受好评的电影，它的评分普遍比平均评分要高1.2分，那么电影“阿甘正传”的偏置值$b_i$是+1.2，因此就可以预测出用户A对电影“阿甘正传”的评分为：$3.5+(-0.5)+1.2$，也就是4.2分。</p>
<p>对于所有电影的平均评分$\mu$是直接能计算出的，因此问题在于要测出每个用户的$b_u$值和每部电影的$b_i$的值。对于线性回归问题，我们可以利用平方差构建损失函数如下：<br>$$<br>\begin{split}<br>Cost &amp;= \sum_{u,i\in R}(r_{ui}-\hat{r}<em>{ui})^2<br>\&amp;=\sum</em>{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2<br>\end{split}<br>$$<br><img src="https://s1.ax1x.com/2020/03/22/84zHbj.png" alt="84zHbj.png"></p>
<p>加入L2正则化：<br>$$<br>Cost=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>公式解析：</p>
<ul>
<li>公式第一部分$ \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2$是用来寻找与已知评分数据拟合最好的$b_u$和$b_i$</li>
<li>公式第二部分$\lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)$是正则化项，用于避免过拟合现象</li>
</ul>
<p>对于最小过程的求解，我们一般采用<strong>随机梯度下降法</strong>或者<strong>交替最小二乘法</strong>来优化实现。</p>
<h4 id="方法一：随机梯度下降法优化"><a href="#方法一：随机梯度下降法优化" class="headerlink" title="方法一：随机梯度下降法优化"></a>方法一：随机梯度下降法优化</h4><p><a href="https://blog.csdn.net/qq_38150441/article/details/80533891" target="_blank" rel="noopener">梯度下降知识点补充</a></p>
<p>使用随机梯度下降优化算法预测Baseline偏置值</p>
<h6 id="step-1：梯度下降法推导-–-要推出来b-u和b-i的表达式"><a href="#step-1：梯度下降法推导-–-要推出来b-u和b-i的表达式" class="headerlink" title="step 1：梯度下降法推导 –(要推出来b_u和b_i的表达式)"></a>step 1：梯度下降法推导 –(要推出来b_u和b_i的表达式)</h6><p>损失函数：<br>$$<br>\begin{split}<br>&amp;J(\theta)=Cost=f(b_u, b_i)\<br>\<br>&amp;J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>\end{split}<br>$$<br>梯度下降参数更新原始公式：<br>$$<br>\theta_j:=\theta_j-\alpha\cfrac{\partial }{\partial \theta_j}J(\theta)<br>$$<br>(对$b_u$和$b_i$求偏导)</p>
<p>梯度下降更新$b_u$:</p>
<p>​    损失函数偏导推导：<br>$$<br>\begin{split}<br>\cfrac{\partial}{\partial b_u} J(\theta)&amp;=\cfrac{\partial}{\partial b_u} f(b_u, b_i)<br>\&amp;=2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)(-1) + 2\lambda{b_u}<br>\&amp;=-2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda<em>b_u<br>\end{split}<br>$$<br>​    $b_u$更新(因为alpha可以人为控制，所以2可以省略掉)：<br>$$<br>\begin{split}<br>b_u&amp;:=b_u - \alpha</em>(-\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + \lambda * b_u)\<br>&amp;:=b_u + \alpha<em>(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) - \lambda</em> b_u)<br>\end{split}<br>$$<br>同理可得，梯度下降更新$b_i$:<br>$$<br>b_i:=b_i + \alpha<em>(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) -\lambda</em>b_i)<br>$$</p>
<h6 id="step-2：随机梯度下降"><a href="#step-2：随机梯度下降" class="headerlink" title="step 2：随机梯度下降"></a>step 2：随机梯度下降</h6><p>由于<strong>随机梯度下降法</strong>本质上利用<strong>每个样本的损失</strong>来更新参数，而不用每次求出全部的损失和，因此使用SGD时：(随机梯度下降每次只考虑一个样本，所以不用上面的求和)</p>
<p>单样本损失值：<br>$$<br>\begin{split}<br>error &amp;=r_{ui}-\hat{r}<em>{ui}<br>\&amp;= r</em>{ui}-(\mu+b_u+b_i)<br>\&amp;= r_{ui}-\mu-b_u-b_i<br>\end{split}<br>$$<br>参数更新：<br>$$<br>\begin{split}<br>b_u&amp;:=b_u + \alpha<em>((r_{ui}-\mu-b_u-b_i) -\lambda*b_u)  \<br>&amp;:=b_u + \alpha</em>(error - \lambda<em>b_u) \<br>\<br>b_i&amp;:=b_i + \alpha</em>((r_{ui}-\mu-b_u-b_i) -\lambda<em>b_i)\<br>&amp;:=b_i + \alpha</em>(error -\lambda*b_i)<br>\end{split}<br>$$</p>
<h6 id="step-3：算法实现"><a href="#step-3：算法实现" class="headerlink" title="step 3：算法实现"></a>step 3：算法实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFBySGD</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, alpha, reg, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                <span class="comment"># for是为了把全部数据遍历一遍，上面的for保证了每个数据遍历20次</span></span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line">				<span class="comment"># 这边的bu和bi都是每个用户每个商品都不一样，相当于每个数都计算了20次</span></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = int(input(<span class="string">"uid: "</span>))</span><br><span class="line">        iid = int(input(<span class="string">"iid: "</span>))</span><br><span class="line">        print(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure>

<h6 id="Step-4-准确性指标评估"><a href="#Step-4-准确性指标评估" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><ul>
<li>添加test方法，然后使用之前实现accuary方法计算准确性指标</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_split</span><span class="params">(data_path, x=<span class="number">0.8</span>, random=False)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始切分数据集..."</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">"userId"</span>).any().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">"userId"</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = list(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    print(<span class="string">"完成数据集切分..."</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuray</span><span class="params">(predict_results, method=<span class="string">"all"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse_mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>), round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">"rmse"</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">"mae"</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFBySGD</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, alpha, reg, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># 学习率</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        <span class="comment"># 正则参数</span></span><br><span class="line">        self.reg = reg</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                error = real_rating - (self.global_mean + bu[uid] + bi[iid])</span><br><span class="line"></span><br><span class="line">                bu[uid] += self.alpha * (error - self.reg * bu[uid])</span><br><span class="line">                bi[iid] += self.alpha * (error - self.reg * bi[iid])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="string">'''评分预测'''</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据"</span>.format(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    trainset, testset = data_split(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFBySGD(<span class="number">20</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rmse: "</span>, rmse, <span class="string">"mae: "</span>, mae)</span><br></pre></td></tr></table></figure>

<h4 id="方法二：交替最小二乘法优化"><a href="#方法二：交替最小二乘法优化" class="headerlink" title="方法二：交替最小二乘法优化"></a>方法二：交替最小二乘法优化</h4><p>使用交替最小二乘法优化算法预测Baseline偏置值</p>
<h6 id="step-1-交替最小二乘法推导"><a href="#step-1-交替最小二乘法推导" class="headerlink" title="step 1: 交替最小二乘法推导"></a>step 1: 交替最小二乘法推导</h6><p>最小二乘法和梯度下降法一样，可以用于求极值。</p>
<p><strong>最小二乘法思想：对损失函数求偏导，然后再使偏导为0</strong></p>
<p>同样，损失函数：<br>$$<br>J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda<em>(\sum_u {b_u}^2 + \sum_i {b_i}^2)<br>$$<br>对损失函数求偏导：<br>$$<br>\cfrac{\partial}{\partial b_u} f(b_u, b_i) =-2 \sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda * b_u<br>$$<br>令偏导为0，则可得：<br>$$<br>\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) = \lambda</em> b_u<br>\\sum_{u,i\in R}(r_{ui}-\mu-b_i) = \sum_{u,i\in R} b_u+\lambda * b_u<br>$$<br>为了简化公式，这里令$\sum_{u,i\in R} b_u \approx |R(u)|*b_u$，即直接假设每一项的偏置都相等，可得：<br>$$<br>b_u := \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_i)}{\lambda_1 + |R(u)|}<br>$$<br>其中$|R(u)|$表示用户$u$的有过评分数量</p>
<p>同理可得：<br>$$<br>b_i := \cfrac {\sum_{u,i\in R}(r_{ui}-\mu-b_u)}{\lambda_2 + |R(i)|}<br>$$<br>其中$|R(i)|$表示物品$i$收到的评分数量</p>
<p>$b_u$和$b_i$分别属于用户和物品的偏置，因此他们的正则参数可以分别设置两个独立的参数</p>
<h6 id="step-2-交替最小二乘法应用"><a href="#step-2-交替最小二乘法应用" class="headerlink" title="step 2: 交替最小二乘法应用"></a>step 2: 交替最小二乘法应用</h6><p>通过最小二乘推导，我们最终分别得到了$b_u$和$b_i$的表达式，但他们的表达式中却又各自包含对方，因此这里我们将利用一种叫交替最小二乘的方法来计算他们的值：    </p>
<ul>
<li>计算其中一项，先固定其他未知参数，即看作其他未知参数为已知</li>
<li>如求$b_u$时，将$b_i$看作是已知；求$b_i$时，将$b_u$看作是已知；如此反复交替，不断更新二者的值，求得最终的结果。这就是<strong>交替最小二乘法（ALS）</strong></li>
</ul>
<h6 id="step-3-算法实现"><a href="#step-3-算法实现" class="headerlink" title="step 3: 算法实现"></a>step 3: 算法实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFByALS</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">als</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> zip(uids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _sum / (self.reg_bi + len(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> zip(iids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _sum / (self.reg_bu + len(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = int(input(<span class="string">"uid: "</span>))</span><br><span class="line">        iid = int(input(<span class="string">"iid: "</span>))</span><br><span class="line">        print(bcf.predict(uid, iid))</span><br></pre></td></tr></table></figure>

<h6 id="Step-4-准确性指标评估-1"><a href="#Step-4-准确性指标评估-1" class="headerlink" title="Step 4: 准确性指标评估"></a>Step 4: 准确性指标评估</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_split</span><span class="params">(data_path, x=<span class="number">0.8</span>, random=False)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    切分数据集， 这里为了保证用户数量保持不变，将每个用户的评分数据按比例进行拆分</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param x: 训练集的比例，如x=0.8，则0.2是测试集</span></span><br><span class="line"><span class="string">    :param random: 是否随机切分，默认False</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始切分数据集..."</span>)</span><br><span class="line">    <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">    dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">    <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">    ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    testset_index = []</span><br><span class="line">    <span class="comment"># 为了保证每个用户在测试集和训练集都有数据，因此按userId聚合</span></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> ratings.groupby(<span class="string">"userId"</span>).any().index:</span><br><span class="line">        user_rating_data = ratings.where(ratings[<span class="string">"userId"</span>]==uid).dropna()</span><br><span class="line">        <span class="keyword">if</span> random:</span><br><span class="line">            <span class="comment"># 因为不可变类型不能被 shuffle方法作用，所以需要强行转换为列表</span></span><br><span class="line">            index = list(user_rating_data.index)</span><br><span class="line">            np.random.shuffle(index)    <span class="comment"># 打乱列表</span></span><br><span class="line">            _index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(index[_index:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将每个用户的x比例的数据作为训练集，剩余的作为测试集</span></span><br><span class="line">            index = round(len(user_rating_data) * x)</span><br><span class="line">            testset_index += list(user_rating_data.index.values[index:])</span><br><span class="line"></span><br><span class="line">    testset = ratings.loc[testset_index]</span><br><span class="line">    trainset = ratings.drop(testset_index)</span><br><span class="line">    print(<span class="string">"完成数据集切分..."</span>)</span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuray</span><span class="params">(predict_results, method=<span class="string">"all"</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    准确性指标计算方法</span></span><br><span class="line"><span class="string">    :param predict_results: 预测结果，类型为容器，每个元素是一个包含uid,iid,real_rating,pred_rating的序列</span></span><br><span class="line"><span class="string">    :param method: 指标方法，类型为字符串，rmse或mae，否则返回两者rmse和mae</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rmse_mae</span><span class="params">(predict_results)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        rmse和mae评估指标</span></span><br><span class="line"><span class="string">        :param predict_results:</span></span><br><span class="line"><span class="string">        :return: rmse, mae</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        _rmse_sum = <span class="number">0</span></span><br><span class="line">        _mae_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating, pred_rating <span class="keyword">in</span> predict_results:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            _rmse_sum += (pred_rating - real_rating) ** <span class="number">2</span></span><br><span class="line">            _mae_sum += abs(pred_rating - real_rating)</span><br><span class="line">        <span class="keyword">return</span> round(np.sqrt(_rmse_sum / length), <span class="number">4</span>), round(_mae_sum / length, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method.lower() == <span class="string">"rmse"</span>:</span><br><span class="line">        rmse(predict_results)</span><br><span class="line">    <span class="keyword">elif</span> method.lower() == <span class="string">"mae"</span>:</span><br><span class="line">        mae(predict_results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> rmse_mae(predict_results)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaselineCFByALS</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number_epochs, reg_bu, reg_bi, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        <span class="comment"># 梯度下降最高迭代次数</span></span><br><span class="line">        self.number_epochs = number_epochs</span><br><span class="line">        <span class="comment"># bu的正则参数</span></span><br><span class="line">        self.reg_bu = reg_bu</span><br><span class="line">        <span class="comment"># bi的正则参数</span></span><br><span class="line">        self.reg_bi = reg_bi</span><br><span class="line">        <span class="comment"># 数据集中user-item-rating字段的名称</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        <span class="comment"># 用户评分数据</span></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 物品评分数据</span></span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        <span class="comment"># 计算全局平均分</span></span><br><span class="line">        self.global_mean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line">        <span class="comment"># 调用sgd方法训练模型参数</span></span><br><span class="line">        self.bu, self.bi = self.als()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">als</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        利用随机梯度下降，优化bu，bi的值</span></span><br><span class="line"><span class="string">        :return: bu, bi</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 初始化bu、bi的值，全部设为0</span></span><br><span class="line">        bu = dict(zip(self.users_ratings.index, np.zeros(len(self.users_ratings))))</span><br><span class="line">        bi = dict(zip(self.items_ratings.index, np.zeros(len(self.items_ratings))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span> % i)</span><br><span class="line">            <span class="keyword">for</span> iid, uids, ratings <span class="keyword">in</span> self.items_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> uid, rating <span class="keyword">in</span> zip(uids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bu[uid]</span><br><span class="line">                bi[iid] = _sum / (self.reg_bi + len(uids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> uid, iids, ratings <span class="keyword">in</span> self.users_ratings.itertuples(index=<span class="literal">True</span>):</span><br><span class="line">                _sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> iid, rating <span class="keyword">in</span> zip(iids, ratings):</span><br><span class="line">                    _sum += rating - self.global_mean - bi[iid]</span><br><span class="line">                bu[uid] = _sum / (self.reg_bu + len(iids))</span><br><span class="line">        <span class="keyword">return</span> bu, bi</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="string">'''评分预测'''</span></span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"无法预测用户&lt;&#123;uid&#125;&gt;对电影&lt;&#123;iid&#125;&gt;的评分，因为训练集中缺失&lt;&#123;iid&#125;&gt;的数据"</span>.format(uid=uid, iid=iid))</span><br><span class="line"></span><br><span class="line">        predict_rating = self.global_mean + self.bu[uid] + self.bi[iid]</span><br><span class="line">        <span class="keyword">return</span> predict_rating</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    trainset, testset = data_split(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, random=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bcf = BaselineCFByALS(<span class="number">20</span>, <span class="number">25</span>, <span class="number">15</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    bcf.fit(trainset)</span><br><span class="line"></span><br><span class="line">    pred_results = bcf.test(testset)</span><br><span class="line"></span><br><span class="line">    rmse, mae = accuray(pred_results)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"rmse: "</span>, rmse, <span class="string">"mae: "</span>, mae)</span><br></pre></td></tr></table></figure>

<h2 id="基于矩阵分解的CF算法"><a href="#基于矩阵分解的CF算法" class="headerlink" title="基于矩阵分解的CF算法"></a>基于矩阵分解的CF算法</h2><h4 id="矩阵分解发展史"><a href="#矩阵分解发展史" class="headerlink" title="矩阵分解发展史"></a>矩阵分解发展史</h4><p><strong>Traditional SVD:</strong></p>
<p>通常SVD矩阵分解指的是SVD（奇异值）分解技术，在这我们姑且将其命名为Traditional SVD（传统并经典着）其公式如下：</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qBJOS.jpg" alt="8qBJOS.jpg"></p>
<p>Traditional SVD分解的形式为3个矩阵相乘，中间矩阵为奇异值矩阵。如果想运用SVD分解的话，有一个前提是要求矩阵是稠密的，即矩阵里的元素要非空，否则就不能运用SVD分解。</p>
<p>很显然我们的数据其实绝大多数情况下都是稀疏的，因此如果要使用Traditional SVD，一般的做法是先用均值或者其他统计学方法来填充矩阵，然后再运用Traditional SVD分解降维，但这样做明显对数据的原始性造成一定影响。</p>
<p><strong>FunkSVD（LFM）</strong></p>
<p>刚才提到的Traditional SVD首先需要填充矩阵，然后再进行分解降维，同时存在计算复杂度高的问题，因为要分解成3个矩阵，所以后来提出了Funk SVD的方法，它不在将矩阵分解为3个矩阵，而是分解为2个用户-隐含特征，项目-隐含特征的矩阵，Funk SVD也被称为最原始的LFM模型</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qBwYn.jpg" alt="8qBwYn.jpg"></p>
<p>借鉴线性回归的思想，通过最小化观察数据的平方来寻求最优的用户和项目的隐含向量表示。同时为了避免过度拟合（Overfitting）观测数据，又提出了带有L2正则项的FunkSVD，上公式：</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qBrlV.jpg" alt="8qBrlV.jpg"></p>
<p>以上两种最优化函数都可以通过梯度下降或者随机梯度下降法来寻求最优解。</p>
<p><strong>BiasSVD:</strong></p>
<p>在FunkSVD提出来之后，出现了很多变形版本，其中一个相对成功的方法是BiasSVD，顾名思义，即带有偏置项的SVD分解：</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qBfYR.jpg" alt="8qBfYR.jpg"></p>
<p>它基于的假设和Baseline基准预测是一样的，但这里将Baseline的偏置引入到了矩阵分解中</p>
<p><strong>SVD++:</strong></p>
<p>人们后来又提出了改进的BiasSVD，被称为SVD++，该算法是在BiasSVD的基础上添加了用户的隐式反馈信息：</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qB5Sx.jpg" alt="8qB5Sx.jpg"></p>
<p>显示反馈指的用户的评分这样的行为，隐式反馈指用户的浏览记录、购买记录、收听记录等。</p>
<p>SVD++是基于这样的假设：在BiasSVD基础上，认为用户对于项目的历史浏览记录、购买记录、收听记录等可以从侧面反映用户的偏好。</p>
<h2 id="基于矩阵分解的CF算法实现（一）：LFM"><a href="#基于矩阵分解的CF算法实现（一）：LFM" class="headerlink" title="基于矩阵分解的CF算法实现（一）：LFM"></a>基于矩阵分解的CF算法实现（一）：LFM</h2><p>LFM也就是前面提到的Funk SVD矩阵分解</p>
<h4 id="LFM原理解析"><a href="#LFM原理解析" class="headerlink" title="LFM原理解析"></a>LFM原理解析</h4><p>LFM(latent factor model)隐语义模型核心思想是通过隐含特征联系用户和物品，如下图：</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qD5Nj.png" alt="8qD5Nj.png"><img src="/img/LFM%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E5%9B%BE%E8%A7%A3.png" alt></p>
<ul>
<li>P矩阵是User-LF矩阵，即用户和隐含特征矩阵。LF有三个，表示共总有三个隐含特征。</li>
<li>Q矩阵是LF-Item矩阵，即隐含特征和物品的矩阵</li>
<li>R矩阵是User-Item矩阵，有P*Q得来</li>
<li><strong>能处理稀疏评分矩阵</strong></li>
</ul>
<p>利用矩阵分解技术，将原始User-Item的评分矩阵（稠密/稀疏）分解为P和Q矩阵，然后利用$P*Q$还原出User-Item评分矩阵$R$。整个过程相当于降维处理，其中：</p>
<ul>
<li><p>矩阵值$P_{11}$表示用户1对隐含特征1的权重值</p>
</li>
<li><p>矩阵值$Q_{11}$表示隐含特征1在物品1上的权重值</p>
</li>
<li><p>矩阵值$R_{11}$就表示预测的用户1对物品1的评分，且$R_{11}=\vec{P_{1,k}}\cdot \vec{Q_{k,1}}$</p>
<p><img src="https://s1.ax1x.com/2020/03/24/8qDWDS.png" alt="8qDWDS.png"></p>
</li>
</ul>
<p>利用LFM预测用户对物品的评分，$k$表示隐含特征数量：<br>$$<br>\begin{split}<br>\hat {r}<em>{ui} &amp;=\vec {p</em>{uk}}\cdot \vec {q_{ik}}<br>\&amp;={\sum_{k=1}}^k p_{uk}q_{ik}<br>\end{split}<br>$$<br>因此最终，我们的目标也就是要求出P矩阵和Q矩阵及其当中的每一个值，然后再对用户-物品的评分进行预测。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>同样对于评分预测我们利用平方差来构建损失函数：<br>$$<br>\begin{split}<br>Cost &amp;= \sum_{u,i\in R} (r_{ui}-\hat{r}<em>{ui})^2<br>\&amp;=\sum</em>{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2<br>\end{split}<br>$$<br>加入L2正则化：<br>$$<br>Cost = \sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)<br>$$<br>对损失函数求偏导：<br>$$<br>\begin{split}<br>\cfrac {\partial}{\partial p_{uk}}Cost &amp;= \cfrac {\partial}{\partial p_{uk}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]<br>\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}<br>\\<br>\cfrac {\partial}{\partial q_{ik}}Cost &amp;= \cfrac {\partial}{\partial q_{ik}}[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})^2 + \lambda(\sum_U{p_{uk}}^2+\sum_I{q_{ik}}^2)]<br>\&amp;=2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-p_{uk}) + 2\lambda q_{ik}<br>\end{split}<br>$$</p>
<h4 id="随机梯度下降法优化"><a href="#随机梯度下降法优化" class="headerlink" title="随机梯度下降法优化"></a>随机梯度下降法优化</h4><p>梯度下降更新参数$p_{uk}$：<br>$$<br>\begin{split}<br>p_{uk}&amp;:=p_{uk} - \alpha\cfrac {\partial}{\partial p_{uk}}Cost<br>\&amp;:=p_{uk}-\alpha [2\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})(-q_{ik}) + 2\lambda p_{uk}]<br>\&amp;:=p_{uk}+\alpha [\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda p_{uk}]<br>\end{split}<br>$$<br> 同理：<br>$$<br>\begin{split}<br>q_{ik}&amp;:=q_{ik} + \alpha[\sum_{u,i\in R} (r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda q_{ik}]<br>\end{split}<br>$$<br><strong>随机梯度下降：</strong> 向量乘法 每一个分量相乘 求和<br>$$<br>\begin{split}<br>&amp;p_{uk}:=p_{uk}+\alpha [(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})q_{ik} - \lambda_1 p_{uk}]<br>\&amp;q_{ik}:=q_{ik} + \alpha[(r_{ui}-{\sum_{k=1}}^k p_{uk}q_{ik})p_{uk} - \lambda_2 q_{ik}]<br>\end{split}<br>$$<br>由于P矩阵和Q矩阵是两个不同的矩阵，通常分别采取不同的正则参数，如$\lambda_1$和$\lambda_2$</p>
<p><strong>算法实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">LFM Model</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评分预测    1-5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFM</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, reg_p, reg_q, number_LatentFactors=<span class="number">10</span>, number_epochs=<span class="number">10</span>, columns=[<span class="string">"uid"</span>, <span class="string">"iid"</span>, <span class="string">"rating"</span>])</span>:</span></span><br><span class="line">        self.alpha = alpha <span class="comment"># 学习率</span></span><br><span class="line">        self.reg_p = reg_p    <span class="comment"># P矩阵正则</span></span><br><span class="line">        self.reg_q = reg_q    <span class="comment"># Q矩阵正则</span></span><br><span class="line">        self.number_LatentFactors = number_LatentFactors  <span class="comment"># 隐式类别数量</span></span><br><span class="line">        self.number_epochs = number_epochs    <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, dataset)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        fit dataset</span></span><br><span class="line"><span class="string">        :param dataset: uid, iid, rating</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        self.dataset = pd.DataFrame(dataset)</span><br><span class="line"></span><br><span class="line">        self.users_ratings = dataset.groupby(self.columns[<span class="number">0</span>]).agg([list])[[self.columns[<span class="number">1</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line">        self.items_ratings = dataset.groupby(self.columns[<span class="number">1</span>]).agg([list])[[self.columns[<span class="number">0</span>], self.columns[<span class="number">2</span>]]]</span><br><span class="line"></span><br><span class="line">        self.globalMean = self.dataset[self.columns[<span class="number">2</span>]].mean()</span><br><span class="line"></span><br><span class="line">        self.P, self.Q = self.sgd()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_matrix</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        初始化P和Q矩阵，同时为设置0，1之间的随机值作为初始值--防止×完全是0</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># User-LF</span></span><br><span class="line">        <span class="comment"># random.rand(x)取值范围是 [0,1)</span></span><br><span class="line">        P = dict(zip(</span><br><span class="line">            self.users_ratings.index,</span><br><span class="line">            np.random.rand(len(self.users_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="comment"># Item-LF</span></span><br><span class="line">        Q = dict(zip(</span><br><span class="line">            self.items_ratings.index,</span><br><span class="line">            np.random.rand(len(self.items_ratings), self.number_LatentFactors).astype(np.float32)</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sgd</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        使用随机梯度下降，优化结果</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        P, Q = self._init_matrix()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.number_epochs):</span><br><span class="line">            print(<span class="string">"iter%d"</span>%i)</span><br><span class="line">            error_list = []</span><br><span class="line">            <span class="keyword">for</span> uid, iid, r_ui <span class="keyword">in</span> self.dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">                <span class="comment"># User-LF P</span></span><br><span class="line">                <span class="comment">## Item-LF Q</span></span><br><span class="line">                v_pu = P[uid] <span class="comment">#用户向量！！这是一个向量，PQ是矩阵</span></span><br><span class="line">                v_qi = Q[iid] <span class="comment">#物品向量</span></span><br><span class="line">                err = np.float32(r_ui - np.dot(v_pu, v_qi))</span><br><span class="line"></span><br><span class="line">                v_pu += self.alpha * (err * v_qi - self.reg_p * v_pu)</span><br><span class="line">                v_qi += self.alpha * (err * v_pu - self.reg_q * v_qi)</span><br><span class="line">                </span><br><span class="line">                P[uid] = v_pu </span><br><span class="line">                Q[iid] = v_qi</span><br><span class="line">				<span class="comment"># 或者不从向量的角度考虑</span></span><br><span class="line">                <span class="comment"># for k in range(self.number_of_LatentFactors):</span></span><br><span class="line">                <span class="comment">#     v_pu[k] += self.alpha*(err*v_qi[k] - self.reg_p*v_pu[k])</span></span><br><span class="line">                <span class="comment">#     v_qi[k] += self.alpha*(err*v_pu[k] - self.reg_q*v_qi[k])</span></span><br><span class="line"></span><br><span class="line">                error_list.append(err ** <span class="number">2</span>)</span><br><span class="line">            print(np.sqrt(np.mean(error_list)))</span><br><span class="line">        <span class="keyword">return</span> P, Q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, uid, iid)</span>:</span></span><br><span class="line">        <span class="comment"># 如果uid或iid不在，我们使用全剧平均分作为预测结果返回</span></span><br><span class="line">        <span class="keyword">if</span> uid <span class="keyword">not</span> <span class="keyword">in</span> self.users_ratings.index <span class="keyword">or</span> iid <span class="keyword">not</span> <span class="keyword">in</span> self.items_ratings.index:</span><br><span class="line">            <span class="keyword">return</span> self.globalMean</span><br><span class="line"></span><br><span class="line">        p_u = self.P[uid]</span><br><span class="line">        q_i = self.Q[iid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.dot(p_u, q_i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self,testset)</span>:</span></span><br><span class="line">        <span class="string">'''预测测试集数据'''</span></span><br><span class="line">        <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> testset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                pred_rating = self.predict(uid, iid)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> uid, iid, real_rating, pred_rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">    dataset = pd.read_csv(<span class="string">"datasets/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line"></span><br><span class="line">    lfm = LFM(<span class="number">0.02</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">10</span>, <span class="number">100</span>, [<span class="string">"userId"</span>, <span class="string">"movieId"</span>, <span class="string">"rating"</span>])</span><br><span class="line">    lfm.fit(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        uid = input(<span class="string">"uid: "</span>)</span><br><span class="line">        iid = input(<span class="string">"iid: "</span>)</span><br><span class="line">        print(lfm.predict(int(uid), int(iid)))</span><br></pre></td></tr></table></figure>


      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
          
            <a href="/tags/spark/" rel="tag"><i class="fa fa-tag"></i> spark</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/14/centos硬盘扩容到根目录/" rel="next" title="centos硬盘扩容到根目录">
                <i class="fa fa-chevron-left"></i> centos硬盘扩容到根目录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/16/机器学习算法/" rel="prev" title="机器学习算法">
                机器学习算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/touxiang.jpg" alt="Shiwei-Yan">
  
  <p class="site-author-name" itemprop="name">Shiwei-Yan</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>







  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Yanin-dpdt" title="GitHub &rarr; https://github.com/Yanin-dpdt" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:Yanin-dpdt@foxmail.com" title="E-Mail &rarr; mailto:Yanin-dpdt@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#推荐系统基础"><span class="nav-number">1.</span> <span class="nav-text">推荐系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#推荐系统简介"><span class="nav-number">1.1.</span> <span class="nav-text">推荐系统简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐的概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">推荐的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-架构介绍"><span class="nav-number">1.1.2.</span> <span class="nav-text">Lambda 架构介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐算法架构"><span class="nav-number">1.1.3.</span> <span class="nav-text">推荐算法架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推荐算法"><span class="nav-number">1.2.</span> <span class="nav-text">推荐算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-推荐模型构建流程"><span class="nav-number">1.2.1.</span> <span class="nav-text">一 推荐模型构建流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）"><span class="nav-number">1.2.2.</span> <span class="nav-text">二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#协同过滤-CF-思路介绍"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">协同过滤(CF)思路介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-相似度计算-Similarity-Calculation"><span class="nav-number">1.2.3.</span> <span class="nav-text">三 相似度计算(Similarity Calculation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相似度计算"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">相似度计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用不同相似度计算方式实现协同过滤"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">使用不同相似度计算方式实现协同过滤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协同过滤推荐算法代码实现："><span class="nav-number">1.2.4.</span> <span class="nav-text">协同过滤推荐算法代码实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用协同过滤推荐算法对用户进行评分预测"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">使用协同过滤推荐算法对用户进行评分预测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于模型的方法–解决用户和物品矩阵比较稀疏的情况"><span class="nav-number">1.2.5.</span> <span class="nav-text">基于模型的方法–解决用户和物品矩阵比较稀疏的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-推荐系统评估"><span class="nav-number">1.3.</span> <span class="nav-text">四 推荐系统评估</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五-推荐系统的冷启动问题"><span class="nav-number">1.3.1.</span> <span class="nav-text">五 推荐系统的冷启动问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#案例–基于协同过滤的电影推荐"><span class="nav-number">1.4.</span> <span class="nav-text">案例–基于协同过滤的电影推荐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据集下载"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">数据集下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据集加载"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">数据集加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相似度计算-1"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">相似度计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#案例–算法实现：User-Based-CF-预测评分"><span class="nav-number">1.5.</span> <span class="nav-text">案例–算法实现：User-Based CF 预测评分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算法实现"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">算法实现</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#案例–算法实现：Item-Based-CF-预测评分"><span class="nav-number">1.6.</span> <span class="nav-text">案例–算法实现：Item-Based CF 预测评分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Model-Based-协同过滤算法"><span class="nav-number">1.6.1.</span> <span class="nav-text">Model-Based 协同过滤算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于K最近邻的协同过滤推荐"><span class="nav-number">1.7.</span> <span class="nav-text">基于K最近邻的协同过滤推荐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于回归模型的协同过滤推荐"><span class="nav-number">1.8.</span> <span class="nav-text">基于回归模型的协同过滤推荐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Baseline：基准预测"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">Baseline：基准预测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一：随机梯度下降法优化"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">方法一：随机梯度下降法优化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#step-1：梯度下降法推导-–-要推出来b-u和b-i的表达式"><span class="nav-number">1.8.0.2.0.1.</span> <span class="nav-text">step 1：梯度下降法推导 –(要推出来b_u和b_i的表达式)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#step-2：随机梯度下降"><span class="nav-number">1.8.0.2.0.2.</span> <span class="nav-text">step 2：随机梯度下降</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#step-3：算法实现"><span class="nav-number">1.8.0.2.0.3.</span> <span class="nav-text">step 3：算法实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Step-4-准确性指标评估"><span class="nav-number">1.8.0.2.0.4.</span> <span class="nav-text">Step 4: 准确性指标评估</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二：交替最小二乘法优化"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">方法二：交替最小二乘法优化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#step-1-交替最小二乘法推导"><span class="nav-number">1.8.0.3.0.1.</span> <span class="nav-text">step 1: 交替最小二乘法推导</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#step-2-交替最小二乘法应用"><span class="nav-number">1.8.0.3.0.2.</span> <span class="nav-text">step 2: 交替最小二乘法应用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#step-3-算法实现"><span class="nav-number">1.8.0.3.0.3.</span> <span class="nav-text">step 3: 算法实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Step-4-准确性指标评估-1"><span class="nav-number">1.8.0.3.0.4.</span> <span class="nav-text">Step 4: 准确性指标评估</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于矩阵分解的CF算法"><span class="nav-number">1.9.</span> <span class="nav-text">基于矩阵分解的CF算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵分解发展史"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">矩阵分解发展史</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于矩阵分解的CF算法实现（一）：LFM"><span class="nav-number">1.10.</span> <span class="nav-text">基于矩阵分解的CF算法实现（一）：LFM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LFM原理解析"><span class="nav-number">1.10.0.1.</span> <span class="nav-text">LFM原理解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#损失函数"><span class="nav-number">1.10.0.2.</span> <span class="nav-text">损失函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机梯度下降法优化"><span class="nav-number">1.10.0.3.</span> <span class="nav-text">随机梯度下降法优化</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shiwei-Yan</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">275k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">4:10</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </div>
  </div>



<script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("07/23/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </footer></div>
    

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    

  

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  



  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>







  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  











  








  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>














<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
